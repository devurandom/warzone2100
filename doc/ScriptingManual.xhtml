<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="content-language" content="en" />
		<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
		<meta http-equiv="content-style-type" content="text/css; charset=UTF-8" />
		<meta name="author" content="Troman"/>
		<link rel="stylesheet" type="text/css" media="screen" href="styles/readme.screen.css" />
		<link rel="stylesheet" type="text/css" media="print" href="styles/readme.print.css" />
		<title>AI scripting language manual for Warzone 2100</title>
	</head>
	<body>
		<div id="content">
			<div id="navigation">
				<h1 id="top">Content</h1>
				<ul>
					<li><a href="#aimanual" class="locallink">Warzone 2100 - AI scripting language manual</a>
						<ul>
							<li><a href="#introduction" class="locallink">Introduction</a>
								<ul>
									<li><a href="#comments" class="locallink">Comments</a></li>
									<li><a href="#vlo" class="locallink">Vlo files</a></li>
									<li><a href="#slo" class="locallink">Slo files</a></li>
									<li><a href="#concept_event_trigger" class="locallink">Event/trigger concept</a></li>
									<li><a href="#triggers" class="locallink">Triggers</a></li>
								</ul>
							</li>
							<li><a href="#expressions" class="locallink">Expressions</a>
								<ul>
									<li><a href="#string_expressions" class="locallink">String expressions</a></li>
									<li><a href="#numeric_expressions" class="locallink">Numeric expressions</a></li>
									<li><a href="#boolean_expressions" class="locallink">Boolean expressions</a></li>
									<li><a href="#floatingpoint_expressions" class="locallink">Floating point expressions</a></li>
								</ul>
							</li>
							<li><a href="#assignment" class="locallink">Assignment</a></li>
							<li><a href="#if_statements" class="locallink">If statements</a></li>
							<li><a href="#while_statements" class="locallink">While statements</a></li>
							<li><a href="#casts" class="locallink">Casts</a></li>
							<li><a href="#custom_functions" class="locallink">Custom functions</a></li>
							<li><a href="#local_variables" class="locallink">Local variables</a></li>
							<li><a href="#macros" class="locallink">Macros</a></li>
							<li><a href="#data_types" class="locallink">Data types</a></li>
							<li><a href="#script_functions" class="locallink">Appendix A: Script functions</a>
								<ul>
									<li><a href="#sf_standard_functions" class="locallink">Standard functions</a></li>
									<li><a href="#sf_type_conversion" class="locallink">Type conversion</a></li>
									<li><a href="#sf_objects" class="locallink">Objects</a></li>
									<li><a href="#sf_structures" class="locallink">Structures</a></li>
									<li><a href="#sf_features" class="locallink">Features</a></li>
									<li><a href="#sf_droids" class="locallink">Droids</a></li>
									<li><a href="#sf_templates" class="locallink">Templates</a></li>
									<li><a href="#sf_research" class="locallink">Research</a></li>
									<li><a href="#sf_components" class="locallink">Components</a></li>
									<li><a href="#sf_power" class="locallink">Power</a></li>
									<li><a href="#sf_environment_map" class="locallink">Environment/Map</a></li>
									<li><a href="#sf_game_states" class="locallink">Game states</a></li>
									<li><a href="#sf_diplomacy" class="locallink">Diplomacy</a></li>
									<li><a href="#sf_strategy" class="locallink">Strategy</a></li>
									<li><a href="#sf_gui" class="locallink"><acronym title="Graphical User Interface">GUI</acronym></a></li>
									<li><a href="#sf_multimedia" class="locallink">Multimedia</a></li>
									<li><a href="#sf_unsorted" class="locallink">Unsorted</a></li>
								</ul>
							</li>
								<li><a href="#debugging_script_functions" class="locallink">Appendix B: Debugging script functions</a></li>
								<li><a href="#script_function_constants" class="locallink">Appendix C: Script function constants</a></li>
								<li><a href="#script_function_externals" class="locallink">Appendix D: Script function externals</a></li>
								<li><a href="#script_function_callbacks" class="locallink">Appendix E: Script function callbacks</a></li>
						</ul>
					</li>
				</ul>
			</div>
			<hr />

			<h1 id="aimanual">Warzone 2100 - AI scripting language manual</h1>

			<h2 id="introduction">Introduction</h2>
			<p>In order for Warzone scripts to function properly two files are required: a file with a .slo extension and a file with a .vlo extension.</p>
			<p>A .slo file is the main part of the script and holds executable instructions while the .vlo file holds additional variable declarations necessary for the .slo file to function properly.</p>
			<p>It is common for a script to deal with new or existing game components such as research topics, structures, unit bodies, propulsions, weapons etc. All these components are defined in appropriate text files like body.txt, structure.txt etc. If you want to use any of these components in your script - in your .slo file - like for example if you want to place certain structures on the map using scripts or enable certain research, you must first make these components available to your script by defining them in a .vlo file.</p>
			<p>Roughly said a .slo file is equivalent to a ".c" file and .vlo to a header file in C/C++.</p>
			<p>Specific skirmish/multiplayer notes:</p>
			<p>Some of the file below does not apply to skirmish scripts! Make your changes to player0.slo and vlo -&gt; player7.slo and vlo.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="comments">Comments</h3>
			<p>There are two type of comment for the script language. A multi-line comment is started by the characters /* and finishes with */. A single line comment is started by //.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="vlo">Vlo files</h3>
			<p>When writing a script it is usually known what data (as defined in data .txt files, located in 'stats' folder) will be used in the script, so it is a good idea to start writing the script with a .vlo file.</p>
			<p>Vlo files are structured as follows:</p>
			<pre>script "myScript.slo"
run
{
 &lt;variable_definitions&gt;
}</pre>
			<p>In the first line a .slo file is attached to this particular .vlo file. variable_definitions that resides inside the curly braces is the heart of every .vlo file, it contains definitions of the data that will be used in the main script part - the .slo file. Each variable definition starts on a new line and is structured as follows:</p>
			<pre>&lt;variable_name&gt; &lt;variable_type&gt; &lt;variable_value&gt;</pre>
			<p class="note">NOTE: Available data types are covered later.</p>
			<p>For example if you want to have access to certain droid bodies, like "Python" in your script you have to define it in your .vlo file and assign it to a variable of type BODY with some descriptive name, like:</p>
			<pre>myPythonBody BODY "Body11ABT"</pre>
			<p>"Body11ABT" is an internal name of the "Python" body used by warzone, it is defined in the body.txt file. Since it is a string it must be put inside quotation marks. All components, be it some research, structure, droid template or a weapon is referred by its internal name in the game and are defined in the appropriate txt data files.</p>
			<p>Each variable definition in a .vlo file starts on the new line and ends at the end of the line.</p>
			<p>It is also possible to define arrays of some data type. For example if you want to use the following 3 research topics in your script you might want to define them like this:</p>
			<pre>myResearch[0] RESEARCHSTAt "R-Vehicle-Body11"
myResearch[1] RESEARCHSTAt "R-Vehicle-Prop-Tracks"
myResearch[2] RESEARCHSTAt "R-Vehicle-Prop-Hover"</pre>
			<p>This defines an array of size 3 of type RESEARCHSTAT.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="slo">Slo files</h3>
			<p>As already mentioned .slo file is the heart of every script, it is the place for the executable code. Slo files can be devided into 3 main parts:</p>
			<ol>
				<li>Variable declarations</li>
				<li>Event and function declaration</li>
				<li>Executable code</li>
			</ol>
			<p>Variables used throughout the script are defined in the Variable declarations part, with exception of the local variables, which are explained later.</p>
			<p>For the .slo file to be able to access variables declared in the .vlo file they must be declared as public variables in the corresponding .slo file.</p>
			<p>Coming back to the two examples above you will have to add following lines to the .slo file:</p>
			<pre>public BODy myPythonBody;
public RESEARCHSTAT myResearch[3];</pre>
			<p>Keyword <code>public</code> signals that the variable is defined in the corresponding .vlo files. Note that unlike in .vlo files variable declarations in .slo files end with a semicolon and unlike in .vlo files it is possible to declare more than one variable of the same type at once.</p>
			<p>More generally a variable declaration in a .slo file looks like this:</p>
			<pre>&lt;storage&gt; &lt;variable_type&gt; &lt;variable_name1&gt; [, &lt;variable_name2&gt;, ...];</pre>
			<p><code>storage</code> is one of <code>public</code> or <code>private</code>. <code>public</code> means that the variable is declared and defined in the corresponding .vlo file. <code>private</code> means the value is only used in the .slo file. Unlike local variables public and private variables are global variables that can be access from anywhere in the .slo file.</p>
			<p class="note">NOTE: All variables are initialized to their default values when created. STRUCTURE/DROID/FEATURE variables are initialized to NULLOBJECT, STRINGs to "", FLOATs to 0.0, INTs to 0, BOOLs to FALSE etc.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="concept_event_trigger">Event/trigger concept</h3>
			<p>In Warzone 2100 scripts executable code consists of events. An event is a list of instructions activated by some trigger attached to it. Event defines what to do, a trigger defines when to run an event, i. e. when to execute the code inside an event.</p>
			<p>All events are structured as follows:</p>
			<pre>event &lt;event_name&gt;(&lt;trigger&gt;)
{
 &lt;code&gt;
}</pre>
			<p>Example:</p>
			<pre>event myFirstEvent(every, 50)
{
 console("Hello world!");
}</pre>
			<p>This piece of code will output "Hello world!" to the game console every 5 seconds. Note that triggers are put inside the round braces after the event name while code that is to be executed resides inside the curly braces. The syntax of the executable code is very close to the C/C++ syntax.</p>
			<p>The only difference between a WZ event and a function as used in programming languages like C/C++ is that an event is not called or activated by another function, but rather by a trigger attached to it.</p>
			<p>It is always possible to interrupt execution of an event with the <code>exit</code> keyword, which is a counterpart of the <code>return</code> keyword used for functions; <code>exit</code> keyword does not deactivate an event.</p>
			<p>Example:</p>
			<pre>event myEvent(every, 10) //run every second
{
 console ("this text will be printed every second");
 if((gameTime / 10) &gt; 60) //did more than a minute pass?
	{
	 exit; //anything that comes after 'exit' will not be executed
	 console("this text will only get printed in the first");
	}
}</pre>
			<p>Events must be defined before they can be referenced. If event definition comes after the place where this event is referenced it is necessary to declare this event beforehand in the event and function declaration section.</p>
			<p>Events are declared like this:</p>
			<pre>event &lt;event_name&gt;;</pre>
			<p>Such a declaration reserves identifier used as event name.</p>
			<p>Example:</p>
			<pre>event myEvent; //declaration of the event
...
// another event that references myEvent
event anotherEvent(wait, 10)
{
 setEventTrigger(myEvent, inactive); //deactivate myEvent
}
...
// myEvent is defined after being referenced by anotherEvent, 
// but it works, since we declared myEvent beforehand
event myEvent(wait, 20)
{
 console("It all compiles, because I was declared beforehand!");
}</pre>
			<p>If	myEvent was not declared before being referenced by anotherEvent then this example would not compile.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="triggers">Triggers</h3>
			<p>In Warzone 2100 triggers are usually simple timers that repeatedly trigger execution of events, but triggers can also be callbacks (special events that occur in the game, like destruction of a building) that are listed and explained later.</p>
			<p>Here are available trigger types:</p>
			<table>
				<tr>
					<th>Trigger type</th>
					<th>Effect</th>
				</tr>
				<tr>
					<td><code>wait, &lt;time&gt;</code></td>
					<td>Run the event after delay <code>&lt;time&gt;</code>.</td>
				</tr>
				<tr>
					<td><code>every, &lt;time&gt;</code></td>
					<td>Run the event at every <code>&lt;time&gt;</code> interval.</td>
				</tr>
				<tr>
					<td><code>&lt;callback&gt;</code></td>
					<td>Run when <code>callback</code> occurs.</td>
				</tr>
				<tr>
					<td><code>&lt;bool exp&gt;, &lt;time&gt;</code></td>
					<td>Run the event if <code>&lt;bool exp&gt;</code> is true, checking every <code>&lt;time&gt;</code> interval.</td>
				</tr>
				<tr>
					<td><code>init</code></td>
					<td>Run the event when the script starts.</td>
				</tr>
				<tr>
					<td><code>inactive</code></td>
					<td>Do not run the event until a trigger is assigned to it.</td>
				</tr>
			</table>
			<p class="note">NOTE: All time intervals are in 1/10 of a second.</p>
			<p>For example <code>every, 10</code> will trigger every second while <code>wait, 50</code> will only activate once: 5 seconds after the game has started. If an event has <code>inactive</code> assigned as a trigger this event will never execute unless its trigger is reassigned by some other event with <code>setEventTrigger(&lt;event&gt;, &lt;trigger&gt;)</code> function.</p>
			<p class="note">NOTE: Complete function and callback listings are given below.</p>
			<p>A few examples:</p>
			<pre>// 1. output text to game console every second
event everySecond(every, 10)
{
 console("The game has started " + gameTime/10 + " seconds ago");
}

// 2. Code inside this event will never execute unless its event is reassigned later
event inactiveEvent(inactive)
{
 console("Someone has just reactivated me!");
}

// 3. CALL_NEWDROID callback with parameters
event droidBuilt(CALL_NEWDROID, 5, ref newDroid, ref myFactory)
{
 console("We got a new droid at coordinates " &amp;
         newDroid.x &amp; "-" &amp; newDroid.y);
}</pre>
			<p>In the last example <code>droidBuilt</code> event will be triggered everytime a factory belonging to player 5 produces a new droid. <code>newDroid</code> variable refers to the new droid that was just built and	<code>myFactory</code> to the factory that build this droid. This example assumes that <code>newDroid</code> and	<code>myFactory</code> were correctly defined in the variable declarations section. For more callbacks see <a href="#script_function_callbacks" class="locallink">Script function callbacks</a>.</p>
			<p class="note">NOTE: <code>ref</code> keyword means that a pointer to the provided variable is passed to the interpreter, so that a callback can modify value of the variable.</p>
			<p>It is possible to reuse a trigger for more than one event if a trigger is declared in the event and function declaration. Trigger declaration has following syntax:</p>
			<pre>trigger &lt;trigger_name&gt; (&lt;trigger&gt;);</pre>
			<p>Example:</p>
			<pre>trigger everySecond (every, 10); //trigger declaration
...
event eventOne(everySecond) // uses the trigger we declared above
{
 ...
}

event eventTwo(everySecond) // uses the trigger we declared above
{
 ...
}</pre>
			<p>In this example <code>everySecond</code> trigger is defined outside of an event. Such a trigger can be reused by its name. Note that trigger declaration ends with a semicolon.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="expressions">Expressions</h2>
			<h3 id="string_Expressions">String expressions</h3>
			<p>Strings are put inside quotation marks: <code>"some text inside quotation marks is a legal string"</code>.</p>
			<p>Strings can be easily concatenated using the <code>&amp;</code> operator.</p>
			<p>For example: <code>"String1" &amp; "String2"</code> will result in "String1String2".</p>
			<p>Strings can be compared using <code>==</code> operator (case insensitive comparison) or <code>strcmp()</code> function.</p>
			<p>Such data types as integers, booleans and floats are automatically converted to strings when it is required, so given the following variable declaration:</p>
			<pre>private float pi;
private int myInteger;
private string myString;
private bool myBool;</pre>
			<p>The following line is a valid string expression:</p>
			<pre>console("value of pi is " &amp; pi &amp; ", value of myInteger is " &amp; myInteger &amp; ", 
value of myString is " &amp; myString &amp; ", value of myBool is " &amp; myBool);</pre>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="numeric_expressions">Numeric expressions</h3>
			<p>Numeric expressions are made up of int variables, numeric constants and functions that return int values, e. g.:</p>
			<pre>power * 32 - basePower
numDroids(player) + 5</pre>
			<p>The possible operators are: <code>+</code> <code>-</code> <code>*</code> <code>/</code></p>
			<p>Increment and decrement operators can only be applied to the integer variables outside of the expression context:</p>
			<pre>myInteger++;
myInteger--;</pre>
			<p>There are also a number of operators that compare numeric expressions to give a boolean</p>
			<table>
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td><code>&lt;</code></td>
					<td>Less than</td>
				</tr>
				<tr>
					<td><code>&gt;</code></td>
					<td>Greater than</td>
				</tr>
				<tr>
					<td><code>&lt;=</code></td>
					<td>Less than or equal</td>
				</tr>
				<tr>
					<td><code>&gt;=</code></td>
					<td>Greater than or equal</td>
				</tr>
				<tr>
					<td><code>==</code></td>
					<td>Equal</td>
				</tr>
				<tr>
					<td><code>!=</code></td>
					<td>Not equal</td>
				</tr>
			</table>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="boolean_expressions">Boolean expressions</h3>
			<p>Boolean expressions are made up of bool variables, the boolean constants TRUE and FALSE and game functions that return a boolean value e.g.:</p>
			<pre>not droidSeen and attackDroid</pre>
			<p>The possible operators are:</p>
			<table>
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td><code>bool1 and bool2</code></td>
					<td>True if <code>bool1</code> and <code>bool2</code> are true</td>
				</tr>
				<tr>
					<td><code>bool1 or bool2</code></td>
					<td>True if at least one of <code>bool1</code> and <code>bool2</code> is true</td>
				</tr>
				<tr>
					<td><code>not bool1</code></td>
					<td>True becomes false and false becomes true</td>
				</tr>
				<tr>
					<td><code>==</code></td>
					<td>Can also be used with user defined type variables</td>
				</tr>
				<tr>
					<td><code>!=</code></td>
					<td>Can also be used with user defined type variables</td>
				</tr>
			</table>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="floatingpoint_expressions">Floating point expressions</h3>
			<p>Floating point expressions are very similar to integer expressions. There are some differences though: it is not possible to use increment/decrement operators with floating point variables. The integral and fractional parts of the float constant must be separated by a dot, even if fractional part is 0.</p>
			<p>Examples:</p>
			<pre>myFloat = 1.0 + pi / 2.0 + 3.6;</pre>
			<p>Floating point expressions cannot be mixed with integer or boolean expressions. To use integers or booleans in floating point expressions they must be cast to FLOATs first.</p>
			<p>For more information about casts refer to <a href="#casts" class="locallink">casts</a>.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="assignment">Assignment</h2>
			<p>The value of a variable or an expression can be assigned to another using the = character, e.g.:</p>
			<pre>currentDroid = foundDroid;
index = base + found * 4;
myString = "some text";
myFloat = 2.0 + pi / 2.0;</pre>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="if_statements">If statements</h2>
			<p>If statements are used to control which bits of code are executed. The simplest form is:</p>
			<pre>if (&lt;bool exp&gt;)
{
 &lt;code&gt;
}</pre>
			<p>In this form if <code>&lt;bool exp&gt;</code> evaluates to true then the script code <code>&lt;code&gt;</code> is executed, otherwise the code is ignored.</p>
			<p>Examples:</p>
			<pre>if (&lt;bool exp&gt;)
{
 &lt;code&gt;
}
else
{
 &lt;other code&gt;
}

if (&lt;bool exp&gt;)
{
 &lt;code&gt;
}
else if (&lt;other bool exp&gt;)
{
 &lt;other code&gt;
}
else
{
 &lt;yet another code&gt;
}</pre>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="while_statements">While statements</h2>
			<p>While statements allow <code>&lt;code&gt;</code> to be executed while <code>&lt;bool exp&gt;</code> evaluates to TRUE:</p>
			<pre>while (&lt;bool exp&gt;)
{
 &lt;code&gt;
}</pre>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="casts">Casts</h2>
			<p>Casts convert one data type into a different one. In Warzone 2100 casts are mostly used to convert float to int, int to float and bool to float. To perform a cast write the required data type in pare nothesis.</p>
			<p>Examples:</p>
			<pre>myFloat = (float)myInteger + 2.3 + (float)500 + 500.0;
myInteger = 100 + numPlayers + (int)myFloat;</pre>
			<p>NOTE: Both <code>(float)500</code> and <code>500.0</code> represent the same value. When converting FLOATs to INTs fractional part is discarded.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="custom_functions">Custom functions</h2>
			<p>It is possible to define custom script functions to reuse certain functionality throughout the script.</p>
			<p>Functions have following syntax:</p>
			<pre>function &lt;return type&gt; &lt;function name&gt; ([ &lt;argument type&gt; &lt; argument name&gt;, ... ])
{
 &lt;code&gt;
 return ... ;
}</pre>
			<p>Examples:</p>
			<pre>function void displayVictoryMessage(int winner)
{
 console ("Player " &amp; getPlayerName(winner) &amp; " has won the game");
}

function float calculateMinimum (float f1, float f2)
{
 if (f1 &lt; f2)
 {
  return f1;
 }
 return f2;
}</pre>
			<p>Functions look almost identical to their C counterparts, except that the beginning of a function is marked with <code>function</code> keyword.</p>
			<p>It is possible to declare functions like with events it is done in the event and function declaration section:</p>
			<pre>function void displayVictoryMessage(int winner);
function float calculateMinimum (float f1, float f2);</pre>
			<p>Declared this way it is possible to use a function before it is defined later in the script. To call a function simply provide its name with parameters in pare nothesis:</p>
			<pre>displayVictoryMessage(0);
...
console("Minimum of 2 and 2.1 is " &amp; calculateMinimum(2.0, 2.1));</pre>
			<p>Like in C <code>return &lt;return expression&gt;;</code> or for void functions just <code>return;</code> returns execution to the caller.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="local_variables">Local variables</h2>
			<p>Local variables belong either to a function or event where they were declared and are not accessible outside of it. Local variables must be declared at the beginning of the function or event. Like public/private variables local variables of the same type can be declared on the same line separated by a comma.</p>
			<p>Declaration of a local variable looks as follows:</p>
			<pre>local &lt;variable type&gt; &lt;variable name&gt; [, &lt;variablename&gt;, ...] ;</pre>
			<p>Example:</p>
			<pre>event myEvent(myTrigger)
{
 local int count;
 &lt;code&gt;
}

function void myFunction()
{
 local DROID myDroid1, myDroid2;
 local string myString;
 &lt;code&gt;
}</pre>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="macros">Macros</h2>
			<p>The Warzone 2100 Scripting language supports nested macros (current max. depth is 10). Parametrized macros are not supported. Macros are defined as follows:</p>
			<pre>#define &lt;macro name&gt; &lt;macro body&gt;</pre>
			<p>Example:</p>
			<pre>#define pi 3.14</pre>
			<p>Example of a nested macro:</p>
			<pre>#define CURRENT_PLAYER 0
#define CURRENT_PLAYER_NAMe getPlayerName(CURRENT_PLAYER)</pre>
			<p>During the compilation process macro names are replaced with the actual code.</p>
			<p>If any other text but "define" follows after # character then anything between # and end of the line is ignored by compiler making it possible to use #region and other tags in your favorite IDE.</p>
			<p class="note">NOTE: "#include" is reserved but not fully supported yet.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="data_types">Data types</h2>
			<p>Apart from standard data types like string (string), integer (int), boolean (bool) and floating point (float) there are some Warzone 2100-specific data types available:</p>
			<table>
				<tr>
					<th>Data type</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td><code>INTMESSAGE</code></td>
					<td>Simple. Name of a message as defined in Messages.txt, used mostly for campaign. In most cases it is easier to use a string instead.</td>
				</tr>
				<tr>
					<td><code>BASEOBJ</code></td>
					<td>Complex. Any of a DROID, FEATURE or STRUCTURE. It is a pointer to some droid/feature/structure on the map, can be NULLOBJECT if it was not assigned to a particular droid/feature/structure. You have access to the following variables:
						<ul>
							<li><code>baseobj.x</code></li>
							<li><code>baseobj.y</code></li>
							<li><code>baseobj.z</code></li>
							<li><code>baseobj.id</code> - unique ID number</li>
							<li><code>baseobj.player</code> - player ID</li>
							<li><code>baseobj.type</code> - one of OBJ_DROID, OBJ_STRUCTURE, OBJ_FEATURE</li>
							<li><code>baseobj.health</code> - %age number of body points left</li>
							<li><code>baseobj.clusterID</code> - the cluster the object is a member of</li>
							<li><code>baseobj.target</code> - target of the object (in case of a multi-turret object returns target of the default weapon)</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><code>DROID</code></td>
					<td>Complex. Defined by the ID got from the world editor. It is a pointer to a particular droid on the map, can be NULLOBJECT when no droid is assigned to the DROID variable. You have access to following variables:
						<ul>
							<li><code>droid.x</code></li>
							<li><code>droid.y</code></li>
							<li><code>droid.z</code></li>
							<li><code>droid.id</code> - unique ID number</li>
							<li><code>droid.player</code> - player ID</li>
							<li><code>droid.type</code> - one of OBJ_DROID, OBJ_STRUCTURE, OBJ_FEATURE</li>
							<li><code>droid.health</code> - %age number of body points left</li>
							<li><code>droid.clusterID</code> - the cluster the object is a member of</li>
							<li><code>droid.target</code> - target of the object (in case of a multi-turret object returns target of the default weapon)</li>
							<li><code>droid.order</code> - current order of the droid</li>
							<li><code>droid.orderx</code> - target location of the droid order</li>
							<li><code>droid.ordery</code> - target location of the droid order</li>
							<li><code>droid.action</code> - current action of the droid</li>
							<li><code>droid.body</code> - the BODY of the droid</li>
							<li><code>droid.propulsion</code> - the PROPULSION of the droid</li>
							<li><code>droid.weapon</code> - the WEAPON of the droid DROIDID - (simple) literally just an Id of a droid</li>
							<li><code>droid.selected</code> - holds TRUE if droid is currently selected</li>
							<li><code>droid.group</code> - the GROUP droid belongs to</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><code>FEATURE</code></td>
					<td>Complex. Defined by the ID got from the world editor. It is a pointer to a map decoration, like a tree, wrecked building, oil resource etc, can be NULLOBJECT. You have access to following variables:
						<ul>
							<li><code>feature.x</code></li>
							<li><code>feature.y</code></li>
							<li><code>feature.z</code></li>
							<li><code>feature.id</code> - unique ID number</li>
							<li><code>feature.player</code> - player ID</li>
							<li><code>feature.type</code> - one of OBJ_DROID, OBJ_STRUCTURE, OBJ_FEATURE</li>
							<li><code>feature.health</code> - %age number of body points left</li>
							<li><code>feature.clusterID</code> - the cluster the object is a member of</li>
							<li><code>feature.target</code> - target of the object (in case of a multi-turret object returns target of the default weapon)</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><code>FEATURESTAT</code></td>
					<td>Simple. Type of a feature as defined in features.txt.</td>
				</tr>
				<tr>
					<td><code>TEMPLATE</code></td>
					<td>Simple. Name of a template as defined in templates.txt.</td>
				</tr>
				<tr>
					<td><code>STRUCTURE</code></td>
					<td>Complex. Defined by the ID got from the world editor. It is a pointer to a particular structure on the map, can be NULLOBJECT when no structure is assigned to the STRUCTURE variable. You have access to the foillowing variables:
						<ul>
							<li><code>structure.x</code></li>
							<li><code>structure.y</code></li>
							<li><code>structure.z</code></li>
							<li><code>structure.id</code> - unique ID number</li>
							<li><code>structure.player</code> - player ID</li>
							<li><code>structure.type</code> - one of OBJ_DROID, OBJ_STRUCTURE, OBJ_FEATURE</li>
							<li><code>structure.health</code> - %age number of body points left</li>
							<li><code>structure.clusterID</code> - the cluster the object is a member of</li>
							<li><code>structure.target</code> - target of the object (in case of a multi-turret object returns target of the default weapon)</li>
							<li><code>structure.stat</code> - the STRUCTURESTAT of the structure, defined in structures.txt</li>
							<li><code>structure.stattype</code> - structure type (likeREF_HQ etc.; refers to <a href="#script_function_constants" class="locallink">Script function constants</a>)</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><code>STRUCTUREID</code></td>
					<td>Simple. Literally just an ID of a struct.</td>
				</tr>
				<tr>
					<td><code>STRUCTURESTAT</code></td>
					<td>Simple. Type of a structure as defined in structures.txt.</td>
				</tr>
				<tr>
					<td><code>BODY</code></td>
					<td>Simple. Name of a body as defined in body.txt.</td>
				</tr>
				<tr>
					<td><code>PROPULSION</code></td>
					<td>Simple. Name of a propulsion as defined in propulsion.txt.</td>
				</tr>
				<tr>
					<td><code>ECM</code></td>
					<td>Simple. Name of an ECM as defined in ecm.txt.</td>
				</tr>
				<tr>
					<td><code>SENSOR</code></td>
					<td>Simple. Name of a sensor as defined in sensor.txt.</td>
				</tr>
				<tr>
					<td><code>CONSTRUCT</code></td>
					<td>Simple. Name of a construct as defined in construct.txt.</td>
				</tr>
				<tr>
					<td><code>WEAPON</code></td>
					<td>Simple. Name of a weapon as defined in weapons.txt.</td>
				</tr>
				<tr>
					<td><code>REPAIR</code></td>
					<td>Simple. Name of a repair type as defined in Repair.txt.</td>
				</tr>
				<tr>
					<td><code>BRAIN</code></td>
					<td>Simple. Name of a brain type as defined in Brain.txt.</td>
				</tr>
				<tr>
					<td><code>SOUND</code></td>
					<td>Simple. ID of sound used in playSound().</td>
				</tr>
				<tr>
					<td><code>LEVEL</code></td>
					<td>Simple. ID of a level as defined in GameDesc.lev.</td>
				</tr>
				<tr>
					<td><code>RESEARCHSTAT</code></td>
					<td>Simple. Name of a research topic as defined in research.txt.</td>
				</tr>
				<tr>
					<td><code>GROUP</code></td>
					<td>Complex. A group of droids. Do not confuse GROUP with in-game units' groups that can be accessed with CTRL-&lt;number&gt;, they have nothing in common. GROUP is an internal structure used to simplify unit management. You have access to following variables:
						<ul>
							<li><code>group.x</code> - average x coord</li>
							<li><code>group.y</code> - average y coord</li>
							<li><code>group.members</code> - number of units in the group</li>
							<li><code>group.health</code> - average %age health of the units</li>
							<li><code>group.type</code> - type of the group, one of: <code>GT_NORMAL</code>, <code>GT_COMMAND</code> or <code>GT_TRANSPORTER</code> (refer to <a href="#script_function_constants" class="locallink">Script function constants</a>)</li>
							<li><code>group.commander</code> - commander of the group, if type == <code>GT_COMMAND</code> or <code>NULLOBJECT</code></li>
						</ul>
					</td>
				</tr>
			</table>
			<p class="note">NOTE: The functions objToDroid, objToStructure and objToFeature exist to convert a BASEOBJ to a droid, structure or feature if the base obj is of the right type.</p>
			<p class="note">NOTE: Transporters and commanders cannot be added to a GROUP.</p>
			<p>With a complex object it is possible to access information specific to the instance of this object. Acomplex object is usually a pointer to a C structure in the code. For example a DROID is a complex object - its x, y, z can be queried whereas a DROIDID (a simple object - an integer) is just a placeholder for the numeric value of the ID.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="script_functions">Appendix A: Script functions</h2>
			<h3 id="sf_standard_functions">Standard functions</h3>
			<dl>
				<dt><code>int random(range)</code></dt>
				<dd>Return a random number between 0 and range - 1.</dd>
				<dt><code>randomiseSeed()</code></dt>
				<dd>Generate a new random seed for the random number generator.</dd>
				<dt><code>int distBetweenTwoPoints(int x1, int y1, int x2, int y2)</code></dt>
				<dd>Returns the distance between the two points given.</dd>
				<dt><code>int max(int value1, int value2)</code></dt>
				<dd>Returns maximum of two integer values.</dd>
				<dt><code>int min(int value1, int value2)</code></dt>
				<dd>Returns minimum of two integer values.</dd>
				<dt><code>float fmax(float value1, float value2)</code></dt>
				<dd>Returns maximum of two float values.</dd>
				<dt><code>float fmin(float value1, float value2)</code></dt>
				<dd>Returns minimum of two float values.</dd>
				<dt><code>int modulo(int divident, int divisor)</code></dt>
				<dd>Returns result of calculation (divident modulo divisor).</dd>
				<dt><code>float toPow(float base, float exponent)</code></dt>
				<dd>Returns floating point result of calculation base^exponent.</dd>
				<dt><code>float exp(float exponent)</code></dt>
				<dd>Exponential function. Returns the result of e^exponent.</dd>
				<dt><code>float sqrt(float argument)</code></dt>
				<dd>Square root function. Returns square root of the argument: &radic;argument.</dd>
				<dt><code>bool strcmp(string string1, string string2)</code></dt>
				<dd>Returns TRUE if string1 and string2 are identical. Comparison is case-sensitive.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_type_conversion">Type conversion</h3>
			<dl>
				<dt><code>DROID objToDroid(BASEOBJ)</code></dt>
				<dd>Convert a BASEOBJ to DROID when BASEOBJ.type == OBJ_DROID. Returns NULLOBJECT otherwise.</dd>
				<dt><code>STRUCTURE objToStructure(BASEOBJ)</code></dt>
				<dd>Convert a BASEOBJ to STRUCTURE when BASEOBJ.type == OBJ_STRUCTURE. Returns NULLOBJECT otherwise.</dd>
				<dt><code>FEATURE objToFeature(BASEOBJ)</code></dt>
				<dd>Convert a BASEOBJ to FEATURE when BASEOBJ.type == OBJ_FEATURE. Returns NULLOBJECT otherwise.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_objects">Objects</h3>
			<dl>
				<dt><code>bool objectInRange(PLAYER, X, Y, RANGE)</code></dt>
				<dd>This function checks for when an object belonging to a player is within range of a position. PLAYER is the id of the player whose unit is checked for in range. X, Y is the position to check from in world coords. RANGE is in world coords - 128 units = 1 tile.</dd>
				<dt><code>bool objectInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>This function checks for when an object belonging to a player is in a square area. PLAYER is the id of the player whose droid is checked for in area. X1, Y1, X2, Y2 is the area to check in world coords. X1, Y1 should be smaller than X2, Y2.</dd>
				<dt><code>centreView(OBJECT)</code></dt>
				<dd>This function centres the view on the object supplied. OBJECT is any type of DROID, FEATURE, STRUCTURE.</dd>
				<dt><code>int numObjectsInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>Return the number of player objects in an area.</dd>
				<dt><code>bool losTwoObjects(BASEOBJ source, BASEOBJ target, bool wallsMatter)</code></dt>
				<dd>Decides whether object source can see object target and you can specify whether walls matter or not. Note that whilst target can be anything, source needs to be something that can actually see - i. e. - have a sensor like a unit or structure. Returns TRUE or FALSE.</dd>
				<dt><code>void forceDamageObject(BASEOBJ obj, int damage)</code></dt>
				<dd>Sets <code>obj</code> to be <code>damage</code> percent damaged. <code>obj</code> must be a feature, droid or structure. <code>damage</code> &ge; 0 &and; <code>damage</code> &le; 100.</dd>
				<dt><code>void fireWeaponAtObj(WEAPON weap, BASEOBJ target)</code></dt>
				<dd>Fire a single shot of the weapon weap at the object target.</dd>
				<dt><code>BASEOBJECT skLocateEnemy(int pl)</code></dt>
				<dd>Return a baseobject of interest belonging to player pl.</dd>
				<dt><code>void skFireLassat (int pl, BASEOBJECT obj)</code></dt>
				<dd>Fire lassat of player <code>pl</code>'s at object <code>obj</code>.</dd>
				<dt><code>int numEnemyWeapObjInRange(int lookingPlayer, int x, int y, int range, bool includeVTOLs, bool onlyFinishedStructs)</code></dt>
				<dd>Return total number of enemy military structures and droids at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to <code>lookingPlayer</code> and his allies are ignored. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numFriendlyWeapObjInRange(int lookingPlayer, int x, int y, int range, bool includeVTOLs, bool onlyFinishedStructs)</code></dt>
				<dd>Return total number of friendly military objects structures and droids at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to enemies of <code>lookingPlayer</code> are ignored. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numPlayerWeapObjInRange(int targetPlayer, int lookingPlayer, int x, int y, int range, bool includeVTOLs, bool onlyFinishedStructs)</code></dt>
				<dd>Returns total number of <code>targetPlayer</code>'s military structures and droids at location <code>x</code>, <code>y</code> and within <code>range</code> that are visible visible by <code>lookingPlayer</code>. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numEnemyObjInRange(int lookingPlayer, int, x, int y, int range, bool includeVTOLs, bool onlyFinishedStructs)</code></dt>
				<dd>Returns total number of enemy objects (structures and units) at location <code>x</code>, <code>y</code> within range <code>range</code> that are visible to <code>lookingPlayer</code>. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>bool objHasWeapon(BASEOBJ object)</code></dt>
				<dd>Returns TRUE if <code>object</code> has a weapon.</dd>
				<dt><code>bool objectHasIndirectWeapon(BASEOBj object)</code></dt>
				<dd>Returns TRUE if <code>object</code> has an indirect weapon.</dd>
				<dt><code>int enemyWeapObjCostInRange(int lookingPlayer, int rangeX, int rangeY, int range, bool includeVtols, bool onlyFinishedStructs)</code></dt>
				<dd>Returns total cost (in power) of enemy objects with a weapon in a certain area. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int friendlyWeapObjCostInRange(int lookingPlayer, int rangeX, int rangeY, int range, bool includeVtols, bool onlyFinishedStructs)</code></dt>
				<dd>Returns total cost (in power) of friendly objects with a weapon in a certain area. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_structures">Structures</h3>
			<dl>
				<dt><code>setStructureLimits(STRUCTURESTAT, LIMIT, PLAYER)</code></dt>
				<dd>This sets a limit for a specific structure on how many can be built on a map. STRUCTURESTAT is defined by the name from Access. LIMIT is a number between 0 and 255. PLAYER is the id of the player.</dd>

				<dt><code>setAllStructureLimits(LIMIT, PLAYER)</code></dt>
				<dd>This sets a limit for all structures on how many can be built on a map. LIMIT is a number between 0 and 255. PLAYER is the id of the player.</dd>
				<dt><code>bool buildingDestroyed(STRUCTUREID, PLAYER)</code></dt>
				<dd>This function checks that a structure (given by the id) no longer exists for the player. STRUCTUREID is the id of the structure. Note that this is different to an object of type STRUCTURE. PLAYER is the id of the player whose list is checked for the building.</dd>
				<dt><code>bool structureIdle(STRUCTURE)</code></dt>
				<dd>This function checks whether the structure is doing anything. Returns TRUE if idle. STRUCTURE is a valid structure defined by ID.</dd>
				<dt><code>bool structureBeingBuilt(STRUCTURESTAT, PLAYER)</code></dt>
				<dd>This function checks that a structure of type STRUCTURESTAT is currently being built for the specified PLAYER. STRUCTURESTAT is defined by the name from Access. PLAYER is the id of the player who gets the structure.</dd>
				<dt><code>bool structureBuilt(STRUCTURESTAT, PLAYER)</code></dt>
				<dd>This function checks that a structure of type STRUCTURESTAT is currently built for the specified PLAYER. STRUCTURESTAT is defined by the name from Access. PLAYER is the id of the player who gets the structure.</dd>
				<dt><code>bool structInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>This function checks for when a structure belonging to a player is in a square area. PLAYER is the id of the player whose droid is checked for in area. X1, Y1, X2, Y2 is the area to check in world coords. X1, Y1 should be smaller than X2, Y2.</dd>
				<dt><code>bool structInRange(PLAYER, X, Y, RANGE)</code></dt>
				<dd>This function checks for when a structure belonging to a player is within range of a position. PLAYER is the id of the player whose unit is checked for in range. X, Y is the position to check from in world coords. RANGE is in world coords - 128 units = 1 tile.</dd>
				<dt><code>setAssemblyPoint(X, Y, STRUCTURE)</code></dt>
				<dd>This sets the location of where new units assemble at for a specific factory. X, Y are the x and y in world coordinates. STRUCTURE is a valid structure defined by ID.</dd>
				<dt><code>STRUCTURE addStructure(STRUCTURESTAT, PLAYER, X, Y)</code></dt>
				<dd>Builds a structure belonging to PLAYER centred at (X, Y). The structure must be previously enabled via enableStructure(). The structure identifier is returned - this can be used in e.g. destroyStructure.</dd>
				<dt><code>destroyStructure(STRUCTURE)</code></dt>
				<dd>This removes the structure from the world. STRUCTURE is a structure defined by ID.</dd>
				<dt><code>STRUCTURE getStructure(STRUCTURESTAT, PLAYER)</code></dt>
				<dd>This function returns the first STRUCTURE based on the stat for the player it can find. To use it create a STRUCTURE variable and assign it to the result of the function call. For example:
				<pre>STRUCTURE myNewStructure;
STRUCTURESTAT Factory;
myNewStructure = getStructure(Factory, 0);</pre>
				This will look through the player 0 list of structures to find a Factory and return a variable of type STRUCTURE. You will then be able to access the x, y, and z. If a structure cannot be found than NULL is returned . It will be worth checking that the STRUCTURE does not equal NULL before using it. For example:
				<pre>if (myNewStructure == NULLOBJECT)
{
 do something
}</pre>
				</dd>
				<dt><code>void initEnumStruct(bool any, STRUCTURESTAT type, int targetPlayer, int lookingPlayer)<br />
				STRUCTURE enumStruct()</code></dt>
				<dd>Enumerate through visible structures of given <code>type</code> of player <code>targetPlayer</code> that are visible to <code>lookingPlayer</code>. Returns NULLOBJECT when no more exist. If <code>any</code> is set to TRUE, then <code>type</code> is ignored and all structure types will be iterated.</dd>
				<dt><code>anyStructButWallsLeft(PLAYER)</code></dt>
				<dd>checks the specified player for any structures except walls - returns TRUE if some exist, FALSE if they have all been destroyed.</dd>
				<dt><code>anyFactoriesLeft(PLAYER)</code></dt>
				<dd>Returns true if player has a factory/cyborg factory/ vtol factory.</dd>
				<dt><code>STRUCTURE structureBuiltInRange(STRUCTURESTAT, X, Y, RANGE, PLAYER)</code></dt>
				<dd>Checks to see if a Structure has been built within a specified range of x, y. The first structure. to be found within this range will be returned. Check the result of the function for being NULLOBJECT before using. STRUCTURE is a return value (structure defined by ID). STRUCTURESTAT is defined by the name from Access. X, Y, RANGE are all in world coords. PLAYER is the id of the player whose structure list is searched.</dd>
				<dt><code>bool structButNoWallsInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>See if there are any player structures excluding walls in an area.</dd>
				<dt><code>int numStructsInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>Return the number of player structures in an area.</dd>
				<dt><code>int numStructsButNotWallsInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>Return the number of player structures excluding walls in an area.</dd>
				<dt><code>int numStructsByTypeInArea(PLAYER, TYPE, X1, Y1, X2, Y2)</code></dt>
				<dd>Return the number of structures of a certain type in an area.</dd>
				<dt><code>bool pickStructLocation(STRUCTURESTAT, ref x, ref y, player);</code></dt>
				<dd>Returns true if structure of type structurestat can be built at x, y. If a structure can be built nearby then returns true and modifies x and y to the coords of acceptable location. Player trying to build uses this for the visibility.</dd>
				<dt><code>bool seenStructInArea(int player, int enemy, bool walls, int x1, int y1, int x2, int y2)</code></dt>
				<dd>Returns true if player has seen a structure belonging to enemy in area specified. Call with walls = true/false to include/exclude walls in the search. Similar to StructInArea.</dd>
				<dt><code>void killStructsInArea(int player, int buildingRef (like REF_WALL etc), int x1, int y1, int x2, int y2, bool bSeeEffect, bool bTakeFeatures).</code></dt>
				<dd>Blows up all the buildings of the specified reference within the specified area. If bSeeEffect is set, then you will see it blow up (provided you can see the building in question of course). If bTakeFeatures is set, then it will also kill features of type BUILDING. Returns 'nowt.</dd>
				<dt><code>bool testStructureModule(int playerNumber, ST_STRUCTURE structureToTest, int ref)</code></dt>
				<dd>Returns true if the structure in question has a module attached - presently the <code>ref</code> id is unused but could be later on. At the moment it returns true if the structure has _any_ number of modules attached. If the structure pointer that is sent in is NULL (i. e. - no structure is specified), then it will return TRUE if _any_ of the player's structures possess _any_ module. In all other cases, it will return FALSE.</dd>
				<dt><code>STRUCTURE takeOverSingleStructure(STRUCTURE structToTakeOver, int playerToGain)</code></dt>
				<dd>This replaces the existing structure (structToTakeOver) by a new one for the playerToGain. The new structure is passed back to the script. Test for NULLOBJECT BEFORE calling this function.</dd>
				<dt><code>int takeOverStructsInArea(int fromPlayer, int toPlayer, int x1, int y1, int x2, int y2)</code></dt>
				<dd><code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> are in world units. checks for structures belonging to <code>fromPlayer</code> and if they are in the area they are given to the <code>toPlayer</code>. This will NOT WORK for the <code>selectedPlayer</code> on any Factory. The structure limits will be increased if necessary.</dd>
				<dt><code>void resetStructTargets()</code></dt>
				<dd>Reset the structure preferences.</dd>
				<dt><code>void setStructTarPref(int type)</code></dt>
				<dd>Set a preferred structure target type, repeated calls combine the effect.</dd>
				<dt><code>void setStructTarIgnore(int type)</code></dt>
				<dd>Set structure target ignore types.</dd>
				<dt><code>STRUCTURE structTargetInArea(int targetPlayer, int visibleToPlayer, int x1, int y1, int x2, int y2)</code></dt>
				<dd>Get a structure target in an area using the preferences. targetPlayer is the player to choose targets from, visibleToPlayer specifies the. player that has to be able to see the target or -1 for no visibility check.</dd>
				<dt><code>STRUCTURE structTargetOnMap(int targetPlayer, int visibleToPlayer)</code></dt>
				<dd>Get a structure target on the map using the preferences.</dd>
				<dt><code>bool isStructureAvailable(STRUCTURESTAT stat, int player)</code></dt>
				<dd>Returns true if structure is available to player, false otherwise.</dd>
				<dt><code>bool structureComplete(STRUCTURE struct)</code></dt>
				<dd>Returns true if the structure is completely built.</dd>
				<dt><code>int skGetFactoryCapacity(STRUCTURE str)</code></dt>
				<dd>Return the capacity of factory <code>str</code>.</dd>
				<dt><code>bool skDefenseLocation (ref int x, ref int y, STRUCTURESTAT defenceStat, STRUCTURESTAT wallstat, DROID unit, int player)</code></dt>
				<dd>Given a starting <code>x</code> and <code>y</code>, make unit <code>unit</code> belonging to <code>player</code> build either a <code>defenceStat</code> or a row of <code>wallStat</code>. Returns modified <code>x</code> and <code>y</code>s.</dd>
				<dt><code>int numEnemyWeapStructsInRange(int lookingPlayer, int x, int y, int range, bool onlyFinishedStructs)</code></dt>
				<dd>Return total number of enemy military structures at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to <code>lookingPlayer</code> and his allies are ignored. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numFriendlyWeapStructsInRange(int lookingPlayer, int x, int y, int range, bool onlyFinishedStructs)</code></dt>
				<dd>Return total number of friendly military structures at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to enemies of <code>lookingPlayer</code> are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numPlayerWeapStructsInRange(int targetPlayer, int lookingPlayer, int x, int y, int range, bool onlyFinishedStructs)</code></dt>
				<dd>Returns total number of <code>targetPlayer</code>'s military objects (either structures, droids or both) at location <code>x</code>, <code>y</code> and within <code>range</code> that are visible visible by <code>lookingPlayer</code>. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numAAinRange(int targetPlayer, int lookingPlayer, int x, int y, int range)</code></dt>
				<dd>Returns number of <code>targetPlayer</code>'s AA defences at location <code>x</code>, <code>y</code> within range <code>range</code> that are visible to <code>lookingPlayer</code>.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_features">Features</h3>
			<dl>
				<dt><code>FEATURE addFeature(FEATURESTAT, X, Y)</code></dt>
				<dd>Builds a feature at position (x, y). FEATURESTAT is the name of a feature stat defined in features.txt. The feature identifier is returned - this can be used in e.g. destroyFeature.</dd>
				<dt><code>destroyFeature(FEATURE)</code></dt>
				<dd>This removes the feature from the world. FEATURE is a feature defined by ID.</dd>
				<dt><code>initGetFeature(STRUCTURESTAT, PLAYER, BUCKET)<br />
				getFeature(BUCKET)</code></dt>
				<dd>enumerate features of a single feature type. PLAYER is the player to use, Only features visible to that player are returned. BUCKET is an int of range 0-MAX_PLAYERS(8), so up to 8 feature enumerations can be going on at any time! getFeature returns NULLOBJECT when no more features are visible.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_droids">Droids</h3>
			<dl>
				<dt><code>addDroid(TEMPLATE, X, Y, PLAYER)</code></dt>
				<dd>This function adds a unit for the player based on the template passed in. The unit is placed at x, y. TEMPLATE is a valid template (does not have to belong to the player!). X, Y are in world coords. PLAYER is the id of the player whose the unit belongs to.</dd>
				<dt><code>buildDroid(TEMPLATE, STRUCTURE, PLAYER, QUANTITY)</code></dt>
				<dd>This function sets a factory defined by STRUCTURE to build units based on the TEMPLATE for the PLAYER. TEMPLATE is a valid template (does not have to belong to the player!). STRUCTURE is a structure defined by ID and MUST BE A FACTORY. PLAYER is the id of the player whose the unit belongs to. QUANTITY is the number of units that will be built.</dd>
				<dt><code>bool droidInRange(PLAYER, X, Y, RANGE)</code></dt>
				<dd>This function checks for when a droid belonging to a player is within range of a position. PLAYER is the id of the player whose unit is checked for in range. X, Y is the position to check from in world coords. RANGE is in world coords - 128 units = 1 tile.</dd>
				<dt><code>bool droidInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>This function checks for when a droid belonging to a player is in a square area. PLAYER is the id of the player whose droid is checked for in area. X1, Y1, X2, Y2 is the area to check in world coords. X1, Y1 should be smaller than X2, Y2.</dd>
				<dt><code>bool droidHasSeen(OBJECT, PLAYER)</code></dt>
				<dd>This functions checks for when a player has seen a given object - either by unit or structure. OBJECT is any type of DROID, FEATURE, STRUCTURE. PLAYER is the id of the player to check for having seen.</dd>
				<dt><code>bool selectDroidByID(DROIDID, PLAYER)</code></dt>
				<dd>This selects a unit defined by the ID since we cannot guarantee the name! Only the list of units belonging to PLAYER will be checked. This returns TRUE if the unit could be found - it will be worth checking it exists! DROIDID is a valid unit defined by ID.</dd>
				<dt><code>void InitEnumDroids(int targetPlayer, int lookingPlayer)<br />
				DROID EnumDroid()</code></dt>
				<dd>Enumerate through all <code>targetPlayer</code>'s droids that are visible to <code>lookingPlayer</code>. Returns NULLOBJECT when no more exist.</dd>
				<dt><code>anyDroidsLeft(PLAYER)</code></dt>
				<dd>checks the specified player for any units - returns TRUE if some exist, FALSE if they have all been destroyed.</dd>
				<dt><code>groupAddDroid(GROUP, DROID)</code></dt>
				<dd>Add a unit to a group.</dd>
				<dt><code>groupAddArea(GROUP, PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>Add all the units inside the rectangle X1, Y1, X2, Y2. Only units belonging to player PLAYER are added.</dd>
				<dt><code>groupAddAreaNoGroup(GROUP, PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>as above but does not add units that are already grouped.</dd>
				<dt><code>groupAddGroup(group1, group2)</code></dt>
				<dd>Add all the units in group2 to group1. All the units are removed from group2.</dd>
				<dt><code>bool hasGroup(DROID droid)</code></dt>
				<dd>Returns TRUE if <code>droid</code> belongs to any group, returns FALSE otherwise.</dd>
				<dt><code>orderDroid(DROID, order)</code></dt>
				<dd>Give a unit an order currently one of:
					<ul>
						<li><code>DORDER_STOP</code> - stop current order</li>
						<li><code>DORDER_RETREAT</code> - retreat</li>
						<li><code>DORDER_DESTRUCT</code> - self destruct</li>
						<li><code>DORDER_RTR</code> - return to repair</li>
						<li><code>DORDER_RTB</code> - return to base</li>
						<li><code>DORDER_RUN</code> - run away for a bit (moral failure)</li>
					</ul>
				</dd>
				<dt><code>orderDroidLoc(DROID, order, x, y)</code></dt>
				<dd>Give a unit an order with a location.
					<ul>
						<li><code>DORDER_MOVE</code> - move to location</li>
					</ul>
				</dd>
				<dt><code>orderDroidObj(DROID, order, BASEOBJ)</code></dt>
				<dd>Give a unit an order with an object.
					<ul>
						<li><code>DORDER_ATTACK</code> - attack the object</li>
						<li><code>DORDER_HELPBUILD</code> - help construct the object</li>
						<li><code>DORDER_DEMOLISH</code> - demolish structure</li>
						<li><code>DORDER_REPAIR</code> - repair structure</li>
						<li><code>DORDER_OBSERVE</code> - (sensor units) keep a target in sensor range</li>
						<li><code>DORDER_EMBARK</code> - get onto a transporter</li>
						<li><code>DORDER_FIRESUPPORT</code> - follow this sensor unit and attack anything it <code>DORDER_OBSERVE</code>'s</li>
					</ul>
				</dd>
				<dt><code>orderDroidStatsLoc(DROID, int order, STRUCTURESTAT stats, int x, int y)</code></dt>
				<dd>Give a unit an order with stats and a location.
					<ul>
						<li><code>DORDER_BUILD</code> - build a structure at the location.</li>
					</ul>
				</dd>
				<dt><code>orderGroup(GROUP, order)</code></dt>
				<dd>Give all the units in the group an order.</dd>
				<dt><code>orderGroupLoc(GROUP, order, x, y)</code></dt>
				<dd>Give all the units in the group an order with a location.</dd>
				<dt><code>orderGroupObj(GROUP, order, BASEOBJ)</code></dt>
				<dd>Give all the units in the group an order with an object.</dd>
				<dt><code>setDroidSecondary(DROID droid, int secondaryOrder, int secondaryState)</code></dt>
				<dd>Set the state of a secondary order for a droid (values in <a href="#script_function_constants" class="locallink">Script function constants</a>).</dd>
				<dt><code>setGroupSecondary(GROUP group, int secondaryOrder, int secondaryState)</code></dt>
				<dd>Set the state of a secondary order for a group (values in <a href="#script_function_constants" class="locallink">Script function constants</a>).</dd>
				<dt><code>int idleGroup(GROUP group)</code></dt>
				<dd>Returns number of units in group not doing anything.</dd>
				<dt><code>bool groupMember(GROUP group, DROID droid)</code></dt>
				<dd>Returns whether a unit is a member of a group.</dd>
				<dt><code>initIterateGroup(GROUP group)</code></dt>
				<dd>Prepare a group to iterate through the units in it.</dd>
				<dt><code>DROID iterateGroup(GROUP group)</code></dt>
				<dd>Get the next unit from the group. Must be called after an initial initGroupIterate. To reset a group back to the start call initGroupIterate.</dd>
				<dt><code>droidLeaveGroup(DROID droid)</code></dt>
				<dd>Make a unit leave the group it is a member of (if any).</dd>
				<dt><code>int numDroidsInArea(PLAYER, X1, Y1, X2, Y2)</code></dt>
				<dd>Return the number of player units in an area.</dd>
				<dt><code>cmdDroidAddDroid(DROID commander, DROID droid)</code></dt>
				<dd>adds the unit droid to the command group of the command unit commander.</dd>
				<dt><code>cmdDroidMaxGroup(DROID commander)</code></dt>
				<dd>Returns max number of droids <code>commander</code> can have in his group.</dd>
				<dt><code>void vanishUnit(DROID droid)</code></dt>
				<dd>Will remove <code>droid</code> from the world without any graphical hoo ha.</dd>
				<dt><code>DROID takeOverSingleDroid(DROID droidToTakeOver, int playerToGain)</code></dt>
				<dd>This replaces the existing droid (droidToTakeOver) by a new one for the playerToGain. The new droid is passed back to the script. Test for NULLOBJECT BEFORE calling this function.</dd>
				<dt><code>int takeOverDroidsInArea(int fromPlayer, int toPlayer, int x1, int y1, int x2, int y2)</code></dt>
				<dd><code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> are in world units. Checks for units belonging to <code>fromPlayer</code> and if they are in the area they are given to the <code>toPlayer</code>.</dd>
				<dt><code>int takeOverDroidsInAreaExp(int fromPlayer, int toPlayer, int x1, int y1, int x2, int y2, int level, int max)</code></dt>
				<dd><code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> are in world units. Checks for units belonging to <code>fromPlayer</code> and if they are in the area they are given to the <code>toPlayer</code>. If their experience level is less than or equal to <code>level</code>. <code>max</code> specifies the maximum number of units to take over.</dd>
				<dt><code>void resetDroidTargets()</code></dt>
				<dd>Reset the unit preferences.</dd>
				<dt><code>void setDroidTarPref(int type)</code></dt>
				<dd>Set prefered unit target types.</dd>
				<dt><code>void setDroidTarIgnore(int type)</code></dt>
				<dd>Set unit target ignore types.</dd>
				<dt><code>DROID droidTargetInArea(int targetPlayer, int visibleToPlayer, int x1, int y1, int x2, int y2)</code></dt>
				<dd>Get a unit target in an area using the preferences.</dd>
				<dt><code>DROID droidTargetOnMap(int targetPlayer, int visibleToPlayer)</code></dt>
				<dd>Get a unit target on the map using the preferences.</dd>
				<dt><code>int getDroidCount(int player)</code></dt>
				<dd>Returns the number of units on the current map for the specified player.</dd>
				<dt><code>setDroidKills(DROID droid, int kills)</code></dt>
				<dd>Sets the number of kills for a unit. currently the level boundaries are:. 4, 8, 16, 32, 64, 128, 256, 512.</dd>
				<dt><code>int killDroidsInArea(int x1, int y1, int x2, int y2, int player)</code></dt>
				<dd>Kills all the <code>player</code>'s units within the area defined. Returns how many it wiped out.</dd>
				<dt><code>int numEnemyWeapDroidsInRange(int lookingPlayer, int x, int y, int range, bool includeVTOLs)</code></dt>
				<dd>Return total number of enemy military droids at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to <code>lookingPlayer</code> and his allies are ignored. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored. If <code>onlyFinishedStructs</code> is set to TRUE, then unfinished structures will be ignored.</dd>
				<dt><code>int numFriendlyWeapDroidsInRange(int lookingPlayer, int x, int y, int range, bool includeVTOLs)</code></dt>
				<dd>Return total number of friendly military droids at location <code>x</code>, <code>y</code> and within <code>range</code>. Units belonging to enemies of <code>lookingPlayer</code> are ignored. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored.</dd>
				<dt><code>int numPlayerWeapDroidsInRange(int targetPlayer, int lookingPlayer, int x, int y, int range, bool includeVTOLs)</code></dt>
				<dd>Returns total number of <code>targetPlayer</code>'s military droids at location <code>x</code>, <code>y</code> and within <code>range</code> that are visible visible by <code>lookingPlayer</code>. If <code>includeVTOLs</code> is set to FALSE, then VTOLs are ignored.</dd>
				<dt><code>void selectDroid(DROID droid, bool select)</code></dt>
				<dd>Depending on value of <code>select</code> selects or deselects droid <code>droid</code>.</dd>
				<dt><code>void selectGroup(GROUP group, bool select)</code></dt>
				<dd>Depending on value of <code>select</code> selects or deselects all droids belonging to group <code>group</code>.</dd>
				<dt><code>int calcDroidPower(DROID droid)</code></dt>
				<dd>Returns cost of the <code>droid</code>.</dd>
				<dt><code>boolisVtol(DROID droid)</code></dt>
				<dd>Returns TRUE if <code>droid</code> is a vtol.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_templates">Templates</h3>
			<dl>
				<dt><code>TEMPLATE getTemplate(COMPONENT, PLAYER)</code></dt>
				<dd>This function returns the first TEMPLATE based on the stat for the player it can find. It can be any type of component. To use it create a TEMPLATE variable and assign it to the result of the function call. For example:
				<pre>TEMPLATE myNewTemplate;
WEAPON Rocket;
myNewTemplate = getStructure(Rocket, 0);</pre>
				This will look through the player 0 list of template to find one which contains a rocket and then return a variable of type TEMPLATE. You will then be able to access its attributes. If a template cannot be found than NULL is returned . It will be worth checking that the TEMPLATE does not equal NULL before using it. For example:
				<pre>if (myNewTemplate == NULLTEMPLATE)
{
 do something
}</pre>
				</dd>
				<dt><code>bool addTemplate(TEMPLATE, int player)</code></dt>
				<dd>Given a template, gives the player the template so that build droid can be used. At least one player must have the template.</dd>
				<dt><code>bool skCanBuildTemplate (int pl, STRUCTURE str, TEMPLATE tem)</code></dt>
				<dd>True when player pl can build design <code>tem</code> with structure <code>str</code>.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_research">Research</h3>
			<dl>
				<dt><code>enableResearch(RESEARCHSTAT, PLAYER)</code></dt>
				<dd>This function makes a research topic available to a player regardless of its pre-requisites. RESEARCHSTAT is defined by the name from Access. PLAYER is the id of the player who gets the research.</dd>
				<dt><code>completeResearch(RESEARCHSTAT, PLAYER)</code></dt>
				<dd>This function acts as if the research was performed by the player giving them the results. RESEARCHSTAT is defined by the name from Access. PLAYER is the id of the player who gets the research.</dd>
				<dt><code>void skDoResearch (STRUCTURE str, int pl, int bias)</code></dt>
				<dd>Make player pl do some research with structure <code>str</code>.</dd>
				<dt><code>bool pursueResearch(STRUCTURE resFac, int player, RESEARCH targetResearch)</code></dt>
				<dd>Makes <code>resFac</code> start researching the first prerequisite necessary for <code>targetResearch</code>. If no prerequisites are left, then <code>targetResearch</code> will be researched. Must be called again for the next prerequisite. <code>resFac</code> must be a valid research facility. Returns TRUE if started researching, FALSE otherwise.</dd>
				<dt><code>int numResearchLeft(int player, RESEARCH research)</code></dt>
				<dd>Returns number of research topics that are left for player <code>player</code> to research in order for a certain research <code>research</code> to become available.</dd>
				<dt><code>bool researchFinished(RESEARCh research, int player)</code></dt>
				<dd>Returns TRUE if <code>player</code> has researched <code>research</code>.</dd>
				<dt><code>bool researchStarted(RESEARCH research, int player)</code></dt>
				<dd>Returns TRUE if <code>research</code> is currently being researched by <code>player</code>.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_components">Components</h3>
			<dl>
				<dt><code>enableComponent(COMPONENT, PLAYER)</code></dt>
				<dd>This function makes a component found to a player - so that they can research a topic that requires the component <code>COMPONENT</code> is any type of Body, Propulsion, Weapon, ECM, Sensor, Construct etc. PLAYER is the id of the player who gets the component.</dd>
				<dt><code>makeComponentAvailable(COMPONENT, PLAYER)</code></dt>
				<dd>This function makes a component available to a player - so that they can build Units using this component. <code>COMPONENT</code> is any type of Body, Propulsion, Weapon, ECM, Sensor, Construct etc. PLAYER is the id of the player who gets the component.</dd>
				<dt><code>enableStructure(STRUCTURESTAT, PLAYER)</code></dt>
				<dd>This function makes a structure available to a player - so that they can research a topic that requires the structure or build the structure STRUCTURESTAT is defined by the name from Access. PLAYER is the id of the player who gets the structure.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_power">Power</h3>
			<dl>
				<dt><code>turnPowerOn()</code></dt>
				<dd>Literally makes the power calculations be used.</dd>
				<dt><code>turnPowerOff()</code></dt>
				<dd>Literally stops the power calculations being used.</dd>
				<dt><code>setPowerLevel(POWER, PLAYER)</code></dt>
				<dd>Sets the power level for a player - this overrides any current setting there is. <code>POWER</code> is the value to set the player's power to. <code>PLAYER</code> is the id of the player.</dd>
				<dt><code>addPower(POWER, PLAYER)</code></dt>
				<dd>Adds the <code>POWER</code> amount to the <code>PLAYER</code>'s current level. <code>POWER</code> is the value to add to the player's power. <code>PLAYER</code> is the id of the player.</dd>
				<dt><code>int playerPower(int player)</code></dt>
				<dd>Returns aspower[player].currentPower (players current power)</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_environment_map">Environment/Map</h3>
			<dl>
				<dt><code>setSnow(bool)</code></dt>
				<dd>This function switches snow on or off. TRUE will turn snow on, FALSE will turn snow off. If rain is on when snow is started the rain will be turned off.</dd>
				<dt><code>setRain(bool)</code></dt>
				<dd>This function switchs rain on or off. TRUE will turn rain on, FALSE will turn rain off. If snow is on when rain is started the snow will be turned off.</dd>
				<dt><code>setBackgroundFog(bool)</code></dt>
				<dd>This function switchs background fog on or off. This sets the backdrop to the current fogcolour and fogs the edge of the visible world. TRUE will turn background fog on, FALSE will turn background fog off.</dd>
				<dt><code>setDepthFog(bool)</code></dt>
				<dd>This function switchs depth fog on or off. This sets the sets fog ramping up from zero in the middle of the view to full fog at the edge of the visible world. TRUE will turn depth fog on, FALSE will turn depth fog off.</dd>
				<dt><code>setFogColour(RED, GREEN, BLUE)</code></dt>
				<dd>This function sets the fog colour, to be used when fog is enabled. This colour is also used in the background clear when fog is enabled. The colour is specified as RED, GREEN and BLUE components each in the range 0 to 255. This yields a 24 bit colour value. Colour values outside the range 0 to 255 will have an indeterminate effect.</dd>
				<dd class="warning">Warning: Setting the fog colour to black (0, 0, 0) does not turn fog off and should be avoided.</dd>
				<dd>Standard values:
					<ul>
						<li>Arizona: 204, 149, 70 (CC9546) (old: 176, 143, 95 (B08F5F))</li>
						<li>Urban: 201, 146, 15 (C9920F)</li>
						<li>Rockies: 182, 225, 236 (B6E1EC)</li>
					</ul>
				</dd>
				<dt><code>setScrollParams(minX, minY, maxX, maxY)</code></dt>
				<dd>This literally sets the scroll settings for the current map - be careful not to set the maxX/maxY greater than that possible for the map! minX, minY, maxX, maxY are all numbers. These are in TILE COORDINATES!!!!!!.</dd>
				<dt><code>setScrollMinX(minX)</code></dt>
				<dd>This just sets the one variable. These are in TILE COORDINATES!!!!!! minX is a number.</dd>
				<dt><code>setScrollMinY(minY)</code></dt>
				<dd>This just sets the one variable. These are in TILE COORDINATES!!!!!! minY is a number.</dd>
				<dt><code>setScrollMaxX(maxX)</code></dt>
				<dd>This just sets the one variable. These are in TILE COORDINATES!!!!!! maxX is a number.</dd>
				<dt><code>setScrollMaxY(maxY)</code></dt>
				<dd>This just sets the one variable. These are in TILE COORDINATES!!!!!! maxY is a number.</dd>
				<dt><code>setDefaultSensor(SENSOR, PLAYER)</code></dt>
				<dd>This sets which sensor will be used as the default when designing units in game for the specified player. The SENSOR must be a valid DEFAULT sensor.</dd>
				<dt><code>setDefaultECM(ECM, PLAYER)</code></dt>
				<dd>Like the above functionm, this sets which ECM will be used as the default when designing units. Again the ECM must be a valid DEFAULT ECM.</dd>
				<dt><code>initAllNoGoAreas()</code></dt>
				<dd>Initialises all the no go areas to 0. Should be called when a new map is loaded.</dd>
				<dt><code>setNoGoArea(x1, y1, x2, y2, areaNum)</code></dt>
				<dd>Defines an area that cannot be built on - used for enemy landing zones. areaNum is a number between 0 and 7. If 0, then this function is the same as calling setlandingZone.</dd>
				<dt><code>setTransporterExit(PLAYER, exitTileX, exitTiley)</code></dt>
				<dd>Setup transporter exit point on map for PLAYER.</dd>
				<dt><code>flyTransporterIn(PLAYER, entryTileX, entryTileY, bool bTrackTransporter)</code></dt>
				<dd>flys <code>PLAYER</code>'s transporter in from entry point on map; set <code>bTrackTransporter</code> true to track it onto the map.</dd>
				<dt><code>setLandingZone(x1, y1, x2, y2)</code></dt>
				<dd>Sets the landing zone for the map. The coords are in tile units and must all be less than 255.</dd>
				<dt><code>setLimboLanding(x1, y1, x2, y2)</code></dt>
				<dd>Sets the landing zone for the Limbo Units. The coords are in tile units and must all be less than 255. The units from the Limbo list are then placed at this location - so call in CALL_GAME_INIT of the mission you want them to appear in.</dd>
				<dt><code>void setWaterTile(int tileNum)</code></dt>
				<dd>Sets the tile to use for underwater. Count from the top of the tileset pcx - presently 17 for arizona.</dd>
				<dt><code>int getPlayerColour(int player)</code></dt>
				<dd>Returns the colour of the player.</dd>
				<dt><code>void setPlayerColour(int colour, int player)</code></dt>
				<dd>Sets the colour to use for the <code>player</code> specified - <code>colour</code> must be 0 to (MAX_PLAYERS-1).</dd>
				<dt><code>void fireWeaponAtLoc(WEAPON weap, int x, int y)</code></dt>
				<dd>Fire a single shot of the weapon weap at the location x, y.</dd>
				<dt><code>bool applyLimitSet (void)</code></dt>
				<dd>Apply the limits set in the structure limits screen.</dd>
				<dt><code>bool fogTileInRange(ref int tileX, ref int tileY, int x, int y, int rangeX, int rangeY, int searchRange, int player, int threatRange)</code></dt>
				<dd>Fills <code>tileX</code>, <code>tileY</code> with coordinates of the unrevealed location in range with starting location <code>x</code>, <code>y</code>, range <code>searchRange</code> and closest to location <code>x</code>, <code>y</code>. If <code>searchRange</code> is -1, then entire map is being searched. <code>player</code> is the player who is looking for an unrevealed map location. If <code>threatRange</code> != -1 then also checks for enemy presence. Locations with enemy presence are ignored then. Returns TRUE if any locations satisfying the search conditions were found, returns FALSE otherwise.</dd>
				<dt><code>bool mapRevealedInRange(int x, int y, int range, int player)</code></dt>
				<dd>Returns TRUE if there are no unrevealed tiles left in locations for player <code>player</code> with center <code>x</code>, <code>y</code> and radius <code>range</code>. All coordinates are in world units.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_game_states">Game states</h3>
			<dl>
				<dt><code>tutorialEnd()</code></dt>
				<dd>A bit of a hack to notify the game when the last of the tutorial events has been run so that the console messages can be turned back on to how they will appear for the rest of the game.</dd>
				<dt><code>gameOver(bool)</code></dt>
				<dd>function to call for ending the game. bool - true or false depending on whether the player has won or not.</dd>
				<dt><code>startMission(MISSION_TYPE, LEVEL)</code></dt>
				<dd>Starts a mission for the currently selected player - NB Transporters must be filled if you want units to appear on the Mission map. MISSION_TYPE is a predefined type - see <a href="#script_function_constants" class="locallink">Script function constants</a>. LEVEL is the name of the level to load as defined in GameDesc.lev.</dd>
				<dt><code>endMission(bool)</code></dt>
				<dd>Ends the current mission the selected player is on - returns all Units that have been loaded onto the Transporter. False if player lost, true if player won????.</dd>
				<dt><code>bool myResponsibility(PLAYER)</code></dt>
				<dd>Returns true if this machine is responsible for <code>PLAYER</code> in multiplayer games.</dd>
				<dt><code>setMissionTime(int time)</code></dt>
				<dd>Used to specify how long an OffWorld mission will last for - used in conjunction with the callback CALL_MISSION_TIME so that end conditions can be displayed if the player has not managed to finish the mission. If time &lt; 0, there is no limit. Time is in 10th of a second.</dd>
				<dt><code>int missionTimeRemaining()</code></dt>
				<dd>Returns how long left for the current mission. If the mission time has not been set it will return 0. The value returned is in 10ths of a second.</dd>
				<dt><code>setReinforcementTime(int time)</code></dt>
				<dd>this defines how long it will take for reinforcements to arrive for an OffWorld mission. If time &lt; 0, there can be no reinforcements. Time is in 10th of a second. Set time to LZ_COMPROMISED_TIME to display '--:--' to indicate the Transporter is unable to land.</dd>
				<dt><code>bool getGameStatus(int StatusRequired)</code></dt>
				<dd>Gets the status of some of the game TRUE/FALSE variables. Can be used to find if the reticule is up or the battle map is open, that sort of thing. Examples:
					<ul>
						<li><code>getGameStatus(STATUS_ReticuleIsOpen);</code> will return TRUE if the reticule is open (on screen) or FALSE if the reticule is not (disabled)</li>
						<li><code>getGameStatus(STATUS_BattleMapViewEnabled);</code> will return TRUE if we are in the battle map mode</li>
						<li><code>getGameStatus(STATUS_DeliveryResposInProgress);</code> will return TRUE if we are repositioning the delivery point</li>
					</ul>
				These are currently the only two options implemented ... for other game modes (like design screen or intelligence map modes) use the externed variable intMode.</dd>
				<dt><code>resetPlayerVisibility(int player)</code></dt>
				<dd>Reset the visibility for a player.</dd>
				<dt><code>void resetLimboMission(void)</code></dt>
				<dd>This can only be called mid Limbo Expand mission - the units that were stored in the mission list at the start of the mission are added back into the map, and the mission type is changed to an Expand Mission.</dd>
				<dt><code>void skDifficultyModifier(int pl)</code></dt>
				<dd>Apply the frontend slider settings to player pl.</dd>
				<dt><code>string getPlayerName(int player)</code></dt>
				<dd>Returns in-game name of <code>player</code>.</dd>
				<dt><code>bool setPlayerName(int player, string newName)</code></dt>
				<dd>Set player's name to <code>newName</code>. Returns TRUE on success.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_diplomacy">Diplomacy</h3>
			<dl>
				<dt><code>bool allianceExists()</code></dt>
				<dd>Returns true if two or more players are in alliance. returns false otherwise.</dd>
				<dt><code>bool dominatingAlliance()</code></dt>
				<dd>Returns true if there is a single dominating alliance, using all multi-players.</dd>
				<dt><code>bool playerInAlliance()</code></dt>
				<dd>Returns true if player is in an alliance.</dd>
				<dt><code>createAlliance(int player1, int player2)</code></dt>
				<dd>Create an alliance between two players.</dd>
				<dt><code>breakAlliance(int player1, int player2)</code></dt>
				<dd>Breake an alliance between two players.</dd>
				<dt><code>void offerAlliance (int p1, int p2)</code></dt>
				<dd>Make p1 offer p2 an alliance.</dd>
				<dt><code>bool allianceExistsBetween (int p1, int p2)</code></dt>
				<dd>True if alliance exists between p1 and p2.</dd>
				<dt><code>bool alliancesLocked()</code></dt>
				<dd>Returns TRUE if the game does not allow to break alliances (i. e. when team mode is on).</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_strategy">Strategy</h3>
			<dl>
				<dt><code>int getThreatInArea(int playerLooking, int playerTarget, int x1, int y1, int x2, int y2, int ldThreat, int mdThreat, int hdThreat)</code></dt>
				<dd>Returns the threat value of all units of a specified player within a certain area for a specified player. The user can 'calibrate' this threat value by specifying the relative weights attached to the threats of small, medium and heavy units respectively as the last three parameters to this function. The final boolean parameter allows the user to say whether they care about whether or not the units in question are presently visible. TRUE means they only add to the threat if <code>PlayerLooking</code> can see this unit (owned by <code>playerTarget</code>), FALSE means they add to the threat if even they cannot see that unit.</dd>
				<dt><code>bool isHumanPlayer (int pl)</code></dt>
				<dd>Returns true is pl is human.</dd>
				<dt><code>bool skVtolEnableCheck(int pl)</code></dt>
				<dd>True when player <code>pl</code> is actively using vtols.</dd>
				<dt><code>bool threatInRange(int player, int rangeX, int rangeY, int range, bool includeVTOLs)</code></dt>
				<dd>Returns TRUE if there is a danger for <code>player</code> at location x/y within radius <code>range</code>. If <code>includeVTOLs</code> is set to FALSE then VTOLs are ignored. All coordinates are in world units. If <code>range</code> == -1 then entire map will be searched.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_gui"><acronym title="Graphical User Interface">GUI</acronym></h3>
			<dl>
				<dt><code>addReticuleButton(BUTTONID)</code></dt>
				<dd>This function adds a reticule button to the interface. BUTTONID is the id of a button - see <a href="#script_function_constants" class="locallink">Script function constants</a>.</dd>
				<dt><code>removeReticuleButton(BUTTONID)</code></dt>
				<dd>This function removes a reticule button from the interface. BUTTONID is the id of a button - see <a href="#script_function_constants" class="locallink">Script function constants</a>.</dd>
				<dt><code>addMessage(INTMESSAGE, MESSAGETYPE, PLAYER, PLAY_IMMEDIATE)</code></dt>
				<dd>This adds a message to the interface for the PLAYER. INTMESSAGE is a variable defined in the values file. MESSAGETYPE is a predefined type - see <a href="#script_function_constants" class="locallink">Script function constants</a>. PLAYER is the player who gets the message. PLAY_IMMEDIATE is a bool for whether to bring the Intelligence Screen up with the message immediately or just store it.</dd>
				<dt><code>removeMessage(INTMESSAGE, MESSAGETYPE, PLAYER)</code></dt>
				<dd>This removes a message from the interface for the PLAYER. INTMESSAGE is a variable defined in the values file. MESSAGETYPE is a predefined type - see <a href="#script_function_constants" class="locallink">Script function constants</a>. PLAYER is the player who loses the message.</dd>
				<dt><code>flashOn(int buttonID)</code></dt>
				<dd>turn on flashing for a button (ids in <a href="#script_function_constants" class="locallink">Script function constants</a>). Works for all buttons not just reticule buttons.</dd>
				<dt><code>flashOff(int buttonID)</code></dt>
				<dd>turn off flashing for a button.</dd>
				<dt><code>setRadarZoom(int level)</code></dt>
				<dd>level is the zoom level between 0 .. 2 on the PC and 0 .. 1 on PSX. 0 is the most zoomed out, 2 the most zoomed in. 2 is mapped to 1 if the script is run on the PSX.</dd>
				<dt><code>void dropBeacon (string msg, int forPlayer, int, fromPlayer, int x, int y, int z)</code></dt>
				<dd>Put a flashing beacon on the map for player <code>forPlayer</code> on position <code>x</code>, <code>y</code>, <code>z</code>. Unless removed manually the beacon is removed automatically from the map after a timeout.</dd>
				<dt><code>void removeBeacon (int forPlayer, int fromPlayer)</code></dt>
				<dd>Remove a previously placed beacon from the map.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_multimedia">Multimedia</h3>
			<dl>
				<dt><code>playSound(SOUND, PLAYER)</code></dt>
				<dd>Plays a '2D' sound i. e. speech and is audible for the player identified. SOUND is a defined type. PLAYER is the id of the player.</dd>
				<dt><code>playSoundPos(SOUND, PLAYER, x, y, z)</code></dt>
				<dd>Plays a '2D' sound i. e. speech and is audible for the player identified. Position of sound is saved so camera can move to object playing sound if required. SOUND is a defined type. PLAYER is the id of the player. x, y, z is the position of the object in game units.</dd>
				<dt><code>addConsoleText(TEXTSTRING, PLAYER)</code></dt>
				<dd>Adds console text to the top of the screen (centre justified) for the player concerned. <code>TEXTSTRING</code> is a string ID obtained from strings.txt. <code>PLAYER</code> is the id of the player.</dd>
				<dt><code>flushConsoleMessages()</code></dt>
				<dd>Clear all the console messages.</dd>
				<dt><code>void console(string message)</code></dt>
				<dd>Outputs <code>message</code> to game console.</dd>
				<dt><code>void msg(string message, int playerFrom, int playerTo)</code></dt>
				<dd>Sends a chat message from <code>playerFrom</code> to <code>playerTo</code>.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="sf_unsorted">Unsorted</h3>
			<dl>
				<dt><code>setRetreatPoint(PLAYER, x, y)</code></dt>
				<dd>Sets the position for a players units to retreat to.</dd>
				<dt><code>setGroupRetreatPoint(GROUP group, int x, int y)</code></dt>
				<dd>Set the retreat position for a group.</dd>
				<dt><code>setRetreatForce(int player, int level)</code></dt>
				<dd>Sets the percentage of the current force below which units for a side will retreat.</dd>
				<dt><code>setGroupRetreatForce(GROUP group, int level)</code></dt>
				<dd>Sets the percentage of the current force below which units for a side will retreat.</dd>
				<dt><code>setRetreatLeadership(int player, int level)</code></dt>
				<dd>Sets the leadership level (chance to run away) for a player (1-100).</dd>
				<dt><code>setGroupRetreatLeadership(GROUP group, int level)</code></dt>
				<dd>Sets the leadership level (chance to run away) for a player (1-100).</dd>
				<dt><code>bool getNearestGateway(int x, int y, ref rX, ref rY)</code></dt>
				<dd>Puts the coordinates of the nearest gateway into reference variables rX and rY. It might not though if there are no gateways on the present map. So make sure you look at the return value. If it is FALSE, then the values in rX and rY will be meaningless - unchanged actually, assuming the scripting works this way. Otherwise, they will be the coordinates of the midpoint of the nearest gateway.</dd>
				<dt><code>initIterateCluster(int clusterID)</code></dt>
				<dd>Get ready to iterate a cluster.</dd>
				<dt><code>BASEOBJ iterateCluster()</code></dt>
				<dd>Return the next object in the cluster or NULLOBJ if none left.</dd>
				<dt><code>BASEOBJ targetInCluster(int clusterID, int visibleToPlayer)</code></dt>
				<dd>Get a target from a cluster using the preferences.</dd>
				<dt><code>traceOn()</code></dt>
				<dd>View the script debug info to stdout.</dd>
				<dt><code>traceOff()</code></dt>
				<dd>Stop viewing the script debug info to stdout.</dd>
				<dt><code>centreViewPos(int x, int y)</code></dt>
				<dd>Center the view on the world coordinates x, y.</dd>
				<dt><code>void setEventTrigger(EVENT event, TRIGGER newTrigger)</code></dt>
				<dd>Assigns <code>newTrigger</code> as new trigger for event <code>event</code>.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="debugging_script_functions">Appendix B: Debugging script functions</h2>
			<p>The following functions can be used to debug Warzone 2100 AI scripts.</p>
			<dl>
				<dt><code>void dbgMsgOn(int player, bool on)</code></dt>
				<dd>Depending on the value of <code>on</code> turns on/off debug output of dbg() and ASSERT() function which are listed below.</dd>
				<dt><code>void dbg(string debugMessage, int player)</code></dt>
				<dd>Outputs <code>debugMessage</code> to the game console if debug output for player <code>player</code> was previously turned on with dbgMsgOn().</dd>
				<dt><code>void ASSERT(bool assertExpression, string assertMessage, int player)</code></dt>
				<dd>If <code>assertExpression</code> evaluates to FALSE, then <code>assertMessage</code> is output to the game console. Must turn on debug output for <code>player</code> with <code>dbgMsgOn()</code> first. <span class="note">NOTE: In debug game builds failed assertion will cause game assertion.</span>.</dd>
				<dt><code>void debug(string debugText)</code></dt>
				<dd>Writes <code>debugText</code> to the standart output (usually a log file).</dd>
				<dt><code>void printCallStack()</code></dt>
				<dd>Outputs script call stack to the standard log file.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="script_function_constants">Appendix C: Script function constants</h2>
			<p>These values are used to represent numbers that are constant throughout the game.</p>
			<p>NULLOBJECT- used to check that a BASEOBJECT/FEATURE/STRUCTURE has been assigned by a function</p>
			<p>NULLTEMPLATE- used to check that a TEMPLATE has been assigned by a function</p>
			<p>NULLSTAT- used to check that a BASESTAT has been assigned by a function</p>
			<p>BARBARIAN1- this can used to represent enemy1 (PC:player 6, PSX:player2)</p>
			<p>BARBARIAN2- this can used to represent enemy2 (PC:player 7, PSX:player3)</p>
			<p>BUTTONID - these values are used when a particular reticule button needs to be identified</p>
			<p>OPTIONs	- NOTE - this currently references the command button</p>
			<p>CANCEL</p>
			<p>BUILD</p>
			<p>MANUFACTURE</p>
			<p>RESEARCH</p>
			<p>INTELMAP</p>
			<p>DESIGN</p>
			<p>COMMAND</p>
			<p>- When flashing an icon - with scrFlashOn() scrFlashOff()</p>
			<p>you can additional use</p>
			<p>IDRET_OPTIONS</p>
			<p>IDRET_CANCEl</p>
			<p>IDRET_BUILD</p>
			<p>IDRET_MANUFACTURE</p>
			<p>IDRET_RESEARCH</p>
			<p>IDRET_INTEL_MAP</p>
			<p>IDRET_DESIGN</p>
			<p>IDRET_COMMAND</p>
			<p>IDDES_TEMPLSTART</p>
			<p>IDDES_SYSTEMBUTTON</p>
			<p>IDDES_BODYBUTTON</p>
			<p>IDDES_PROPBUTTON</p>
			<p>MESSAGETYPE - these values are used when a type of message needs to be identified</p>
			<p>RES_MSG</p>
			<p>CAMP_MSG</p>
			<p>MISS_MSG</p>
			<p>PROX_MSG</p>
			<p>Multiplayer alliance types:</p>
			<p>NO_ALLIANCES- alliances are disallowed</p>
			<p>ALLIANCES- alliances are allowed</p>
			<p>ALLIANCES_TEAMS- team mode, locked alliances</p>
			<p>MISSIONTYPE - these values are used when a type of mission needs to be identified</p>
			<p>CAMP_START	- used for the starting point of a campaign</p>
			<p>CAMP_EXPAND	- used to expand a current campaign map</p>
			<p>OFF_KEEP	- used to load up an off world map, but keeping access</p>
			<p>to factories and research facilities back at home base</p>
			<p>OFF_CLEAR	- used to load up an off world map, but having no access to home base</p>
			<p>LZ_COMPROMISED_TIME- value to set the reinforcement time with to display '--:--'</p>
			<p>when the Transporter is unable to land</p>
			<p>Droid Orders:</p>
			<p>DORDER_NONE- no order assigned</p>
			<p>DORDER_STOP- stop current order</p>
			<p>DORDER_RETREAT- retreat</p>
			<p>DORDER_DESTRUCT- self destruct</p>
			<p>DORDER_RTR- return to repair</p>
			<p>DORDER_RTB- return to base</p>
			<p>DORDER_RUN- run away for a bit (moral failure)</p>
			<p>DORDER_MOVE- move to location</p>
			<p>DORDER_ATTACK- attack the object</p>
			<p>DORDER_HELPBUILD- help construct the object</p>
			<p>DORDER_DEMOLISH- demolish structure</p>
			<p>DORDER_REPAIR- repair structure</p>
			<p>DORDER_OBSERVE- (sensor units) keep a target in sensor range</p>
			<p>DORDER_EMBARK- get onto a transporter</p>
			<p>DORDER_FIRESUPPORT- follow this sensor unit and attack anything it DORDER_OBSERVE's</p>
			<p>DORDER_SCOUT- same as move, but stop if enemy units are encountered.</p>
			<p>Unit secondary orders:</p>
			<p>DSO_ATTACK_RANGE</p>
			<p>DSO_REPAIR_LEVEL</p>
			<p>DSO_ATTACK_LEVEL</p>
			<p>DSO_RECYCLE</p>
			<p>DSO_PATROL- patrol between current pos and next move target</p>
			<p>DSO_HALTTYPE- what to do when stopped</p>
			<p>DSO_RETURN_TO_LOC- return to various locations</p>
			<p>Unit secondary states:</p>
			<p>DSS_ARANGE_SHORT</p>
			<p>DSS_ARANGE_LONG</p>
			<p>DSS_ARANGE_DEFAULT</p>
			<p>DSS_REPLEV_LOW- Medium Damage Taken</p>
			<p>DSS_REPLEV_HIGH- Heavy Damage Taken</p>
			<p>DSS_REPLEV_NEVER- Never Repair</p>
			<p>DSS_ALEV_ALWAYS</p>
			<p>DSS_ALEV_ATTACKED</p>
			<p>DSS_ALEV_NEVER</p>
			<p>DSS_PATROL_SET(0 to clear)</p>
			<p>DSS_HALT_HOLD</p>
			<p>DSS_HALT_GUARD</p>
			<p>DSS_HALT_PERSUE</p>
			<p>DSS_RECYCLE_SET(0 to clear)</p>
			<p>DSS_RTL_REPAIR(0 to clear)</p>
			<p>DSS_RTL_BASE(0 to clear)</p>
			<p>DSS_RTL_TRANSPORT(0 to clear)</p>
			<p>Button ID's:</p>
			<p>IDRET_OPTIONS- option button</p>
			<p>IDRET_BUILD- build button</p>
			<p>IDRET_MANUFACTURE- manufacture button</p>
			<p>IDRET_RESEARCH- research button</p>
			<p>IDRET_INTEL_MAP- intelligence map button</p>
			<p>IDRET_DESIGN- design units button</p>
			<p>IDRET_CANCEL- central cancel button</p>
			<p>Unit types:</p>
			<p>DROID_WEAPON- Weapon unit</p>
			<p>DROID_SENSOR- Sensor unit</p>
			<p>DROID_ECM- ECM unit</p>
			<p>DROID_CONSTRUCt	- Constructor unit</p>
			<p>DROID_PERSON- person</p>
			<p>DROID_CYBORG- cyborg/super cyborg</p>
			<p>DROID_TRANSPORTER- guess what this is!</p>
			<p>DROID_COMMAND- Command unit</p>
			<p>DROID_REPAIR- Repair Unit</p>
			<p>DROID_CYBORG_CONSTRUCT- Cyborg engineer</p>
			<p>DROID_CYBORG_REPAIR- Cyborg mechanic</p>
			<p>Structure types:</p>
			<p>REF_HQ</p>
			<p>REF_FACTORY</p>
			<p>REF_FACTORY_MODULe</p>
			<p>REF_POWER_GEN</p>
			<p>REF_POWER_MODULE</p>
			<p>REF_RESOURCE_EXTRACTOR</p>
			<p>REF_DEFENSE</p>
			<p>REF_WALL</p>
			<p>REF_WALLCORNER- corner wall - no gun</p>
			<p>REF_RESEARCh</p>
			<p>REF_RESEARCH_MODULe</p>
			<p>REF_REPAIR_FACILITY</p>
			<p>REF_COMMAND_CONTROL- control centre for command units</p>
			<p>REF_CYBORG_FACTORY</p>
			<p>REF_VTOL_FACTORY</p>
			<p>REF_REARM_PAD</p>
			<p>REF_MISSILE_SILO</p>
			<p>Multiplayer Game Types:</p>
			<p>SKIRMISH</p>
			<p>DMATCH</p>
			<p>CAMPAIGN</p>
			<p>TEAMPLAY</p>
			<p>MultiPlayer Base Configurtations:</p>
			<p>CAMP_CLEAN- build units only</p>
			<p>CAMP_BASE- small base</p>
			<p>CAMP_WALLS- defensive base</p>
			<p>Cursor Mode (possible values of cursorType):</p>
			<p>IMAGE_CURSOR_SELECT</p>
			<p>IMAGE_CURSOR_ATTACK</p>
			<p>IMAGE_CURSOR_MOVE</p>
			<p>IMAGE_CURSOR_JAM</p>
			<p>IMAGE_CURSOR_PICKUP</p>
			<p>IMAGE_CURSOR_DEFAULT</p>
			<p>IMAGE_CURSOR_SEEKREPAIR</p>
			<p>IMAGE_CURSOR_BUILD</p>
			<p>IMAGE_CURSOR_GUARD</p>
			<p>IMAGE_CURSOR_BRIDGE</p>
			<p>IMAGE_CURSOR_ATTACH</p>
			<p>IMAGE_CURSOR_LOCKON</p>
			<p>IMAGE_CURSOR_FIX</p>
			<p>IMAGE_CURSOR_EMBARK</p>
			<p>Game mode - possible values for intMode external variable</p>
			<p>int_NORMAL- Standard mode (just the reticule)</p>
			<p>int_OPTION- Option screen</p>
			<p>int_EDITSTAT- Stat screen up for placing objects</p>
			<p>int_EDIT- Edit mode</p>
			<p>int_OBJECT- Object screen</p>
			<p>int_STAT- Object screen with stat screen</p>
			<p>int_CMDORDER- Object screen with command units and orders screen</p>
			<p>int_DESIGN- Design screen</p>
			<p>int_INTELMAP- Intelligence Map</p>
			<p>int_ORDER</p>
			<p>int_INGAMEOP- in game options.</p>
			<p>int_TRANSPORTER- Loading/unloading a Transporter</p>
			<p>int_MISSIONRES- Results of a mission display.</p>
			<p>int_MULTIMENU- multiplayer only, player stats etc...</p>
			<p>Possible options for getGameStatus():</p>
			<p>STATUS_ReticuleIsOpen- returns true is the reticule is open</p>
			<p>STATUS_BattleMapViewEnabled- returns true if we are in battlemap mode</p>
			<p>Possible values for targetedObjectType:</p>
			<p>MT_TERRAIN</p>
			<p>MT_RESOURCE</p>
			<p>MT_BLOCKING</p>
			<p>MT_RIVER</p>
			<p>MT_TRENCH</p>
			<p>MT_OWNSTRDAM</p>
			<p>MT_OWNSTROK</p>
			<p>MT_OWNSTRINCOMP</p>
			<p>MT_REPAIR</p>
			<p>MT_REPAIRDAM</p>
			<p>MT_ENEMYSTR</p>
			<p>MT_TRANDROID</p>
			<p>MT_OWNDROID</p>
			<p>MT_OWNDROIDDAM</p>
			<p>MT_ENEMYDROID</p>
			<p>MT_COMMAND</p>
			<p>MT_ARTIFACT</p>
			<p>MT_DAMFEATURE</p>
			<p>MT_SENSOR</p>
			<p>MT_WRECKFEATURE</p>
			<p>Structure Target preference types:</p>
			<p>ST_HQ</p>
			<p>ST_FACTORY</p>
			<p>ST_POWER_GEN</p>
			<p>ST_RESOURCE_EXTRACTOR</p>
			<p>ST_WALL</p>
			<p>ST_RESEARCH</p>
			<p>ST_REPAIR_FACILITY</p>
			<p>ST_COMMAND_CONTROL</p>
			<p>ST_CYBORG_FACTORY</p>
			<p>ST_VTOL_FACTORY</p>
			<p>ST_REARM_PAD</p>
			<p>ST_SENSOR</p>
			<p>ST_DEF_GROUND</p>
			<p>ST_DEF_AIR</p>
			<p>ST_DEF_IDF</p>
			<p>ST_DEF_ALL- ground/air/idf structures</p>
			<p>Unit target preference types:</p>
			<p>turret types:</p>
			<p>DT_COMMAND</p>
			<p>DT_SENSOR</p>
			<p>DT_CONSTRUCT</p>
			<p>DT_REPAIR</p>
			<p>DT_WEAP_GROUND</p>
			<p>DT_WEAP_AIR</p>
			<p>DT_WEAP_IDF</p>
			<p>DT_WEAP_ALL- ground/air/idf units</p>
			<p>Body types:</p>
			<p>DT_LIGHT</p>
			<p>DT_MEDIUM</p>
			<p>DT_HEAVY</p>
			<p>DT_SUPER_HEAVy	- transporter only</p>
			<p>Propulsion:</p>
			<p>DT_TRACK</p>
			<p>DT_HTRACK</p>
			<p>DT_WHEEL</p>
			<p>DT_LEGS</p>
			<p>DT_GROUND</p>
			<p>DT_VTOL</p>
			<p>DT_HOVER</p>
			<p>Group types:</p>
			<p>GT_NORMAL</p>
			<p>GT_COMMAND</p>
			<p>GT_TRANSPORTER</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="script_function_externals">Appendix D: Script function externals</h2>
			<p>These represent variables that are defined in the game which can be accessed in the scripts. It will only be possible to set the value that is held for some of the variables.</p>
			<p>mapWidth- (get) - field to hold the width of the map</p>
			<p>mapHeight- (get) - field to hold the height of the map</p>
			<p>gameInitialised- (get) flag to specify when all initialisation has been performed for the game - use it in place of a bool i. e. can be considered to equal true or false</p>
			<p>selectedPlayer- (get) field to hold the currently selected player</p>
			<p>gameTime- (get) the current time in the game (in 1/10 sec)</p>
			<p>multiPlayerGameType	- (get) the type of multiplayer game underway.</p>
			<p>multiPlayerMaxPlayers	- max number of human players in this game.(see constants for return values)</p>
			<p>multiPlayerBaseType	- campaign game base type. (see constants for return values)</p>
			<p>multiPlayerAlliancesType- (get) alliance type (eg NO_ALLIANCES etc, see	<a href="#script_function_constants" class="locallink">Script function constants</a>)</p>
			<p>scrollX- (get/set) field to hold the starting x coordinate where the player can scroll</p>
			<p>scrollY- (get/set) field to hold the starting y coordinate where the player can scroll</p>
			<p>scrollWidth- (get/set) field to hold the width the player can scroll</p>
			<p>scrollHeight- (get/set) field to hold the height the player can scroll</p>
			<p>cursorType- (get) - Gets the current mode that the cursor is in (e.g. IMAGE_CURSOR_BUILD ... see	<a href="#script_function_constants" class="locallink">Script function constants</a>)</p>
			<p>intMode- (get) - Get the current game mode (e.g. int_DESIGN when the design screen is active) ... see	<a href="#script_function_constants" class="locallink">Script function constants</a>)</p>
			<p>targetedObjectType- (get) - The type of the object currently under the cursor (one of MT_... see	<a href="#script_function_constants" class="locallink">Script function constants</a>)</p>
			<p>boolextraVictoryFlag- use to mark additional victory conditions have been met - reset to FALSE at start of each level</p>
			<p>boolextraFailFlag- use to mark additional failure conditions have been met - reset to FALSE at start of each level</p>
			<p>GameLevel(get/set) - set single player difficulty.</p>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<h2 id="script_function_callbacks">Appendix E: Script function callbacks</h2>
			<p>These are used in the place of a trigger and are for events that are to be called at specific times in the game. They will cause the event they are associated with to be called every time unless the trigger for the event is set to inactive.</p>
			<dl>
				<dt><code>CALL_GAMEINIT</code></dt>
				<dd>this is triggered when the game has initialised.</dd>
				<dt><code>CALL_DROIDDESIGNED</code></dt>
				<dd>this is triggered when the player saves a template design.</dd>
				<dt><code>CALL_DROIDBUILT</code></dt>
				<dd>this is triggered when a unit has been built via a factory.</dd>
				<dt><code>CALL_POWERGEN_BUILT</code></dt>
				<dd>this is triggered when a Power generatot has been built.</dd>
				<dt><code>CALL_RESEX_BUILT</code></dt>
				<dd>this is triggered when a Resource Extractor has been built.</dd>
				<dt><code>CALL_RESEARCH_BUILT</code></dt>
				<dd>this is triggered when a Research Facility has been built.</dd>
				<dt><code>CALL_FACTORY_BUILT</code></dt>
				<dd>this is triggered when a Factory has been built.</dd>
				<dt><code>CALL_MISSION_START</code></dt>
				<dd>this is triggered when CTRL + 'M' is pressed so that the script can start a mission.</dd>
				<dt><code>CALL_MISSION_END</code></dt>
				<dd>this is triggered when CTRL + 'B' is pressed so that the script can end a mission.</dd>
				<dt><code>CALL_VIDEO_QUIT</code></dt>
				<dd>this is triggered when the CURRENT video sequence is over, either end of anim or when 'ESC' has been pressed.</dd>
				<dt><code>CALL_LAUNCH_TRANSPORTER</code></dt>
				<dd>this is triggered when the 'Launch' button is pressed on the Transporter interface.</dd>
				<dt><code>CALL_START_NEXT_LEVEL</code></dt>
				<dd>this is triggered when a new level is desired.</dd>
				<dt><code>CALL_TRANSPORTER_REINFORCE</code></dt>
				<dd>this is triggered when a transporter carrying reinforcements for player 0 enters the map.</dd>
				<dt><code>CALL_MISSION_TIME</code></dt>
				<dd>this is triggered when the time specified by setMissionTime() has elapsed.</dd>
				<dt><code>CALL_ELECTRONIC_TAKEOVER</code></dt>
				<dd>triggered when a unit or a structure for the selectedPlayer are taken over using Electronic weapons.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="callbacks_with_parameters">Callbacks with parameters</h3>
			<dl>
				<dt><code>CALL_RESEARCHCOMPLETED, ref RESEARCHSTAT, ref STRUCTURE</code></dt>
				<dd>This is triggered when a research topic is complete - major or minor.. RESEARCHSTAt is the research topic that was complete, STRUCTURE is research facility that has completed research.</dd>
				<dt><code>CALL_NEWDROID, player, ref DROID, ref STRUCTURE</code></dt>
				<dd>triggered when a unit for player is built by a factory. DROID is the unit that was built. structure is the factory that built it, do not assume that the factory is still there!!.</dd>
				<dt><code>CALL_STRUCT_ATTACKED, player, ref STRUCTURE, ref BASEOBJ</code></dt>
				<dd>triggered when a structure for player is attacked. STRUCTURE is the attacked structure, . BASEOBJ is the unit that attacked the structure (could be NULLOBJECT).</dd>
				<dt><code>CALL_DROID_ATTACKED, player, ref DROID, ref BASEOBJ</code></dt>
				<dd>triggered when a unit for player is attacked. DROID is the attacked unit, . BASEOBJ is the unit that attacked (could be NULLOBJECT).</dd>
				<dt><code>CALL_ATTACKED, player, ref BASEOBJ, ref BASEOBJ</code></dt>
				<dd>triggered when a structure or unit for player is attacked. BASEOBJ is the attacked unit, . BASEOBJ is the unit that attacked (could be NULLOBJECT).</dd>
				<dt><code>CALL_TRANSPORTER_OFFMAP, player</code></dt>
				<dd>triggered when a transporter for player exits the map.</dd>
				<dt><code>CALL_TRANSPORTER_LANDED, GROUP, player</code></dt>
				<dd>triggered when transporter for player lands; units on transporter are unloaded. into the given GROUP.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="tutorial_callbacks">Tutorial Callbacks</h3>
			<dl>
				<dt><code>CALL_BUILDLIST</code></dt>
				<dd>Build structures interface up.</dd>
				<dt><code>CALL_BUILDGRID</code></dt>
				<dd>Place structure cursor up.</dd>
				<dt><code>CALL_RESEARCHLIST</code></dt>
				<dd>Choose research interface up.</dd>
				<dt><code>CALL_MANURUN</code></dt>
				<dd>Number of units to manufacture has changed.</dd>
				<dt><code>CALL_MANULIST</code></dt>
				<dd>Choose manufacturing interface up.</dd>
				<dt><code>CALL_BUTTON_PRESSED, buttonID</code></dt>
				<dd>triggered when an interface button with id buttonID is pressed.</dd>
				<dt><code>CALL_DESIGN_QUIT</code></dt>
				<dd>triggered when the design screen is closed.</dd>
				<dt><code>CALL_OBJ_DESTROYED, int player, ref BASEOBJ object</code></dt>
				<dd>triggered when either a unit or a structure for player is destroyed.</dd>
				<dt><code>CALL_DROID_DESTROYED, int player, ref DROID droid</code></dt>
				<dd>triggered when a unit for player is destroyed.</dd>
				<dt><code>CALL_STRUCT_DESTROYED, int player, ref STRUCTURE structure</code></dt>
				<dd>triggered when a structure for player is destroyed.</dd>
				<dt><code>CALL_FEATURE_DESTROYED, ref FEATURe feature</code></dt>
				<dd>triggered when either a unit or a structure for player is destroyed.</dd>
				<dt><code>CALL_OBJ_SEEN, int player, ref BASEOBj object, ref BASEOBJ viewer</code></dt>
				<dd>triggered when either a unit or a structure is seen by a unit belonging to player.. object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).</dd>
				<dt><code>CALL_DROID_SEEN, int player, ref BASEOBJ object, ref BASEOBJ viewer</code></dt>
				<dd>triggered when a unit is seen by a unit belonging to player.. object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).</dd>
				<dt><code>CALL_STRUCT_SEEN, int player, ref BASEOBJ object, ref BASEOBJ viewer</code></dt>
				<dd>triggered when a structure is seen by a unit belonging to player.. object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).</dd>
				<dt><code>CALL_NO_REINFORCEMENTS_LEFT</code></dt>
				<dd>called when the player has transferred all reinforcements from one level to the next.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>

			<h3 id="tutorial_callbacks_tutonly">Tutorial callbacks (tutorial only)</h3>
			<dl>
				<dt><code>CALL_DESIGN_WEAPON</code></dt>
				<dd>a weapon button pressed.</dd>
				<dt><code>CALL_DESIGN_SYSTEM</code></dt>
				<dd>a system (constructor/ecm/sensor/etc) button pressed.</dd>
				<dt><code>CALL_DESIGN_COMMAND</code></dt>
				<dd>a command droid turret pressed.</dd>
				<dt><code>CALL_DESIGN_BODY</code></dt>
				<dd>a body selected.</dd>
				<dt><code>CALL_DESIGN_PROPULSION</code></dt>
				<dd>a propulsion selected.</dd>
				<dt><code>CALL_ALL_ONSCREEN_DROIDS_SELECTED</code></dt>
				<dd>does exactly when it says on the box.</dd>
				<dt><code>CALL_UNITTAKEOVER, ref unit</code></dt>
				<dd>Unit has been taken over by nexus link.</dd>
				<dt><code>CALL_PLAYERLEFT, ref int player</code></dt>
				<dd>Player has left the multiplayer game.</dd>
				<dt><code>CALL_ALLIANCEOFFER, ref int one, ref int two</code></dt>
				<dd>One offers two an alliance.</dd>
			</dl>
			<div class="rt">
				<p><a href="#top" class="locallink">back to top</a></p>
			</div>
			<hr/>

			<p>Warzone2100. Script language notes.</p>
			<p>Original Author: Pumpkin Studios. 1999</p>
			<p>Last Author: $Author$</p>
			<p>Last update: $Date$, $Revision$, 	<a href="http://wz2100.net/">WRP</a></p>
			<p>Note from Pumpkin Studios: making any modifications to Warzone 2100 will void any technical support open to you. We will not answer questions or help you in any way if you have modified Warzone 2100. Pumpkin Studios and Eidos will not take responsibility for any damage resulting from modifcation of Warzone 2100.</p>
		</div>
	</body>
</html>
