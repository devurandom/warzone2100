/////////////////////////////////////////////////////////////////////
// ai for skirmish game
/////////////////////////////////////////////////////////////////////
// Warzone2100, Pumpkin Studios, 
// alex lee.98/99.
//
// This script does the following.
// -------------------------------
// structural rules
//  * ensure we have derricks.
//  * if oil in range with no derrick on . build
//  * if idle and derrick in range and no defense then build defense, else rtb.
//  * build a power gen for every 4 derricks.
//  * ensure we have everything in the vital structs list.
//  * build stage two.. build other stuff, grow the base slowly...
//  * Structure (fac/res/pow) upgrades
//	* Finish Building Part Built Structures 
//  * keep details about the size and postion of the ai players base
//  * fortify base by building defensive structs on the edge of the base.
// vehicle rules
//  * deal with a droid being built 
//  * deal with attacks. 
//  * build more con droids.
//  * build better droids as time goes on.
//  * put vehicle factories to work
//  * put cyborg factories to work
//  * scout an area
//  * dont unneccesarily wonder around the base. (better comms and faster play)
//  * visit new places
//  * order scouts
//  * process new visibility reports
//  * send attack team out to cause trouble near things scout found.
//  * defend attacked objects.
//  * defenders  return after they are finished.
//  * dont ever build more than 80 units. 
// management rules
//  * do research
//  * form alliances
//  * break the alliance too.
//  * bring forces back together to consolidate attacks
//  * stop building stuff on low power, but only when appropriate. maybe: no power == build lighter units.
// vtol rules
//  * if any player attacks with a vtol. build a vtol defense within range of the attacked strucutre..
//  * build a vtol factory if required.
//  * make sure that vtol factories have pads.
//  * vtol factories build vtols.
//  * groups of vtols attack the attack and defend group targets..

//  ** dont attack pc players with purpose.
//  ** form alliances against the humans..
//  ** attack quicker than release
//  ** use cyborgs for defense only
//  ** build and use repair facilities.
//  ** store locations when see other hq's/good targets.
//  ** use stored location to plan an all out attack.
//  ** attack walls with a low prioirty, they made lead to a base you cant yet see.


// *** more aggressive attack points
// *** cut comms by 75% (c)
// *** auto research. no more arrays.. (c)
// *** dont wall yourself in (c) 
// *** template manipulation
// *** vtol decision making
// *** no more research cheating.
// *** vtol upgrades
// *** better defense choice.

// still to do / should do
// -----------------------
//  * build walls in bright places.
//  * jump base!

/////////////////////////////////////////////////////////////////////

public	INT				player;				// player for this instance.

public	INT				tileExpand;

public	INT				numScouts;			// aim for...
public	INT				numDefenders;
public	INT				numAttackers;

// structures
private INT				baseX,baseY,minx,miny,maxx,maxy;				// base details
public	INT				numStructs,numDefStructs,numExtraStructs;							
public	STRUCTURESTAT	structs[5],defStructs[26],extraStructs[6],structChoice[5];
public	STRUCTURESTAT	resLab,powGen,playerHQ,factory,derrick,cybFactory,vtolDefStruct[5],vtolPad,vtolFactory,repairFacility;
public	STRUCTURESTAT	powModule,facModule,resModule,vtolModule;
public	INT				extraStruct;

// common droid types.

public	INT				numTemplates;
public	TEMPLATE		tmpl[80];
private	TEMPLATE		tmplChoice[5];

public	TEMPLATE		cybTempl[4];

public	TEMPLATE		vtols[18];
public	INT				numVtolTemplates;

public	TEMPLATE		sense[11];
public	INT				numSenseTemplates;

//
public	TEMPLATE		constructor,repairUnit;				
public	INT				numCyborgs,numRepairUnits;
private INT				currentCyborgs,currentCyborgTemplate;

//defend
private GROUP			defendGroup;
private BOOL			defendbusy;
private BASEOBJ			defendObj;

//build
private GROUP			buildGroup;
private INT				buildX,buildY;
public	FEATURESTAT		oilRes;

// scout
private GROUP			scoutGroup;
private INT				scoutX,scoutY;
private INT				scoutTLX,scoutTLY,scoutW,scoutH;

// attack
private GROUP			attackGroup;
private BASEOBJ			attackObj,allOutAttack;

// vtols
private GROUP			vtolGroup;
//public	TEMPLATE		vtolTemplate;

// generic
private STRUCTURE		structure;
private DROID			droid;
private FEATURE			feature;
private BASEOBJ			baseobj,baseobj2;
private INT				count,count2,result,tempx,tempy;
private BOOL			boolResult,boolResult2;

private BOOL			powerSave;

private	INT				allianceTime[8];

/////////////////////////////////////////////////////////////////////
// triggers.

trigger buildExpandTr				(every, 900);
trigger fortifyTr					(every,	2110);
trigger upgradeStructuresTr			(every, 590 );
trigger conDroidsTr					(every, 3600);
trigger repairDroidsTr				(every, 2600);
trigger	managePowerTr				(every, 2000);
trigger basedetailsTr				(every, 700	);
trigger buildDerrickTr				(every, 110	);
trigger buildOilDefenseOrRetreatTr	(every, 170	);
trigger buildPowerGeneratorsTr		(every, 90	);
trigger buildBaseTr					(every, 210	);
trigger finishStructsTr				(every, 610 );
//event droidBuilt					(CALL_NEWDROID,player, ref droid,ref structure)
//event droidDestroyed				(CALL_DROID_DESTROYED,  player, ref droid)
trigger consolidateEventTr			(every,	3100);
trigger factoryEventTr				(every, 200	);
trigger cyborgFactoryEventTr		(every, 200	);
trigger chooseScoutAreaTr			(every,	200	);
trigger expandScoutAreaTr			(every,	600	);
trigger scoutMainTr					(every,	150	);
//event newObjectReport				(CALL_OBJ_SEEN, player, ref baseobj, ref baseobj2)
trigger attackStuffTr				(every, 300	);
trigger allOutAttackTr				(every, 2380);
//event defendWatch					(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
trigger defendReturnTr				(every,	600	);
trigger doResearchTr				(every, 500 );
//event vtolDefend(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
trigger vtolStructsTr				(every, 360);		
trigger buildVtolsTr				(every, 360);		
trigger vtolAttackTr				(every, 460);			
trigger vtolEnablerTr				(every, 2100);

/////////////////////////////////////////////////////////////////////
// HouseKeeping

event initialisedEvent(CALL_GAMEINIT)
{

	// setup build group
	//all initial droids are in buildgroup! (assume only constructs for now)

	extraStruct = 0;

	numRepairUnits = 0;
	
	allOutAttack = NULLOBJECT;

	groupAddArea(buildGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));  
	initGetFeature(oilRes,player,player);		// use bucket = player

	// note where our base is.
	initIterateGroup(buildGroup);		// find idle droids in build group.
	droid = iterateGroup(buildGroup);
	if(droid != NULLOBJECT)
	{
		baseX = droid.x;
		baseY = droid.y;
	}
	else
	{
		baseX = (128*mapWidth)/2;
		baseY = (128*mapHeight)/2;
	}

	// defence.
	defendbusy = FALSE;
	
	// setup scouts
	structure = getStructure(factory, player);
	if(structure != NULLOBJECT)
	{	
		scoutTLX		= structure.x;
		scoutTLY		= structure.y;
	}
	else
	{
		scoutTLX		= baseX;
		scoutTLY		= baseY;
	}
	scoutW			= 256;
	scoutH			= 256;
	scoutX			= scoutTLX;
	scoutY			= scoutTLY;

	currentCyborgTemplate = 0;
	powerSave = FALSE;

	allianceTime[0] = 0;
	allianceTime[1] = 0;
	allianceTime[2] = 0;
	allianceTime[3] = 0;
	allianceTime[4] = 0;
	allianceTime[5] = 0;
	allianceTime[6] = 0;
	allianceTime[7] = 0;
}

/////////////////////////////////////////////////////////////////////

event givehelp(every, 100)
{
 	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{
		setEventTrigger(givehelp,	inactive);			
	}
	else
	{
		if(multiPlayerBaseType == CAMP_WALLS)
		{
			// free power
			addPower(1500, player);

			// free droids.
			structure = getStructure(factory, player);
			if(structure != NULLOBJECT)
			{
				count = 0;
				while(count<10)
				{
					tempx = baseX;
					tempy = baseY;
					 
				
					boolResult = pickStructLocation(defStructs[0], ref tempx, ref tempy,player);
					if(boolResult == TRUE)
					{
						addDroid(tmpl[ random(6) ]  , tempx, tempy, player);
					}

					count = count + 1;
				}
			}
		}
		setEventTrigger(givehelp,	inactive);			

	}
}

/////////////////////////////////////////////////////////////////////
// keep details about the size and postion of the ai players base
event basedetails(basedetailsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{
		setEventTrigger(basedetails,	inactive);			
	}
	else
	{
		// clear old extremities.
		maxy = 0;
		maxx = 0;
		miny = (mapHeight*128);
		minx = (mapWidth*128);

		// now find the extremities of our vital structures.	
		count = 0;
		while(count < numStructs)
		{
			initEnumStruct(FALSE,structs[count],player,player);					
			structure= enumStruct();
			while(structure != NULLOBJECT)	
			{
				if(structure.x < minx)
				{
					minx = structure.x;
				}
				if(structure.x > maxx)
				{
					maxx = structure.x;	
				}
				if(structure.y < miny)
				{
					miny = structure.y;
				}
				if(structure.y > maxy)
				{
					maxy = structure.y;
				}
				structure= enumStruct();
			}
			count = count + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// structure building rules

// ensure we have derricks.
// if oil in range with no derrick on . build

event buildDerrick(buildDerrickTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildDerrick,	inactive);			
	}
	else
	{
		feature = getFeature(player);					// find unoccupied oil resource.
		if(feature != NULLOBJECT)
		{
			buildX = feature.x;
			buildY = feature.y;

			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			boolResult = FALSE;							// only send 1 droid to each derrick
			while( (boolResult == FALSE) and (droid != NULLOBJECT))
			{
				if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);	//build a derick
					boolResult = TRUE;
				}
				droid = iterateGroup(buildGroup);
			}
		}
		else											// feature is null
		{
			initGetFeature(oilRes,player,player);		// start again next time.
		}
	}
}

/////////////////////////////////////////////////////////////////////
// if idle and derrick in range and no defense then build defense, else rtb.
event buildOilDefenseOrRetreat(buildOilDefenseOrRetreatTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildOilDefenseOrRetreat,	inactive);			
	}
	else
	{
		// check idle.
		initIterateGroup(buildGroup);					// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				// if in range of a derrick				 
				structure = structureBuiltInRange(derrick, droid.x, droid.y, (3*128), player);

				// if inside base limits then presume ok..
				if( structure != NULLOBJECT)
				{
					if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))	
					{
						structure = NULLOBJECT;
					}
				}

				if(structure != NULLOBJECT)
				{
					buildX = droid.x;
					buildY = droid.y;
					
					count = 0;							// if derrick has no defense near it.
					result = 0;
					while(count < numDefStructs)
					{	
						structure = structureBuiltInRange(defStructs[count], droid.x, droid.y,(3*128), player);
						if(structure != NULLOBJECT)
						{				
							result = 1;								// found a defense. 
						}
						count = count + 1;
					}

					// not many defenses nearby
					if(result < 2)
					{
					
						//pick a struct to build..
						count = numDefStructs - 1;
						count2 = 0;
						while( (count2 < 5) and (count >= 0) )
						{
							if( isStructureAvailable(defStructs[count],player))
							{
								structChoice[count2] = defStructs[count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
						count =0;
						if(count2 > 0)
						{
							count = random(count2);						 //count = choice!

	//OLD					result = random(numDefStructs);				// pick a structure
							// pick a location 
							boolResult = pickStructLocation(structChoice[count], ref buildX, ref buildY,player);
							if(boolResult == TRUE)
							{	
								// don't choose x(sensor) if it's in range already. use xyz instead.			
								if(count == 5)
								{	
									structure = structureBuiltInRange(structChoice[count], buildX, buildY,(5*128), player);
									if(structure != NULLOBJECT)
									{
										count = 8;
									}
								}

								// build it.
								orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
							}
						}				
					}
					else
					{	
						structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), player);	
						if(structure == NULLOBJECT)
						{
							orderDroid(droid,DORDER_RTB);				// return to base;
						}
					}					
				}
				else
				{
					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), player);	
					if(structure == NULLOBJECT)
					{
						orderDroid(droid,DORDER_RTB);					// return to base;
					}
				}
			}	
			droid = iterateGroup(buildGroup);
		}
	}
}


/////////////////////////////////////////////////////////////////////
// build a power gen for every 4 derricks. VITAL!
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildPowerGenerators,	inactive);			
	}
	else
	{
		initEnumStruct(FALSE,derrick,player,player);					// count = numderricks
		structure= enumStruct();
		count	 = 0;
		while(structure != NULLOBJECT)	
		{
			count = count + 1;
			structure= enumStruct();
		}
			
		initEnumStruct(FALSE,powGen,player,player);					// count2 = numpowgens
		structure= enumStruct();
		count2	 = 0;
		while(structure != NULLOBJECT)	
		{
			count2 = count2 + 1;
			structure= enumStruct();
		}
								
		if( (count2 * 4) < count )								// if we need powergen
		{
			buildX = baseX;										// try build powergen.
			buildY = baseY;
			boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{	
				initIterateGroup(buildGroup);				
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
					}
					droid = iterateGroup(buildGroup);
				}	
					
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
// ensure we have everything in the vital structs list.
event buildBase(buildBaseTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildBase,	inactive);			
	}
	else
	{
		if( idleGroup(buildGroup) >= (buildGroup.members/2) )
		{
			count = 0;
			while(count < numStructs)
			{
				// check that struct.
				structure = getStructure(structs[count],player);
				if(structure == NULLOBJECT)				// if missing build it.
				{
					buildX = baseX;						// pick a location 
					buildY = baseY;
					boolResult = pickStructLocation(structs[count], ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{	
						initIterateGroup(buildGroup);				// find idle droids in build group.
						droid = iterateGroup(buildGroup);
						while(droid != NULLOBJECT)
						{				
							if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,structs[count], buildX,buildY);	// build it
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
				count = count + 1;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
//  build other stuff, grow the base slowly...
event buildExpand( buildExpandTr )
{

	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildExpand,inactive);			
	}
	else
	{

		if(extraStruct == numExtraStructs)	// loop round
		{
			extraStruct = 0;
		}

		buildX = baseX;						// pick a location 
		buildY = baseY;
		boolResult = pickStructLocation(extraStructs[extraStruct], ref buildX, ref buildY,player);
	
		if(boolResult == TRUE)
		{	
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order != DORDER_BUILD)
				{	
					orderDroidStatsLoc(droid, DORDER_BUILD,extraStructs[extraStruct], buildX,buildY);// build it.
				}
				droid = iterateGroup(buildGroup);
			}
			extraStruct = extraStruct + 1;
		}
	}
}


/////////////////////////////////////////////////////////////////////
//	Structure (fac/res/pow) upgrades
event upgradeStructures(upgradeStructuresTr )
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(upgradeStructures,inactive);			
	}
	else
	{
		initIterateGroup(buildGroup);				// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order != DORDER_BUILD)
			{	
				// got an idle constructor vehicle.
				//powergen
				initEnumStruct(FALSE,powGen,player,player);									
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)))			
					{
						orderDroidStatsLoc(droid,DORDER_BUILD,powModule, structure.x,structure.y);// upgrade it.				
					}
					structure= enumStruct();
				}
			
				//factory
				initEnumStruct(FALSE,factory,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)	
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 3 ))			
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.			
					}
					structure= enumStruct();
				}

				//research
				initEnumStruct(FALSE,resLab,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)	
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)))			
					{			
						orderDroidStatsLoc(droid, DORDER_BUILD,resModule, structure.x,structure.y);	// upgrade it.			
					}
					structure= enumStruct();
				}
				
				//vtol Factory
				initEnumStruct(FALSE,vtolFactory,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)	
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(facModule,player) and (not testStructureModule(player, structure, 0)))			
					{			
						orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.			
					}
					structure= enumStruct();
				}			
			}
			droid = iterateGroup(buildGroup);	
		}
	}
}


/////////////////////////////////////////////////////////////////////
//	Finish Building Part Built Structures 
event finishStructs(finishStructsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(finishStructs,	inactive);			
	}
	else
	{
		initEnumStruct(TRUE,factory,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)	
		{	
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);				// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order != DORDER_BUILD) 
					{	
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
					}
					droid = iterateGroup(buildGroup);
				}
			}
			structure= enumStruct();
		}
	}
}


/////////////////////////////////////////////////////////////////////
//  fortify base by builiding defensive structs on the edge of the base.
event fortify(fortifyTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(fortify,	inactive);			
	}
	else
	{
		boolResult = FALSE;
		initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
		droid = iterateGroup(buildGroup);
		while((boolResult == FALSE) and (droid != NULLOBJECT))
		{
			if(droid.order != DORDER_BUILD)
			{	
				boolResult = TRUE;					// dont do this again!
				
				// pick a side of the base.
				tempx = 0;
				tempy = 0;
				result = random(4);
				if(result == 0)
				{
					tempx = minx - (3*128);
				}
				else if(result == 1)
				{
					tempx = maxx + (3*128);
				}
				else if(result == 2)
				{
					tempy = miny - (3*128);
				}
				else
				{
					tempy = maxy + (3*128);
				}

				// pick the other point at the edge of the base.....
				if(tempx == 0)
				{
					tempx = random( maxx - minx ) + minx;
				}
				if(tempy ==0)
				{
					tempy = random( maxy - miny ) + miny;
				}

				//pick a struct to build..
				count = numDefStructs - 1;
				count2 = 0;
				while( (count2 < 5) and (count >= 0) )
				{
					if( isStructureAvailable(defStructs[count],player))
					{
						structChoice[count2] = defStructs[count];
						count2 = count2 + 1;
					}
					count = count - 1;
				}
				count =0;
				if(count2 > 0)
				{
					count = random(count2);		 //count = choice!
					// pick a location 
					boolResult = pickStructLocation(structChoice[count], ref tempx, ref tempy,player);
					if(boolResult == TRUE)
					{	
						// don't choose x(sensor) if it's in range already. use xyz instead.			
						if(count == 5)
						{	
							structure = structureBuiltInRange(structChoice[count], tempx, tempy,(5*128), player);
							if(structure != NULLOBJECT)
							{
								count = 8;
							}
						}

						// build it.
						orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], tempx,tempy);
					}
				}				
					
			}
			droid = iterateGroup(buildGroup);
		}	
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// droid building rules


/////////////////////////////////////////////////////////////////////
// deal with a droid being built 
event droidBuilt(CALL_NEWDROID,player, ref droid,ref structure)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(droidBuilt,	inactive);			
	}
	else
	{
		if(isVtol(droid))
		{
			groupAddDroid(vtolGroup, droid);
		}
		else
		{
			if(droid.droidType == DROID_REPAIR)
			{
				numRepairUnits = numRepairUnits + 1;
			}
			if(droid.droidType == DROID_CONSTRUCT)				// if not constructor droid 
			{	
				groupAddDroid(buildGroup, droid);
			}
			else
			{
				if(droid.droidType == DROID_CYBORG)
				{
					groupAddDroid(defendGroup, droid);
				}
				else
				{	
					if(scoutGroup.members < numScouts)
					{	
						groupAddDroid(scoutGroup, droid);
					}
					else if( attackGroup.members < numAttackers)
					{
						groupAddDroid(attackGroup, droid);
					}
					else if( defendGroup.members < numDefenders)
					{
						groupAddDroid(defendGroup, droid);
					}
				
					else		// just make them scouts.
					{	
						if(attackGroup.members > scoutGroup.members)
						{
							groupAddDroid(scoutGroup, droid);
						}
						else
						{
							groupAddDroid(attackGroup, droid);
						}
					}
				}
			}

			structure = getStructure(repairFacility,player);
			if(structure == NULLOBJECT)				
			{
				setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
			}
			else
			{
				setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_LOW);
			}
		

		}
	}	
}

/////////////////////////////////////////////////////////////////////
// deal with attacks. 
event droidDestroyed(CALL_DROID_DESTROYED,  player, ref droid)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(droidDestroyed,inactive);			
	}
	else
	{
		if(droid.droidType == DROID_REPAIR)
		{
			numRepairUnits = numRepairUnits - 1;
		}

		if(droid.droidType == DROID_CONSTRUCT)					// if constructor droid 
		{
			initEnumStruct(FALSE,factory,player,player);
			structure= enumStruct();							// find factory.

			if( (structure != NULLOBJECT) and (getDroidCount(player) < 80) )
			{
				buildDroid(constructor, structure, player, 1);	// build constructor
			}

		}
	}
}


/////////////////////////////////////////////////////////////////////
// build more con droids.
event conDroids(conDroidsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(conDroids,inactive);			
	}
	else
	{	
		initEnumStruct(FALSE,factory,player,player);
		structure= enumStruct();							// find factory.

		if((structure != NULLOBJECT)  and (getDroidCount(player) < 80) )
		{
			buildDroid(constructor, structure, player, 1);// build constructor
		}
	}
}

/////////////////////////////////////////////////////////////////////
// build repair droids.
event repairDroids(repairDroidsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(repairDroids,inactive);			
	}
	else
	{
		// if we're running low on repair droids, build some..
		if(numRepairUnits <3)
		{
			initEnumStruct(FALSE,factory,player,player);
			structure= enumStruct();							// find factory.
			if( (structure != NULLOBJECT) and (getDroidCount(player) < 80) )
			{
				buildDroid(repairUnit, structure, player, 1);	// build repairunit.
			}
		}

	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//NEW FACTORY EVENT
//go down the template list.
//check if you can build each given template.
//stop when you have x templates.
//pick one of the x and build it.

event factoryEvent(factoryEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(factoryEvent,	inactive);			
	}
	else
	{
		// for each factory....
		initEnumStruct(FALSE,factory,player,player);
		structure= enumStruct();								// find factory.
		if(getDroidCount(player) < 80)
		{
			while(structure != NULLOBJECT)
			{
				if( structureIdle(structure) == TRUE)
				{	

					count = numTemplates - 1;
					count2 = 0;
					while( (count2 < 5) and (count >= 0) )
					{
						if( skCanBuildTemplate(player,structure, tmpl[count]) )
						{
							tmplChoice[count2] = tmpl[count];
							count2 = count2 + 1;
						}
						count = count - 1;
					}

					if(count2 > 0)
					{
						buildDroid(tmplChoice[random(count2)],structure,player,1);
					}				
				}
				structure= enumStruct();							// find factory.

			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// put cyborg factories to work
event cyborgFactoryEvent(cyborgFactoryEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(cyborgFactoryEvent,	inactive);			
	}
	else
	{
		initEnumStruct(FALSE,cybFactory,player,player);
		structure= enumStruct();								// find factory.

		while(structure != NULLOBJECT)
		{
			if( structureIdle(structure)  == TRUE)
			{	
				if( (defendGroup.members < numCyborgs) and (getDroidCount(player) < 80) )
				{
					buildDroid(cybTempl[currentCyborgTemplate], structure, player, 1);
				}
			}
			structure= enumStruct();							// find factory.
		}
		
		// increment cyborg template counter, wrapping if required.
		currentCyborgTemplate = currentCyborgTemplate + 1;
		if( currentCyborgTemplate > 3)
		{
			currentCyborgTemplate = 0;
		}

	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// scouting rules

// scout an area
event chooseScoutArea(chooseScoutAreaTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(chooseScoutArea,	inactive);			
	}
	else
	{	
		scoutX = scoutTLX + random(scoutW);
		scoutY = scoutTLY + random(scoutH);
	}
}

/////////////////////////////////////////////////////////////////////
// visit new places

event expandScoutArea(expandScoutAreaTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(expandScoutArea,	inactive);			
	}
	else
	{
		//expand the scouting area slightly
		scoutTLX	= scoutTLX - ((mapWidth*128)/ tileExpand);
		scoutTLY	= scoutTLY - ((mapHeight*128)/ tileExpand);
		scoutW		= scoutW + (2*((mapWidth*128)/ tileExpand));
		scoutH		= scoutH + (2*((mapHeight*128)/ tileExpand));

		// check & restrain.
		if(scoutTLX <1)
		{
			scoutTLX = 1;
		}
		if(scoutTLY <1)
		{
			scoutTLY = 1;
		}

		if(scoutTLX >(mapWidth*128))
		{
			scoutTLX = (mapWidth*128) - 128;
		}
		if(scoutTLY >(mapHeight*128))
		{
			scoutTLY = (128*mapHeight) - 128;
		}

		if( (scoutTLX + scoutW) > (128 * mapWidth) )
		{
			scoutW = ( (128 * mapWidth) - scoutTLX) - 128;
		}
		if( (scoutTLY + scoutH) > (128 *mapHeight) )
		{
			scoutH = ( (128*mapHeight) - scoutTLY) - 128;
		}
	}
}

/////////////////////////////////////////////////////////////////////
// order scouts

event scoutMain(scoutMainTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(scoutMain,	inactive);			
	}
	else
	{
		// find any new scouts
		// if scouts aren't busy, send them to a new spot.
		if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
		{	
			orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
		}
	}
}

/////////////////////////////////////////////////////////////////////
// process new visibility reports
event newObjectReport(CALL_OBJ_SEEN, player, ref baseobj, ref baseobj2)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(newObjectReport,	inactive);			
	}
	else
	{
		if( baseobj2 != NULLOBJECT )
		{
			if(baseobj2.type == OBJ_DROID)				
			{
				if( isHumanPlayer(baseobj.player) )	// new in wdg1 dont allout attack a pc player
				{
					attackObj = baseobj;// got a new unseen human target from a scout.

					if(	attackObj.type == OBJ_STRUCTURE)// if hq plan all out attack.
					{
						structure = objToStructure(attackObj);
						if(structure.stat == factory)
						{
							allOutAttack = attackObj;
						}
					}

				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// attack rules

event findEnemy(attackStuffTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(findEnemy,	inactive);			
	}
	else
	{
		if(attackObj == NULLOBJECT)
		{
			count = random(8);
			while( not isHumanPlayer(count) )
			{
				count = random(8);
			}
			baseobj = skLocateEnemy(count);
			if(baseobj != NULLOBJECT)
			{
				attackObj =	baseobj;
				allOutAttack = attackObj;
			}
		}
	}

}

// send attack team out to cause trouble near things scout found.
event attackStuff(attackStuffTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(attackStuff,	inactive);			
	}
	else
	{
		if( idleGroup(attackGroup) >= (attackGroup.members /2)) 
		{	
			if(attackObj != NULLOBJECT)
			{
				if(attackGroup.members > (6+random(6)) ) 
				{		
					orderGroupLoc(attackGroup, DORDER_SCOUT,attackObj.x,attackObj.y);
				}
				if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
				{	
					orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
				}
			}

		}
	}
}

/////////////////////////////////////////////////////////////////////
event doAllOutAttack(allOutAttackTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(attackStuff,	inactive);			
	}
	else
	{
		if( allOutAttack != NULLOBJECT )	// human special struct to go kill. yum....
		{	
			if( getDroidCount(player) > 40)	// plenty of units.
			{
					orderGroupObj(attackGroup, DORDER_ATTACK,allOutAttack);
					orderGroupLoc(defendGroup, DORDER_SCOUT,allOutAttack.x,allOutAttack.y);
					orderGroupLoc(scoutGroup,  DORDER_SCOUT,allOutAttack.x,allOutAttack.y);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// defending rules

// defend attacked objects.
event defendWatch(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(defendWatch,	inactive);			
	}
	else
	{
		if(baseobj != NULLOBJECT)
		{
			if(not isHumanPlayer(baseobj.player) )	// new in wdg1 dont allout attack a pc player
			{
				defendObj = baseobj;
				defendbusy = TRUE;
				// if not too busy, attack.
				if( idleGroup(defendGroup) >= (defendGroup.members /2) )
				{			
					orderGroupObj(defendGroup, DORDER_ATTACK, defendObj);
				}

				if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
				{	
					orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
				}

			}
		}		
	}
}

/////////////////////////////////////////////////////////////////////
// defenders  return after they are finished.
event defendReturn(defendReturnTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(defendReturn,	inactive);			
	}
	else
	{
		if( defendbusy and (idleGroup(defendGroup) == defendGroup.members))
		{
			orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
			defendbusy = FALSE;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Research Rules
// do research

event doResearch(doResearchTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(doResearch,	inactive);			
	}
	else
	{
		// for every research lab do this..
		initEnumStruct(FALSE,resLab,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)	
		{
			skDoResearch(player,0);
			structure= enumStruct();
		}
	
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Alliance Rules

// form alliances
event formAllianceEvent(every,170)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(formAllianceEvent,	inactive);			
	}
	else
	{
		count = 0;
		while(count<8)
		{
			if( count != player )												// if not the only other player and rand2
			{
				if((getDroidCount(player) > 1) and (getDroidCount(count) > 1) )	// not dead
				{
					if(random(28) == 1)											// bit random
					{
						if(not isHumanPlayer(count))							// not human
						{
							createAlliance(player,count);
							allianceTime[count] = gameTime;
						}
					}
				}
			}
			count = count + 1;	
		}
	}
}

/////////////////////////////////////////////////////////////////////
// break the alliance too.
event breakAllianceEvent(every,700)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(breakAllianceEvent,	inactive);			
	}
	else
	{
		count = 0;
		while(count<8)
		{
			if( count != player )
			{
				if((getDroidCount(player) > 1) and (getDroidCount(count) > 1) )	// not dead
				{
					// check if we're in alliance with any other players.
					if( (random(30) == 1) and ( (gameTime - allianceTime[count]) > 6000) )		// rand and more than 10 minutes.
					{
						allianceTime[count] = 0;
						breakAlliance(player,count); 
					}
							
				}
			}
			count = count + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Consolidate Rules

// bring forces back together to consolidate attacks
event consolidateEvent(consolidateEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(consolidateEvent,	inactive);			
	}
	else
	{
		if(random(3 ) == 1)				// order all droids home to rejoin forces.!
		{
			orderGroupLoc(scoutGroup, DORDER_MOVE,baseX,baseY);
			orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
		}

		if(attackObj != NULLOBJECT)	// consolidate any ongoing attack.
		{
			orderGroupObj(attackGroup, DORDER_ATTACK,attackObj);
		}
		else
		{
			orderGroupLoc(attackGroup, DORDER_MOVE,baseX,baseY);
		}

	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// power management.

// if running low on power put some power eating stuff on hold for a while.
event managePower(managePowerTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(managePower,	inactive);			
	}
	else
	{
		if( playerPower(player) < 250 )	// turn off some events.
		{
			powerSave = TRUE;	

			setEventTrigger(fortify,			inactive);	// stop building defenses.
			setEventTrigger(upgradeStructures,	inactive);	// stop building oil defenses.
		//	setEventTrigger(buildExpand,		inactive);	// stop building extra buildings.
			setEventTrigger(conDroids,			inactive);	// stop building more construct droids.
		}
		else
		{
			if(powerSave == TRUE)		// turn events back on.
			{
			powerSave = FALSE;
				
			setEventTrigger(fortify,			fortifyTr);			 //  building defenses.
			setEventTrigger(upgradeStructures,	upgradeStructuresTr);//  building oil defenses.
		//	setEventTrigger(buildExpand,		buildExpandTr);		 //  building extra buildings.
			setEventTrigger(conDroids,			conDroidsTr);	  	 //  building more construct droids.
			}
		}
	}
}

event leechPower(every, 600)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(managePower,	inactive);			
	}
	else
	{
		// if weve got powergen and a derrick
		structure = getStructure(derrick,player);	
		if(structure != NULLOBJECT)						
		{	
			structure = getStructure(powGen,player);	
			if(structure != NULLOBJECT)						
			{					
				addPower(200,player);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// vtols.



/////////////////////////////////////////////////////////////////////
// build vtol strucutures.
event vtolStructs(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolStructs,inactive);			
	}
	else
	{
		structure = getStructure(vtolFactory,player);	// if we dont have vtol factory
		if(structure == NULLOBJECT)						// if missing build it.
		{		
			// build factory
			buildX = baseX;								// pick a location 
			buildY = baseY;
			boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{
				initIterateGroup(buildGroup);			// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				boolResult = FALSE;						// only send 1 droid to do the job
				while( (boolResult == FALSE) and (droid != NULLOBJECT))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,vtolFactory, buildX,buildY);
						boolResult = TRUE;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
		else	// we have a factory..
		{
			// count rearm pads
			initEnumStruct(FALSE,vtolPad,player,player);
			structure= enumStruct();
			count	 = 0;
			while(structure != NULLOBJECT)	
			{
				count = count + 1;
				structure= enumStruct();
			}

			// do we have 2 or more rearm pads?
			if(count < 3)
			{
				// build vtol rearm pads.
				buildX = baseX;								// pick a location 
				buildY = baseY;
				boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);			// find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while( droid != NULLOBJECT)
					{
						if(droid.order != DORDER_BUILD) 
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,vtolPad, buildX,buildY);
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}


		}
	}
}


/////////////////////////////////////////////////////////////////////
// build vtols.

event buildVtols(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildVtols,inactive);			
	}
	else
	{
		structure = getStructure(vtolPad,player);			// got vtol pads?
		if(structure != NULLOBJECT)					
		{
			structure = getStructure(vtolFactory,player);	// got a vtolfac?	
			if(structure != NULLOBJECT)					
			{
				if(vtolGroup.members < 5)					// got enough vtols?
				{


					if( (structureIdle(structure) == TRUE) and (getDroidCount(player) < 80))	// if factory idle
					{

//OLD						buildDroid (vtolTemplate, structure, player, 1);// build vtols.
//NEW
						count = numVtolTemplates - 1;
						count2 = 0;
						while( (count2 < 3) and (count >= 0) )
						{
							if( skCanBuildTemplate(player,structure, vtols[count]) )
							{
								tmplChoice[count2] = vtols[count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
						if(count2 > 0)
						{
							buildDroid(tmplChoice[random(count2)],structure,player,1);
						}			
//endofnew.

					}
				}
			}
		}
	}
}



				
	


/////////////////////////////////////////////////////////////////////
// attack with vtols.

event vtolAttack(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolAttack,inactive);			
	}
	else
	{
		// if vtol group is not busy..
		if(  (idleGroup(vtolGroup) >= (vtolGroup.members /2)) and (vtolGroup.members > 2) )
		{	
			if(attackObj != NULLOBJECT)
			{ 
				orderGroupObj(vtolGroup, DORDER_ATTACK,attackObj);	// get the attack target.
			}
			else
			{
				if(defendObj != NULLOBJECT)
				{
					if(not isHumanPlayer(defendObj.player) )	// new in wdg1
					{
						orderGroupObj(vtolGroup, DORDER_ATTACK,defendObj);		// get the defend target
					}
				}
			}
		}
	}
}



/////////////////////////////////////////////////////////////////////
// watch for incoming vtols
event vtolDefend(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolDefend,inactive);			
	}
	else
	{
		boolResult2 = FALSE;					// if attacked by a vtol.
		if(baseobj != NULLOBJECT)
		{
			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					// activate other vtol functions..
					setEventTrigger(vtolStructs,vtolStructsTr);			
					setEventTrigger(buildVtols,	buildVtolsTr);			
					setEventTrigger(vtolAttack,	vtolAttackTr);			

					// build defenses.
					initIterateGroup(buildGroup);		// find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while( (boolResult2 != TRUE) and (droid != NULLOBJECT))
					{
						if( (structure != NULLOBJECT) and (droid.order != DORDER_BUILD) )
						{	
							buildX = structure.x;				
							buildY = structure.y;
							//	if ! vtol defense already built...

							//find best defense we can build.
							count = 0;
							count2 = -1;
							while( count < 5)
							{
								if(isStructureAvailable(vtolDefStruct[count],player))
								{
									count2 = count;
								}
								count = count + 1;
							}
							if(count2 != (-1) )
							{
								boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,player);
								if(boolResult == TRUE)	// build a vtol defense near the attacked struct...
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
									boolResult2 = TRUE;
								}
							}
							
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}	
		}
	}
}


event vtolEnabler(vtolEnablerTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolEnabler,inactive);			
	}
	else
	{
		if( skVtolEnableCheck(player) )					// check to see if we have vtol technologies.
		{
			setEventTrigger(vtolEnabler,inactive);		// turn off this event.
			setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol functions..		
			setEventTrigger(buildVtols,	buildVtolsTr);			
			setEventTrigger(vtolAttack,	vtolAttackTr);	
		}
	}	
}

