//////////////////////////////////////
// BecomePrey AI version 2.92 - 1.10
//////////////////////////////////////
// Elite Force, 2008
// by NIKER
// NIKER@seznam.cz
// http://wef.warzone2100.de

// This AI is optimized for WZ 1.10 version
// If you want to use whole BecomePrey AI or it's part, contact player.
// Module design of BecomePrey2 allows mod creators to simple customize it for any mod.
// I will most likely allow any experiments with this AI.
// NOTE: This AI was created using my VSC2 program!
///////////////////////////////////////
// THIS FILE STORES MAIN ARTIFICIAL INTELLIGENCE SCRIPT


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+ DO NOT EDIT THIS FILE IF YOU DON'T UNDERSTAND SCRIPTING LANGUAGE *+*+*
//+*+ BAD MODIFICATIONS TO BecomePrey AI SCRIPT MAY CAUSE GAME TO CRASH *+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ VARIABLES AND CONSTANTS *+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
public INT player;                                                      // player for this instance.
public BOOL LIFE,useTanks,useCyborgs,useVtols,useNEXUS,useReincarnation;        // feature switch
public INT tileExpand,numMaxDerricks;                                                   // rate of exploration
public BOOL usePower;                                                   //should WZ use power?

// structures
public INT baseX,baseY,minx,miny,maxx,maxy,defSpotX,defSpotY;
public INT numStructs,numAA,numIncendrys,numTStructs[3], currentT,numWallWeaps,numGroundTargets,numRushTargets,numTmpls, numSuperCyb, numVtols,numBBs,numSense,numInitialTargets, numGenAA, numVtolTargets, numCyborgGroundTargets;
public STRUCTURESTAT incendrys[8],structs[51],defStructs[3][25],structChoice[30],wallWeaps[16],vtolDefStruct[10],sense[4],TEdge[3],initialTargets[7],vtolGenStruct[10], vtolTargets[20];
public STRUCTURESTAT sensorTower,wallStruct,resLab,powGen,playerHQ,lassat,factory,derrick,cybFactory,vtolPad,vtolFactory,repairFacility, uplinkCenter,CBSense;
public STRUCTURESTAT powModule,facModule,resModule,vtolModule,demAnomallyFix;

public INT highPowerGroup;
public INT numOilStrGroups;
public INT numOilStructs[7],structsLimits[5];
public STRUCTURESTAT oilStructs[7][10];


public STRUCTURESTAT pickStrQueue[15];                  //should be maximum struct + 1
public INT pickStrQueueDepth;
public STRUCTURESTAT pickDefQueue[60];                  //should be maximum struct + 1
public INT pickDefQueueDepth;

private STRUCTURESTAT pickStructureQueue[80];
private INT pickStructureQueueDepth;

private INT extraStruct;
public BOOL AIControl;
// unit templates
public TEMPLATE tmpl0[28];
public TEMPLATE tmpl1[5];
public TEMPLATE superCyb[20];
public TEMPLATE vtols[18];
public TEMPLATE constructor,VTOLconstr,cybcondroid;
public BODY engBody;

// special - template recognizer
public PROPULSION cyborgPropulsion;
public PROPULSION hoverProp;

// special
public RESEARCHSTAT nexusDefence;
public RESEARCHSTAT powerAddOn,cybMg;
public BOOL IamBOT;
public INT WhosMyLord;
public BOOL RTBTriggerT;
public BOOL RTBTriggerC;
public INT artyCount, defendDelay,defendDelayHP;
public FEATURESTAT artefact;
public BOOL doResortUnits ;

//build
private INT buildX,buildY,buildX2,buildY2;
public FEATURESTAT oilRes;

public STRUCTURESTAT tempStructurestat;

// GROUPS
public INT numHarvesters;
public GROUP vtolGroup,vtolUnitGroup, tankGroup, buildGroup,harvesterGroup, cyborgGroup,nexusGroup,senseGroup;
private GROUP xGroup;

// generic
private STRUCTURE structure,structure2;
public STRUCTURE structure3;
private DROID droid,droid2;
private FEATURE feature,feature2;
private BASEOBJ baseobj,baseobj2;
private INT count,count2,count3,count4,count5,result,result2,tempx,tempy,botcount,botcount2,botcount3,builddroid;
private INT rectFixX,rectFixY,rectFixX1,rectFixX2,rectFixY1,rectFixY2,rectFixRange,rectValidX, rectValidY, rectValid;
private BOOL boolResult,boolResult2,boolResult3,boolResult4;
public INT buildBBCheck;

////DBM SCRIPT
public INT lastBaseMove;

////skLocateEnemy alternative script
public INT lastGroundAttack;


//  ADVANCED ATTACKING SCRIPT MK-6:
//  HEAVY ASSAULT SCRIPT
//tanks
public BOOL tankActive, tankSubInitBool1,tankSubInitBool2,tankAntiUnit1,tankPosBool1,tankOverrunBool1,tankMigrationBool1;
public INT tankMigrationX, tankMigrationY;
public BASEOBJ tankTarget;
public INT tankUnitAttacked;
/*public	INT	tankStance,cyborgStance;*/
//cyborgs
public BOOL cyborgActive,cyborgSubInitBool1, cyborgSubInitBool2, cyborgAntiUnit1,cyborgPosBool1, cyborgOverrunBool1,cyborgMigrationBool1;
public INT cyborgMigrationX, cyborgMigrationY;
public BASEOBJ cyborgTarget;
public INT cyborgUnitAttacked;
//shared
private INT plNum[8];
private INT plCount,minDistance;
public INT targetPl;
public INT lastCybMove,lastTankMove,lastVtolMove;
public INT lastBaseAttacked;

//  ADVANCED VTOL ATTACKING SCRIPT MK-V:
//  SUPREME ASSAULT SCRIPT
//vtols
public BOOL vtolActive, vtolSubInitBool1,vtolSubInitBool2,vtolSubInitBool3,vtolPosBool1,vtolOverrunBool1,vtolMigrationBool1;
public INT vtolMigrationX, vtolMigrationY;
public BASEOBJ vtolTarget;
public INT vtolUnitAttacked;


// NEW - GLOBAL TARGET SELECTOR //
private INT mapSizeDetector;     //detects debug trigger accordingly to map size
public STRUCTURESTAT structureTargets[98],rushTargets[11];
private INT failedTimes;





public DROID seenUnitArray[10];
public INT targetExpire[10];
public WEAPON BBs;



//New TOTAL CONTROL SCRIPT - Vtol Unit attacks
public INT TCSVtolUnitArray;
public BOOL DoVtolDebug;

// NEW laser satellite
public BOOL LasSatCharged;
public BOOL AlreadyHasSat;
public BASEOBJ lassatTarget;
private STRUCTURE destroyedStruct;
private INT buildingSelector;
public BOOL targetSelected;


// pseudo-NEXUS scripts
public WEAPON NEXUS_WEAPON1;
public WEAPON NEXUS_WEAPON2;
public INT lastNEXUSArray;
public INT NEXUSActivatedTimes;
public INT LastNexusX;
public INT LastNexusY;
public INT linkRange;

//Shielding systems (2:45 hours after game begins) (KICK)
public RESEARCHSTAT SHIELDS;

// Helping script
public BOOL attacksOnHold;


public INT lastTE;                              //avoid baseXY so change too often
public INT lastAA;                              //avoid building too much 'realtime protection' AA defences
public INT lastPowergen;                        //avoid powerGens to be build too often on high-oil maps
public INT recentOilEvents;                             //special value to indicate building of extra oil defenses

////    AA PROTECTION
public INT AAPx;
public INT AAPy;
public INT AAPtime;



// +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*

//// WEATHER SETTINGS VARIABLES
public INT curR;
public INT curG;
public INT curB;
public INT targetR;
public INT targetG;
public INT targetB;
public INT weatherSelected;
public BOOL stormyWeather;

/////////////////////////////////////////////

//// DEBUG-MODE
public BOOL EnableDebug;
public INT CheatLevel;
public INT AutoBaseCheat;
public STRUCTURESTAT stdDefOilGr;
public STRUCTURESTAT stdDefOilAA;
public STRUCTURESTAT stdBaseFortress;

private INT facLimit;

//// T1 cyborgs problem
public RESEARCHSTAT CyborgHotfixR;
public RESEARCHSTAT CyborgLegs;

private INT oilX,oilY;

//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ TRIGGERS *+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
trigger buildBaseArtyTr (every,172);
trigger fortifyTr                   (every,350);
trigger buildBaseTr             (every,27);
trigger buildBaseQueueTr             (every,105);
trigger defendBaseTr                   (every,32);
trigger defendBaseLPTr                   (every,300);
trigger defendBaseQueueTr          (every,267);
trigger defendSpotChangeTr              (every,1000);
trigger upgradeStructuresTr         (every,2);
trigger initOverrideMostEssentialTr         (every,2);
trigger initOverrideMinorTr         (every,5);
trigger scoutMainTr                 (every,82);
trigger managePowerTr               (every,10);
trigger basedetailsTr           (every,900);
trigger buildDerrickTr  (every,18);
trigger extraOilDefensesTr      (every,56);
trigger incendryTr              (every,26);
trigger incendryRetryTr (every,18);
trigger incendryStopTr              (every,150);
trigger buildPowerGeneratorsTr      (every,4);
trigger cyborgBuildEventTr      (every,8);
trigger tankBuildEventTr      (every,9);
trigger finishStructsTr             (every,300);
trigger droidBuiltTr                            (CALL_NEWDROID,player, ref droid,ref structure);
//trigger newObjectReportTr			(CALL_OBJ_SEEN, player, ref baseobj, ref baseobj2);
trigger newDroidReportTr                        (CALL_DROID_SEEN, player, ref droid, ref baseobj);
trigger doResearchTr                (every,10);
trigger doResearchLPTr                (every,1450);
trigger reassignTr                                      (CALL_PLAYERLEFT,ref count);
trigger vtolDefendTr                            (CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj);
trigger vtolStructsTr               (every,125);
trigger takeoverTr                              (CALL_UNITTAKEOVER, ref droid);
trigger EtakeoverTr                             (CALL_ELECTRONIC_TAKEOVER);
trigger lassatRechargetr                (every,3000);   // Equals to Laser Satellite reload time
trigger lassatEventTr           (every,50);     // Laser Satellite minimal delay
trigger NEXUSTeamGoTr   (every,40);
trigger VtolsTeamGoTr   (every,20);
trigger NEXUSCheckTr    (every,30);
trigger NEXUSStopAndEngage               (CALL_DROID_ATTACKED, player, ref droid, ref baseobj);
trigger buildSenseTr            (every,481);

//trigger stanceSwitchTr	(every,3600);

trigger tankAttackTr1 (wait,0); //attack
trigger tankAttackTr2 (every,810); //invasion/check
trigger tankAttackTr3 (every,180); //invade for (max)
trigger tankAttackTr4 (every,8); //init
trigger tankAttackTr5 (every,6); //RTB
trigger tankDebug64Tr  (wait,1800);
trigger tankDebug96Tr  (wait,3200);
trigger tankDebug128Tr  (wait,5400);

trigger cyborgAttackTr1 (wait,0); //attack
trigger cyborgAttackTr2 (every,610); //invasion/check
trigger cyborgAttackTr3 (every,150); //invade for (max)
trigger cyborgAttackTr4 (every,8); //init
trigger cyborgAttackTr5 (every,6); //RTB
trigger cyborgDebug64Tr  (wait,1200);
trigger cyborgDebug96Tr  (wait,2400);
trigger cyborgDebug128Tr  (wait,4800);

trigger vtolAttackTr1 (wait,0); //attack
trigger vtolAttackTr2 (wait,929); //re-enabler
trigger vtolAttackTr3 (every,5); //invade for (max)
trigger vtolAttackTr4 (every,10); //init
trigger vtolAttackTr5 (every,4); //RTB
trigger vtolDebug96Tr   (wait,1800);
trigger vtolDebug128Tr  (wait,2600);


trigger designDownTr (CALL_DROIDDESIGNED);

trigger changeWeatherTargetTr (every,1181);

trigger sendHelpNowTr(CALL_ALLIANCEOFFER, ref count, ref count2);
trigger restoreAttacksTr (wait,3600);
trigger TankTCSTr (CALL_DROID_ATTACKED,player, ref droid, ref baseobj);

trigger EmergencyRTBTr(wait,10);
trigger CheatsTr(every,600);

trigger tankInitTr              (every,150);
trigger tankMoveTr              (every,30);
trigger executeScriptTr (wait,0);
trigger emulateZeroWaitTr       (every,4);
trigger tankOverrunWaitTr       (every,75);
trigger cyborgInitTr            (every,250);
trigger cyborgMoveTr    (every,35);
trigger cyborgOverrunWaitTr     (every,100);
trigger blessTr (every,5);
trigger vtolInitTr              (every,300);
trigger vtolMoveTr              (every,30);
trigger buildHQTopPriority      (every,1);
trigger planExecuteTr   (wait, 300);



//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ MAIN SCRIPT *+*+*+*+*+*+*++*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*


// HouseKeeping

event initialisedEvent(CALL_GAMEINIT)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(initialisedEvent,inactive);
	}
	else
	{
//// PRE-COMPILED SCRIPT - RESTART ALL PUBLIC VARIABLES
		AAPtime = 0 ; AAPy = 0 ; AAPx = 0 ; recentOilEvents = 0 ; lastPowergen = 0 ; lastAA = 0 ; lastTE = 0 ; attacksOnHold = FALSE ; LastNexusY = 0 ; LastNexusX = 0 ; NEXUSActivatedTimes = 0 ; lastNEXUSArray = 0 ; targetSelected = FALSE ; lassatTarget = NULLOBJECT ; AlreadyHasSat = FALSE ; LasSatCharged = FALSE ; DoVtolDebug = FALSE ; TCSVtolUnitArray = 0 ; targetExpire[0] = 0 ; targetExpire[1] = 0 ; targetExpire[2] = 0 ; targetExpire[3] = 0 ; targetExpire[4] = 0 ; targetExpire[5] = 0 ; targetExpire[6] = 0 ; targetExpire[7] = 0 ; targetExpire[8] = 0 ; targetExpire[9] = 0 ; seenUnitArray[0] = NULLOBJECT ; seenUnitArray[1] = NULLOBJECT ; seenUnitArray[2] = NULLOBJECT ; seenUnitArray[3] = NULLOBJECT ; seenUnitArray[4] = NULLOBJECT ; seenUnitArray[5] = NULLOBJECT ; seenUnitArray[6] = NULLOBJECT ; seenUnitArray[7] = NULLOBJECT ; seenUnitArray[8] = NULLOBJECT ; seenUnitArray[9] = NULLOBJECT ; vtolUnitAttacked = 0 ; vtolTarget = NULLOBJECT ; vtolMigrationY = 0 ; vtolMigrationX = 0 ; vtolMigrationBool1 = FALSE ; vtolOverrunBool1 = FALSE ; vtolPosBool1 = FALSE ; vtolSubInitBool3 = FALSE ; vtolSubInitBool2 = FALSE ; vtolSubInitBool1 = FALSE ; vtolActive = FALSE ; lastBaseAttacked = 0 ; lastVtolMove = 0 ; lastTankMove = 0 ; lastCybMove = 0 ; targetPl = 0 ; cyborgUnitAttacked = 0 ; cyborgTarget = NULLOBJECT ; cyborgMigrationY = 0 ; cyborgMigrationX = 0 ; cyborgMigrationBool1 = FALSE ; cyborgOverrunBool1 = FALSE ; cyborgPosBool1 = FALSE ; cyborgAntiUnit1 = FALSE ; cyborgSubInitBool2 = FALSE ; cyborgSubInitBool1 = FALSE ; cyborgActive = FALSE ; tankUnitAttacked = 0 ; tankTarget = NULLOBJECT ; tankMigrationY = 0 ; tankMigrationX = 0 ; tankMigrationBool1 = FALSE ; tankOverrunBool1 = FALSE ; tankPosBool1 = FALSE ; tankAntiUnit1 = FALSE ; tankSubInitBool2 = FALSE ; tankSubInitBool1 = FALSE ; tankActive = FALSE ; lastGroundAttack = 0 ; lastBaseMove = 0 ; buildBBCheck = 0 ; WhosMyLord = 0 ; IamBOT = FALSE ; RTBTriggerC = FALSE ; RTBTriggerT = FALSE ; defSpotY = 0 ; defSpotX = 0 ; maxy = 0 ; maxx = 0 ; miny = 0 ; minx = 0 ; baseY = 0 ; baseX = 0 ;
//// PRE-COMPILED SCRIPT END



		resetDroidTargets();
		setDroidTarPref(8192);
		setDroidTarPref(4096);
		setDroidTarPref(65536);
		setDroidTarPref(2048);
		setDroidTarPref(16384);
		setDroidTarPref(30720);
		setDroidTarPref(32768);

		targetPl = -1;
		numMaxDerricks = 40; //max number of derricks per player
		AAPx = -1;
		numHarvesters = 2;
		TCSVtolUnitArray = -1;
		WhosMyLord = -1;
		lastNEXUSArray = -1;
		randomiseSeed();
		groupAddArea(buildGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
		if(buildGroup.members > 2)
		{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			if(droid != NULLOBJECT)
			{
				groupAddDroid(harvesterGroup, droid );
			}
		}



		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		if(droid != NULLOBJECT)
		{
			baseX = droid.x;
			baseY = droid.y;
		}
		else
		{
			baseX = (128*mapWidth)/2;
			baseY = (128*mapHeight)/2;
		}

		count2 = 0;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if((count2 > 2) and (count2 < 5))
			{
				groupAddDroid(harvesterGroup, droid);
			}
			count2 = count2 + 1;
			droid = iterateGroup(buildGroup);
		}



		initAllNoGoAreas();
	}


	//for all players, avoid attacking themselves (AIControl bug)
	createAlliance(player,player);

	if(usePower == FALSE)
	{
		turnPowerOff();
	}

//INIT DYWERA
	WhosMyLord = -1;
	curR = 1;
	curG = 1;
	curB = 1;
	setFogColour(curR,curG,curB);

	if(player == 0)
	{
		count = random(3);
		count2 = random(2);
		stormyWeather = FALSE;
		//WEATHER
		if(count == 0) //RAIN
		{
			weatherSelected = 0;
		}

		if(count == 1) //SNOW
		{
			weatherSelected = 1;
		}

		if(count == 2) //SUN
		{
			weatherSelected = 2;
		}

		//DAYTIME
		if((count == 2) and (count2 == 0)) //SUN + DAY
		{
			targetR = 229;
			targetG = 197;
			targetB = 21;
		}

		if((count == 1) and (count2 == 0)) //SNOW + DAY
		{
			targetR = 166;
			targetG = 207;
			targetB = 220;
		}

		if((count == 0) and (count2 == 0)) //RAIN + DAY
		{

			targetR = 65;
			targetG = 119;
			targetB = 147;
			stormyWeather = TRUE;
		}

		if((count == 2) and (count2 == 1)) //SUN + NIGHT :o)
		{
			targetR = 1;
			targetG = 20;
			targetB = 94;
		}

		if((count == 1) and (count2 == 1)) //SNOW + NIGHT
		{
			targetR = 62;
			targetG = 71;
			targetB = 106;
		}

		if((count == 0) and (count2 == 1)) //RAIN + NIGHT
		{
			targetR = 48;
			targetG = 19;
			targetB = 81;
			stormyWeather = TRUE;
		}

	}

	//HACKS
	if((isHumanPlayer(player) == FALSE) or (AIControl == TRUE))
	{
		setStructureLimits(demAnomallyFix, 0, player);
		makeComponentAvailable(NEXUS_WEAPON1, player);
		makeComponentAvailable(NEXUS_WEAPON2, player);
	}

	enableResearch(CyborgLegs, player);
	completeResearch(CyborgLegs, player);

	//switch T level
	if(currentT == 0)
	{
		if(isStructureAvailable(TEdge[0],player))
		{
			currentT = 1;
		}
	}
	if(currentT == 1)
	{
		if(isStructureAvailable(TEdge[1],player))
		{
			currentT = 2;
		}
	}

	//build queue
	count = 0;
	pickDefQueueDepth = 0;
	while(count < numTStructs[currentT])
	{
		if(isStructureAvailable(defStructs[currentT][count],player))
		{
			pickDefQueue[pickDefQueueDepth] = defStructs[currentT][count];
			pickDefQueueDepth = pickDefQueueDepth + 1;
		}
		count = count + 1;
	}
	count = 0;
	pickStrQueueDepth = 0;
	while(count < numStructs)
	{
		if(isStructureAvailable(structs[count],player))
		{
			pickStrQueue[pickStrQueueDepth] = structs[count];
			pickStrQueueDepth = pickStrQueueDepth + 1;
		}
		count = count + 1;
	}
	LIFE = TRUE;
	doResortUnits = TRUE;
}

event AutoBases(inactive)
{
	if((isHumanPlayer(player) == FALSE) and (IamBOT == FALSE) and (AutoBaseCheat > 0) and (numObjectsInArea(player, 0,0,mapWidth*128,mapHeight*128) > 0 ))
	{
		//STEAL OIL RESOURCE
		count = 0;
		initGetFeature(oilRes, player,player);
		feature = getFeature(player);
		while(feature != NULLOBJECT)
		{
			count3 = 0;
			if(distBetweenTwoPoints(feature.x, feature.y, baseX, baseY) < (((mapWidth+mapHeight) * 64) / 2))
			{
				rectFixX = feature.x;
				rectFixY =  feature.y;
				rectFixRange = 128;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
				count2 = 0;
				while(count2 < 8)
				{
					if((numObjectsInArea(player, rectFixX1,rectFixY1,rectFixX2,rectFixY2) > 0) and (player != count2) and (allianceExistsBetween(player,count2) == FALSE) and (rectValid == 1))
					{
						count3 = count3 + 1;
					}
					count2 = count2 + 1;
				}
				if(count3 == 0)
				{
					addStructure( derrick, player, feature.x, feature.y);
					count = count + 1;
					//level 2 enables auto-defences
					if(AutoBaseCheat > 1)
					{
						//ground tower
						buildX = feature.x;
						buildY = feature.y;
						pickStructLocation(stdDefOilGr,ref buildX, ref buildY, player);
						addStructure( stdDefOilGr, player, buildX, buildY );
						//AA site
						buildX = feature.x;
						buildY = feature.y;
						pickStructLocation(stdDefOilAA,ref buildX, ref buildY, player);
						addStructure( stdDefOilAA, player, buildX, buildY );
					}
				}
			}
			feature = getFeature(player);
		}

		//BUILD POWERGENS
		count = (count / 4) + 1;
		while(count > 0)
		{
			buildX = baseX;
			buildY = baseY;
			pickStructLocation(powGen,ref buildX, ref buildY, player);
			addStructure( powGen, player, buildX, buildY );
			count = count - 1;
		}

		//BUILD FACTORIES
		count = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.0 " & player, player);
		initEnumStruct(FALSE,factory,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			count = count + 1;
			structure = enumStruct();
		}
		count = 5 - count;
		while(count > 0)
		{
			buildX = baseX;
			buildY = baseY;
			pickStructLocation(factory,ref buildX, ref buildY, player);
			addStructure(factory, player, buildX, buildY );
			count = count - 1;
		}

		//BUILD CYBORG FACTORIES
		count = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.1 " & player, player);
		initEnumStruct(FALSE,cybFactory,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			count = count + 1;
			structure = enumStruct();
		}
		count = 3 - count;
		while(count > 0)
		{
			buildX = baseX;
			buildY = baseY;
			pickStructLocation(cybFactory,ref buildX, ref buildY, player);
			addStructure(cybFactory, player, buildX, buildY );
			count = count - 1;
		}

		if(AutoBaseCheat > 1)
		{
			count = 8       ;
			while(count > 0)
			{
				buildX = baseX;
				buildY = baseY;
				pickStructLocation(stdBaseFortress,ref buildX, ref buildY, player);
				addStructure(stdBaseFortress, player, buildX, buildY );
				count = count - 1;
			}
		}
	}
	setEventTrigger(AutoBases,inactive);
}

event ForceBuildHQ (every,1)
{
	if((isHumanPlayer(player) == FALSE) or (AIControl == TRUE))
	{
		structure = getStructure(playerHQ, player);
		if(structure == NULLOBJECT)
		{
			buildX = baseX;
			buildY = baseY;
			boolResult = pickStructLocation(factory, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{

				//BUILD HQ AT THE FIRST PLACE!!!
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order != DORDER_BUILD)
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,playerHQ, buildX,buildY );
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
		else
		{
			setEventTrigger(ForceBuildHQ,inactive);
		}
	}
}




event DEBUG_MODE_ENABLER(buildBaseTr)
{
	if(EnableDebug == TRUE)
	{
		if(isHumanPlayer(player))
		{
			traceOn();
			structure = getStructure(uplinkCenter, player);
			if(structure == NULLOBJECT)
			{
				structure2= getStructure(playerHQ,player);
				if(structure2 != NULLOBJECT)
				{
					if(anyFactoriesLeft(player) == FALSE)
					{
						addStructure( factory, player, structure2.x + 256, structure2.y + 256 );
					}
					addStructure( uplinkCenter, player, structure2.x, structure2.y );

				}
			}
			addPower(500,player);
		}
	}
	else
	{
		setEventTrigger(DEBUG_MODE_ENABLER,inactive);
	}
}





//////// BOT SETTINGS //////////////////////////////////
event BOTSettings(buildDerrickTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(BOTSettings,    inactive);
	}
	else
	{
		IamBOT = FALSE;
		WhosMyLord = -1;
		count2 = 0;
		while((count2 < 8) and (WhosMyLord == -1))
		{
			if(isHumanPlayer(count2) == TRUE)
			{
				if((allianceExistsBetween (player,count2) == TRUE) or (allianceExistsBetween (count2,player) == TRUE))
				{
					IamBOT = TRUE;
					WhosMyLord = count2;
				}
			}
			count2 = count2 + 1;
		}
		count = 0;
		while(count < 8)
		{
			if(count != player)
			{
				if(IamBOT == FALSE)
				{
					if(isHumanPlayer(count) == FALSE)
					{
						boolResult = FALSE;
						count3 = 0;
						while(count3 < 8)
						{
							botcount = 0;
							while(botcount < 8)
							{
								if((allianceExistsBetween(botcount,count3) == TRUE) and (isHumanPlayer(botcount) == TRUE))
								{
									boolResult = TRUE;
								}
								botcount = botcount + 1;
							}
							count3 = count3 + 1;
						}

						if(boolResult == FALSE)
						{
							createAlliance(player,count);
						}

					}
				}
				//else
				//{
				//	count3 = 0;
				//	while(count3 < 8)
				//	{
				//		if(isHumanPlayer(count3) == FALSE)
				//		{
				//			addPower(999999,count3);    // make BOTs stronger than you ;)
				//		}
				//count3 = count3 + 1;
				//	}
				//}
			}
			//yeah I know, this is a cheat for human, but I'm not that kind :-D
			//disabled since 2.41
			count = count + 1;
		}
		setEventTrigger(BOTSettings,    inactive);

////////////////////////////////////////////////
////// COLORS ////////////////////////////////
////////////////////////////////////////////////
	}
	setBackgroundFog(TRUE);
	setDepthFog(TRUE);
}

event ReAllyBOTs (buildBaseTr)
{
	if((IamBOT == TRUE) and (allianceExistsBetween(player,WhosMyLord) == FALSE))
	{
		createAlliance(player,WhosMyLord);
	}
}






//// WEATHER SETTINGS  (DYWERA)
event weatherSetUp (changeWeatherTargetTr)
{
	if(player == 0)
	{
		count = random(3);
		count2 = random(2);

		stormyWeather = FALSE;
		//WEATHER
		if(count == 0) //RAIN
		{
			weatherSelected = 0;
		}

		if(count == 1) //SNOW
		{
			weatherSelected = 1;
		}

		if(count == 2) //SUN
		{
			weatherSelected = 2;
		}

		//DAYTIME
		if((count == 2) and (count2 == 0)) //SUN + DAY
		{
			targetR = 229;
			targetG = 197;
			targetB = 21;
		}

		if((count == 1) and (count2 == 0)) //SNOW + DAY
		{
			targetR = 166;
			targetG = 207;
			targetB = 220;
		}

		if((count == 0) and (count2 == 0)) //RAIN + DAY
		{
			targetR = 65;
			targetG = 119;
			targetB = 147;
			if(random(2) == 0) { stormyWeather = TRUE; }
		}

		if((count == 2) and (count2 == 1)) //SUN + NIGHT :o)
		{
			targetR = 1;
			targetG = 20;
			targetB = 94;
		}

		if((count == 1) and (count2 == 1)) //SNOW + NIGHT
		{
			targetR = 62;
			targetG = 71;
			targetB = 106;
		}

		if((count == 0) and (count2 == 1)) //RAIN + NIGHT
		{
			targetR = 48;
			targetG = 19;
			targetB = 81;
			if(random(2) == 0) { stormyWeather = TRUE; }
		}

	}
}
event changeFogColor(upgradeStructuresTr)
{
	if(player == 0)
	{
		if((targetR != curR) or (targetG != curG) or (targetB != curB))
		{
			if(curR != targetR)
			{


				if(curR < targetR)
				{
					curR = curR + 1;
				}
				else
				{
					curR = curR - 1;
				}
			}

			if(curG != targetG)
			{
				if(curG < targetG)
				{
					curG = curG + 1;
				}
				else
				{
					curG = curG - 1;
				}
			}

			if(curB != targetB)
			{
				if(curB < targetB)
				{
					curB = curB + 1;
				}
				else
				{
					curB = curB - 1;
				}
			}
		}
		else
		{
			if(weatherSelected == 0)        {       setRain(TRUE);  }
			if(weatherSelected == 1)        {       setSnow(TRUE);  }
			if(weatherSelected == 2)
			{
				setRain(FALSE);
				setSnow(FALSE);
			}

		}
		if((random(50) == 13) and (stormyWeather == TRUE))
		{
			setFogColour(60,196,252);
		}
		else
		{
			setFogColour(curR,curG,curB);
		}
	}
}

///////  DBM (DYNAMIC BASE MANAGEMENT SCRIPT)
event DBM_MoveBase(fortifyTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(DBM_MoveBase,inactive);
	}
	else
	{
		boolResult = FALSE;
		count = 0;
		count2 = 0;

		structure2 = getStructure(lassat, player);              // if LasSat is available, move the center of base to it's destination
		if(structure2 != NULLOBJECT)
		{
			baseX = structure2.x;
			baseY = structure2.y;
			boolResult = TRUE;
		}


		structure = getStructure(playerHQ, player);     // move base to alternative location centered on HQ
		if(structure != NULLOBJECT)
		{
			baseX = structure.x;
			baseY = structure.y;
			boolResult = TRUE;
		}

		boolResult2 = FALSE;
		// select random alternative location (move base a little)
		if( (boolResult == FALSE) and ((gameTime - lastBaseMove) > 1200) )
		{
			boolResult2 = TRUE;
		}

		if( (gameTime - lastBaseMove) > 66000 )
		{
			boolResult2 = TRUE;
		}

		if(boolResult2 == TRUE)
		{
			if(structure != NULLOBJECT)
			{
				destroyStructure(structure);    //Destroy old HQ if it's timed movement
			}

			failedTimes = 0;
			while(((count < 512 ) or (count > 128*mapWidth) or (count2 < 512 ) or (count2 > 128*mapHeight)) and (failedTimes < 64))
			{
				failedTimes = failedTimes + 1;
				if(random(2) == 0)
				{
					count = baseX + random(64)*128 ;
				}
				else
				{
					count = baseX - random(64)*128 ;
				}

				if(random(2) == 0)
				{
					count2 = baseY + random(64)*128 ;
				}
				else
				{
					count2 = baseY - random(64)*128 ;
				}
			}

			if((count != 0) and (count2 != 0) and (count != baseX) and (count2 != baseY))
			{
				if((count > 512 ) and (count < 128*mapWidth) and (count2 > 512 ) and (count2 < 128*mapHeight))
				{
					boolResult = FALSE;
					count4 = 0;
					while(count4 < 8)
					{
						if(allianceExistsBetween(player,count4) == FALSE)
						{
							if(numStructsInArea(count4,count - 1600,count2 - 1600, count + 1600,count2 + 1600) > 1)
							{
								boolResult = TRUE;
							}
						}
						count4 = count4 + 1;
					}

					if(boolResult == FALSE)
					{
						baseX  = count;
						baseY  = count2;
						lastBaseMove = gameTime;
					}

				}

				//// build HQ at new location
				boolResult = FALSE;
				count2 = 0;
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.2 " & player, player);
				initEnumStruct(FALSE,playerHQ,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					count2 = count2 + 1;
					structure= enumStruct();
				}
				if(count2==0)
				{
					buildX = baseX;
					buildY = baseY;
					boolResult = pickStructLocation(playerHQ, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						initIterateGroup(buildGroup);                   // find idle droids in build group.
						droid = iterateGroup(buildGroup);
						if((droid != NULLOBJECT) and (buildGroup.members + senseGroup.members > 2))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,playerHQ, buildX,buildY);
						}
					}
				}
				//// HQ built
				orderGroupLoc(tankGroup, DORDER_MOVE, baseX,baseY);
				orderGroupLoc(cyborgGroup, DORDER_MOVE, baseX,baseY);
			}


		}



	}
}


// KEEP details about the size and postion of the ai players base
event basedetails(basedetailsTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(basedetails,    inactive);
	}
	else
	{
		// clear old extremities.
		maxy = 0;
		maxx = 0;
		miny = (mapHeight*128);         minx = (mapWidth*128);

		// now find the extremities of our vital structures.
		count = 0;
		while(count < numStructs)
		{
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.3 " & player, player);
			initEnumStruct(FALSE,structs[count],player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				if(structure.x < minx)
				{
					minx = structure.x;
				}
				if(structure.x > maxx)
				{
					maxx = structure.x;
				}
				if(structure.y < miny)
				{
					miny = structure.y;
				}
				if(structure.y > maxy)
				{
					maxy = structure.y;
				}
				structure= enumStruct();
			}

			count = count + 1;
		}
	}
}



// structure building rules

//NEW INITIAL CYBORG FACTORY OVERRIDE
event buildCybFactoryFirst(initOverrideMinorTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildCybFactoryFirst,   inactive);
	}
	else
	{
		if(useCyborgs)
		{
//init
			count4 = 0;
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.4 " & player, player);
			initEnumStruct(FALSE,cybFactory,player,player);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				count4 = count4 + 1;
				structure = enumStruct();
			}


// FORCE AI TO BUILD 2 CYBORG FACTORIES
			if(count4 < 2)
			{
				boolResult = FALSE;
				if(buildGroup.members + senseGroup.members > 1)
				{
					buildX = baseX;
					buildY = baseY;
					if( isStructureAvailable(cybFactory, player) == TRUE)
					{
						boolResult = pickStructLocation(cybFactory, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							initIterateGroup(buildGroup);
							droid = iterateGroup(buildGroup);
							builddroid = 0;
							while((droid != NULLOBJECT) and (builddroid < 1))
							{
								if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,cybFactory, buildX,buildY);
									builddroid = builddroid + 1;
								}
								droid = iterateGroup(buildGroup);
							}
						}
					}
				}
			}
		}
	}
}


//NEW INITIAL REPAIR CENTER OVERRIDE
event buildRepFirst(initOverrideMinorTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildRepFirst,  inactive);
	}
	else
	{

//init
		count4 = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.5 " & player, player);
		initEnumStruct(FALSE,repairFacility,player,player);
		structure = enumStruct(); while(structure != NULLOBJECT)
		{
			count4 = count4 + 1;
			structure = enumStruct();
		}

// FORCE AI TO BUILD 1 REPAIR CENTER CENTRE
		if(count4 == 0)
		{
			boolResult = FALSE;
			if(buildGroup.members + senseGroup.members > 1)
			{
				buildX = baseX;
				buildY = baseY;
				boolResult = pickStructLocation(repairFacility, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					builddroid = 0;
					while((droid != NULLOBJECT) and (builddroid < 1))
					{
						if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,repairFacility, buildX,buildY);
							builddroid = builddroid  + 1;
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
}

//NEW INITIAL FACTORY OVERRIDE
event buildFactoryFirst(initOverrideMostEssentialTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildFactoryFirst,      inactive);
	}
	else
	{
		if(useTanks)
		{
			if(isStructureAvailable(factory,player))
			{
//init
				count4 = 0;
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.6 " & player, player);
				initEnumStruct(FALSE,factory,player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					count4 = count4 + 1;
					structure = enumStruct();
				}

// FORCE AI TO BUILD 3 FACTORIES
				if(count4 < 3)
				{
					boolResult = FALSE;
					if(buildGroup.members + senseGroup.members > 1)
					{
						buildX = baseX;
						buildY = baseY;
						boolResult = pickStructLocation(factory, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							initIterateGroup(buildGroup);
							droid = iterateGroup(buildGroup);
							builddroid  = 0;
							while((droid != NULLOBJECT) and (builddroid < 1))
							{
								if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,factory, buildX,buildY);
									builddroid  = builddroid  + 1;
								}
								droid = iterateGroup(buildGroup);
							}
						}
					}
				}
			}
		}
	}
}


//NEW INITIAL RESEARCH OVERRIDE
event buildResFirst(initOverrideMinorTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildResFirst,  inactive);
	}
	else
	{
//init
		count4 = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.7 " & player, player);
		initEnumStruct(FALSE,resLab,player,player);
		structure = enumStruct(); while(structure != NULLOBJECT)
		{
			count4 = count4 + 1;
			structure = enumStruct();
		}

// FORCE AI TO BUILD 1 RESEARCH CENTRE
		if(count4 == 0)
		{
			boolResult = FALSE;
			if(buildGroup.members + senseGroup.members > 1)
			{
				buildX = baseX;
				buildY = baseY;
				boolResult = pickStructLocation(resLab, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					builddroid = 0;
					while((droid != NULLOBJECT) and (builddroid < 1))
					{
						if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,resLab, buildX,buildY);
							builddroid = builddroid  + 1;
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
}





//NEW INITIAL POWER GENERATOR OVERRIDE
event buildPowFirst(initOverrideMostEssentialTr  )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildPowFirst,  inactive);
	}
	else
	{
//init
		count4 = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.8 " & player, player);
		initEnumStruct(FALSE,powGen,player,player);
		structure = enumStruct(); while(structure != NULLOBJECT)
		{
			count4 = count4 + 1;
			structure = enumStruct();
		}

// FORCE AI TO BUILD 2 POWER GENS
		if(count4 < 2)
		{
			boolResult = FALSE;
			if(buildGroup.members + senseGroup.members > 1)
			{
				buildX = baseX;
				buildY = baseY;
				boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					builddroid = 0;
					while((droid != NULLOBJECT) and (builddroid < 1))
					{
						if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
							builddroid = builddroid  + 1;
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
}




//ADVANCED HARVESTER SCRIPT
////////////////////////////////////
event harvesterOperate(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(harvesterOperate,       inactive);
	}
	else
	{
		tempx=-1;
		tempy=-1;
		recentOilEvents = 0;
		initIterateGroup(harvesterGroup);
		droid = iterateGroup(harvesterGroup);
		while(droid != NULLOBJECT)
		{
			count4 = -1;
			if((droid.order == DORDER_BUILD) or (droid.order == DORDER_LINEBUILD) or (droid.order == DORDER_RTB))
			{
				count4 = 1;
			}
			if((droid.order == DORDER_HELPBUILD) or (droid.order == DORDER_NONE) or (droid.order == DORDER_STOP))
			{
				count4 = -1;
			}
			if( ((droid.orderx == baseX) and (droid.ordery == baseY)) or ((droid.orderx == tempx) and (droid.orderx == tempy) ))
			{
				count4 = 2;
			}

			boolResult2 = FALSE;
			if(count4 == -1)
			{

				count3 = 0;
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.9 " & player, player);
				initEnumStruct(FALSE,derrick,player,player);
				structure2 = enumStruct();
				while(structure2 != NULLOBJECT)
				{
					count3 = count3 + 1;
					structure2 = enumStruct();
				}

				//determine proper action
				boolResult2 = FALSE;
				feature2 = NULLOBJECT;  //this will be build
				count = 99999999;       //init proximity set
				initGetFeature(oilRes,player,player);
				feature = getFeature(player);
				while(feature != NULLOBJECT)
				{
					count2 = 0;
					boolResult = FALSE;
					//distance check
					if( (distBetweenTwoPoints(feature.x,feature.y,droid.x,droid.y) < count) and ((feature.x != tempx) and (feature.y != tempy) ))
					{
						//enemy flag check
						while((count2 < 8) and (boolResult == FALSE))
						{
							if((count2 != player) and (allianceExistsBetween(count2,player) == FALSE))
							{
								if(objectInRange(count2, feature.x,feature.y, 1000) == TRUE)
								{
									boolResult = TRUE;
								}
							}
							count2 = count2 + 1;
						}
						if(count3 >= numMaxDerricks)    {       boolResult = TRUE;              }
					}
					if((boolResult == FALSE) and (distBetweenTwoPoints(feature.x,feature.y,droid.x,droid.y) < count))
					{
						count = distBetweenTwoPoints(feature.x,feature.y,droid.x,droid.y);
						feature2 = feature;
					}
					feature = getFeature(player);
				}
				if( feature2 == NULLOBJECT)
				{
					boolResult = FALSE;
					ASSERT(player >= 0 and player < 8,      "player out of bounds:.10 " & player, player);
					initEnumStruct(FALSE,derrick,player,player);
					structure = enumStruct();
					while((structure != NULLOBJECT) and (boolResult == FALSE))
					{
						if((distBetweenTwoPoints(structure.x,structure.y, baseX,baseY) > 640) and ((structure.x != tempx) and (structure.y != tempy)) )
						{
							buildX = structure.x;
							buildY = structure.y;
							count = 0;
							while((count < numOilStrGroups) and (boolResult == FALSE))
							{
								if( ((count >= highPowerGroup) and (playerPower(player) > 160)) or (count < highPowerGroup))
								{
									boolResult2 = FALSE;
									//detect the best def to build
									count2 = numOilStructs[count] - 1;
									while((count2 > -1) and (boolResult2 == FALSE))
									{
										if(structureBuiltInRange(oilStructs[count][count2], buildX, buildY, 1408, player) != NULLOBJECT)
										{
											boolResult2 = TRUE;
										}
										count2 = count2 - 1;
									}

									if(boolResult2 == FALSE)
									{
										count3 = numOilStructs[count] - 1;
										while((count3 > -1) and (boolResult == FALSE))
										{
											if(isStructureAvailable(oilStructs[count][count3],player))
											{
												boolResult = pickStructLocation(oilStructs[count][count3], ref buildX, ref buildY,player);
												if( boolResult == TRUE )
												{
													orderDroidStatsLoc(droid, DORDER_BUILD,oilStructs[count][count3],buildX,buildY);
													tempx = buildX;
													tempy = buildY;
												}
											}
											count3 = count3 - 1;
										}
									}
								}
								count = count + 1;
							}
						}
						structure = enumStruct();
					}
					if( boolResult == FALSE )
					{
						recentOilEvents = -1;
						if((distBetweenTwoPoints(baseX,baseY,droid.x,droid.y) > 768) and (droid.order != DORDER_RTB) and ((droid.orderx != baseX) and (droid.ordery != baseY)))
						{
							orderDroidLoc(droid, DORDER_MOVE, baseX + 1,baseY + 1);
						}
					}
				}
				else
				{
					buildX = feature2.x;
					buildY = feature2.y;
					orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);
					tempx = buildX;
					tempy = buildY;
				}
			}
			droid = iterateGroup(harvesterGroup);
		}
	}
}

event oilHack1(executeScriptTr)
{
	//oil derrick detection hack
	if((isHumanPlayer(player) == FALSE) or (AIControl == TRUE))
	{
		if(structure3 != NULLOBJECT) { destroyStructure(structure3); }
		oilX= oilX + 10;
		if(oilX>= mapWidth)
		{
			oilX= 0;
			oilY= oilY + 10;
		}
		if(oilY< (mapHeight)   - 11)
		{
			count3 = oilX*128;
			count4 = oilY*128;
			boolResult = pickStructLocation(sensorTower,ref count3, ref count4, player);
			if(boolResult == TRUE) {structure3= addStructure(sensorTower, player, count3, count4 ); }
			setEventTrigger(oilHack1,executeScriptTr);
		}
		else
		{
			setEventTrigger(oilHack1,inactive);
			setEventTrigger(AutoBases,executeScriptTr);
			setEventTrigger(harvesterOperate,buildDerrickTr);       /// IMPORTANT - ACTIVATE HARVESTER WHEN YOU KNOW ALL OIL LOCATIONS
		}
	}
}


event harvesterBuildersSlider(buildDerrickTr)
{
	initIterateGroup(buildGroup);
	droid =  iterateGroup(buildGroup);
	while(droid != NULLOBJECT)
	{
		if(droid.body != engBody)
		{
			boolResult =TRUE;
		}
		droid =  iterateGroup(buildGroup);
	}
	if(boolResult == TRUE)
	{
		if((buildGroup.members + senseGroup.members > 2) and (harvesterGroup.members < 2) and (idleGroup(harvesterGroup) == 0))
		{
			boolResult = FALSE;
			initIterateGroup(buildGroup);
			droid =  iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				if(droid.body != engBody)
				{
					groupAddDroid(harvesterGroup, droid);
					boolResult =TRUE;
				}
				droid =  iterateGroup(buildGroup);
			}
		}
		if( ((buildGroup.members + senseGroup.members < 2) and (harvesterGroup.members > 0)) or ((harvesterGroup.members > 1) and (idleGroup(harvesterGroup) > 1)) )
		{
			boolResult =FALSE;
			initIterateGroup(harvesterGroup);
			droid =  iterateGroup(harvesterGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				groupAddDroid(buildGroup, droid);
				boolResult =TRUE;
				droid =  iterateGroup(harvesterGroup);
			}
		}
	}
	else
	{
		if((buildGroup.members + senseGroup.members > 2) and (harvesterGroup.members < 2))
		{
			boolResult =FALSE;
			initIterateGroup(buildGroup);
			droid =  iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				groupAddDroid(harvesterGroup, droid);
				boolResult =TRUE;
				droid =  iterateGroup(buildGroup);
			}
		}
		if((buildGroup.members + senseGroup.members < 2) and (harvesterGroup.members > 0))
		{
			boolResult =FALSE;
			initIterateGroup(harvesterGroup);
			droid =  iterateGroup(harvesterGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				groupAddDroid(buildGroup, droid);
				boolResult =TRUE;
				droid =  iterateGroup(harvesterGroup);
			}
		}
	}
}

//build extra defenses
event defendOilEnhanced(extraOilDefensesTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(defendOilEnhanced,      inactive);
	}
	else
	{
		if((recentOilEvents == -1) and (playerPower(player) > 100))
		{
			//find idle truck
			initIterateGroup(harvesterGroup);
			droid = iterateGroup(harvesterGroup);
			builddroid = 0;
			while((droid != NULLOBJECT) and (builddroid < 1))
			{
				if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
				{
					builddroid = builddroid  + 1;
				}
				droid = iterateGroup(harvesterGroup);
			}
			if(builddroid  > 0) //idle droid detected
			{
				if(pickDefQueueDepth > 0)
				{
					count = random(pickDefQueueDepth);
					if(isStructureAvailable(pickDefQueue[count],player))
					{
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.11 " & player, player);
						initEnumStruct(FALSE,derrick,player,player);
						structure = enumStruct();
						while(structure != NULLOBJECT)
						{
							count4 = count4 + 1;
							structure = enumStruct();
						}
						count5 = random(count4);
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.12 " & player, player);
						initEnumStruct(FALSE,derrick,player,player);
						structure = enumStruct();
						while(count5 > 0)
						{
							count5 = count5 - 1;
							structure = enumStruct();
						}
						if(structure != NULLOBJECT)
						{
							buildX = structure.x ;
							buildY = structure.y ;
							boolResult = pickStructLocation(pickDefQueue[count], ref buildX, ref buildY,player);
							if(boolResult == TRUE)
							{
								initIterateGroup(harvesterGroup);                       // find idle droids in build group.
								droid = iterateGroup(harvesterGroup);
								builddroid = 0;
								while((droid != NULLOBJECT) and (builddroid < 1))
								{
									if((droid.order != DORDER_BUILD) and (droid.order != DORDER_RTB) and ((droid.orderx != baseX) and (droid.ordery != baseY)))
									{
										orderDroidStatsLoc(droid, DORDER_BUILD,pickDefQueue[count],buildX,buildY);
										builddroid = builddroid  + 1;
									}
									droid = iterateGroup(harvesterGroup);
								}
							}
						}
					}
				}
			}
		}
	}
}



//AACS - Artillery Attacking and Counter-attacking Script
event incendry(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))

	{
		setEventTrigger(incendry,       inactive);
	}
	else
	{
		count2 = 0;
		initIterateGroup(senseGroup);                           // find idle droids in build group.
		droid = iterateGroup(senseGroup);
		while(droid != NULLOBJECT)
		{
			if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
			{
				count2 = count2 + 1;
			}
			droid = iterateGroup(senseGroup);
		}

		if(count2 > 0)
		{
			boolResult2 = FALSE;
			boolResult3 = FALSE;
			count = 0;
			boolResult = FALSE;
			while( (count < numSense) and (boolResult == FALSE))
			{
				if(isStructureAvailable(sense[count], player))
				{
					boolResult = TRUE;
					tempStructurestat = sense[count];
				}
				count = count + 1;
			}
			boolResult = FALSE;

			if(isStructureAvailable(tempStructurestat, player))
			{
				if(isStructureAvailable(CBSense, player))
				{
					if(structureBuiltInRange(CBSense, baseX,baseY, (32*128),player) == NULLOBJECT)
					{
						buildX = baseX;
						buildY = baseY;
						boolResult = pickStructLocation(CBSense, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							initIterateGroup(senseGroup);
							droid = iterateGroup(senseGroup);
							while(droid != NULLOBJECT)
							{
								if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,CBSense,buildX,buildY);
									boolResult3 = TRUE;
								}
								droid = iterateGroup(senseGroup);
							}
						}
					}
				}

				//now proceed to attacking sensors
				//select best spot for sensor
				//NORTH
				if((boolResult2 == FALSE) and (boolResult3 == FALSE))
				{
					//annulate
					tempx = -1;
					tempy = -1;
					buildX = -1;
					buildY = -1;
					//re - set
					buildX = baseX;
					buildY = baseY + (32*128);
					tempx = buildX;
					tempy = buildY;
					//check if the EXACT spot is free
					boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						if((buildX == tempx) and (buildY == tempy))
						{
							//all sets, start building (== no obstacle + no sense built there)
							boolResult2 = TRUE;
						}
						else
						{
							if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
							{
								boolResult2 = TRUE;
							}
						}
					}
				}
				//EAST
				if((boolResult2 == FALSE) and (boolResult3 == FALSE))
				{
					//annulate
					tempx = -1;
					tempy = -1;
					buildX = -1;
					buildY = -1;
					//re - set
					buildX = baseX + (32*128);
					buildY = baseY;
					tempx = buildX;
					tempy = buildY;
					//check if the EXACT spot is free
					boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						if((buildX == tempx) and (buildY == tempy))
						{
							//all sets, start building (== no obstacle + no sense built there)
							boolResult2 = TRUE;
						}
						else
						{
							if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
							{
								boolResult2 = TRUE;
							}
						}
					}
				}
				//SOUTH
				if((boolResult2 == FALSE) and (boolResult3 == FALSE))
				{
					//annulate
					tempx = -1;
					tempy = -1;
					buildX = -1;
					buildY = -1;
					//re - set
					buildX = baseX;
					buildY = baseY - (32*128);
					tempx = buildX;
					tempy = buildY;
					//check if the EXACT spot is free
					boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						if((buildX == tempx) and (buildY == tempy))
						{
							//all sets, start building (== no obstacle + no sense built there)
							boolResult2 = TRUE;
						}
						else
						{
							if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
							{
								boolResult2 = TRUE;
							}
						}
					}
				}
				//WEST
				if((boolResult2 == FALSE) and (boolResult3 == FALSE))
				{
					//annulate
					tempx = -1;
					tempy = -1;
					buildX = -1;
					buildY = -1;
					//re - set
					buildX = baseX - (32*128);
					buildY = baseY;
					tempx = buildX;
					tempy = buildY;
					//check if the EXACT spot is free
					boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						if((buildX == tempx) and (buildY == tempy))
						{
							//all sets, start building (== no obstacle + no sense built there)
							boolResult2 = TRUE;
						}
						else
						{
							if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
							{
								boolResult2 = TRUE;
							}
						}
					}
				}
			}
			if((boolResult2 == TRUE) and (boolResult3 == FALSE))
			{
				initIterateGroup(senseGroup);                           // find idle droids in build group.
				droid = iterateGroup(senseGroup);
				while(droid != NULLOBJECT)
				{
					if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,tempStructurestat,buildX,buildY);
					}
					droid = iterateGroup(senseGroup);
				}
			}
		}
	}
}

//AACS - Group cancel
event incendryStop(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(incendryStop,   inactive);
	}
	else
	{
		initIterateGroup(senseGroup);                           // find idle droids in sense group.
		droid = iterateGroup(senseGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				groupAddDroid(buildGroup, droid);
				setEventTrigger(incendry,       inactive);
			}
			droid = iterateGroup(senseGroup);
		}
	}
}

//AACS - Group init
event incendryStart(incendryTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(incendryStart,  inactive);
	}
	else
	{
		if(currentT > 0)
		{
			count2 = 0;
			initIterateGroup(buildGroup);                   // find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
				{
					count2 = count2 + 1;
				}
				droid = iterateGroup(buildGroup);
			}

			if((count2 != 0) and (senseGroup.members == 0))
			{
				boolResult2 = FALSE;
				boolResult3 = FALSE;
				count = 0;
				boolResult = FALSE;
				while( (count < numSense) and (boolResult == FALSE))
				{
					if(isStructureAvailable(sense[count], player))
					{
						boolResult = TRUE;
						tempStructurestat = sense[count];
					}
					count = count + 1;
				}
				boolResult = FALSE;

				if(isStructureAvailable(tempStructurestat, player))
				{
					if(isStructureAvailable(CBSense, player))
					{
						if(structureBuiltInRange(CBSense, baseX,baseY, (32*128),player) == NULLOBJECT)
						{
							boolResult3 = TRUE;
						}
					}

					//now proceed to attacking sensors
					//select best spot for sensor
					//NORTH
					if((boolResult2 == FALSE) and (boolResult3 == FALSE))
					{
						//annulate
						tempx = -1;
						tempy = -1;
						buildX = -1;
						buildY = -1;
						//re - set
						buildX = baseX;
						buildY = baseY + (32*128);
						tempx = buildX;
						tempy = buildY;
						//check if the EXACT spot is free
						boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							if((buildX == tempx) and (buildY == tempy))
							{
								//all sets, start building (== no obstacle + no sense built there)
								boolResult2 = TRUE;
							}
							else
							{
								if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
								{
									boolResult2 = TRUE;
								}
							}
						}
					}
					//EAST
					if((boolResult2 == FALSE) and (boolResult3 == FALSE))
					{
						//annulate
						tempx = -1;
						tempy = -1;
						buildX = -1;
						buildY = -1;
						//re - set
						buildX = baseX + (32*128);
						buildY = baseY;
						tempx = buildX;
						tempy = buildY;
						//check if the EXACT spot is free
						boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							if((buildX == tempx) and (buildY == tempy))
							{
								//all sets, start building (== no obstacle + no sense built there)
								boolResult2 = TRUE;
							}
							else
							{
								if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
								{
									boolResult2 = TRUE;
								}
							}
						}
					}
					//SOUTH
					if((boolResult2 == FALSE) and (boolResult3 == FALSE))
					{
						//annulate
						tempx = -1;
						tempy = -1;
						buildX = -1;
						buildY = -1;
						//re - set
						buildX = baseX;
						buildY = baseY - (32*128);
						tempx = buildX;
						tempy = buildY;
						//check if the EXACT spot is free
						boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							if((buildX == tempx) and (buildY == tempy))
							{
								//all sets, start building (== no obstacle + no sense built there)
								boolResult2 = TRUE;
							}
							else
							{
								if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
								{
									boolResult2 = TRUE;
								}
							}
						}
					}
					//WEST
					if((boolResult2 == FALSE) and (boolResult3 == FALSE))
					{
						//annulate
						tempx = -1;
						tempy = -1;
						buildX = -1;
						buildY = -1;
						//re - set
						buildX = baseX - (32*128);
						buildY = baseY;
						tempx = buildX;
						tempy = buildY;
						//check if the EXACT spot is free
						boolResult = pickStructLocation(tempStructurestat, ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							if((buildX == tempx) and (buildY == tempy))
							{
								//all sets, start building (== no obstacle + no sense built there)
								boolResult2 = TRUE;
							}
							else
							{
								if( (structureBuiltInRange(tempStructurestat, tempx,tempy, (16*128),player) == NULLOBJECT) and (structureBuiltInRange(tempStructurestat, buildX,buildY, (16*128),player) == NULLOBJECT) and (distBetweenTwoPoints(buildX, buildY, tempx, tempy) < (12*128)))
								{
									boolResult2 = TRUE;
								}
							}
						}
					}
				}
				if((boolResult2 == TRUE) or (boolResult3 == TRUE))
				{
					// usual check end
					boolResult = FALSE;
					initIterateGroup(buildGroup);                   // find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while((droid != NULLOBJECT) and (boolResult == FALSE))
					{
						if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
						{
							groupAddDroid(senseGroup, droid);
							boolResult = TRUE;

						}
						droid = iterateGroup(buildGroup);
					}
					setEventTrigger(incendry,incendryRetryTr);
					setEventTrigger(incendryStop,incendryStopTr);
				}
			}
		}
	}
}
//Randomly deliver sensors around the map
event buildSense(buildSenseTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(buildSense,     inactive);
	}
	else
	{
		//select place
		boolResult3 = FALSE;
		failedTimes = 0;
		while((boolResult3 == FALSE) and (failedTimes < 6))
		{
			tempx = random(mapWidth * 128);
			tempy = random(mapHeight * 128);
			boolResult2 = pickStructLocation(factory,ref tempx, ref tempy, player);
			if(boolResult2 == TRUE)
			{
				count = 0;
				boolResult3 = TRUE;
				while((count < 8) and (boolResult3 == TRUE))
				{
					if(objectInRange(count, tempx,tempy, 1920) == TRUE)
					{
						boolResult3 = FALSE;
					}
					count = count + 1;
				}
			}
			failedTimes = failedTimes  + 1;
		}


		if((failedTimes < 6) and (boolResult3 == TRUE))
		{
			count = 0;
			boolResult = FALSE;
			while( (count < numSense) and (boolResult == FALSE))
			{
				if(isStructureAvailable(sense[count], player))
				{
					boolResult = TRUE;
					tempStructurestat = sense[count];
				}
				count = count + 1;
			}
			if(boolResult == TRUE)
			{
				boolResult2 = FALSE;
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				while((droid != NULLOBJECT) and (boolResult2 == FALSE))
				{
					if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,tempStructurestat,tempx,tempy);
						boolResult2 = TRUE;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
	}
}

// build a power gen for every 4 derricks. VITAL!
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(buildPowerGenerators,   inactive);
		}
		else
		{
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.13 " & player, player);
			initEnumStruct(FALSE,derrick,player,player);                            // count = numderricks
			structure= enumStruct();
			count    = 0;
			while(structure != NULLOBJECT)
			{
				count = count + 1;
				structure= enumStruct();
			}
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.14 " & player, player);
			initEnumStruct(FALSE,powGen,player,player);                             // count2 = numpowgens
			structure= enumStruct();
			count2   = 0;
			while(structure != NULLOBJECT)
			{
				count2 = count2 + 1;
				structure= enumStruct();
			}

			if( (lastPowergen + 1500 > gameTime) and (gameTime > 3400) and (count2 > 4))
			{
				count = 0; //do nothing
			}
			else
			{
				if( (count2 * 4) < count )                                                      // if we need powergen
				{
					buildX = baseX;                                                                 // try build powergen.
					buildY = baseY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						initIterateGroup(buildGroup);
						droid = iterateGroup(buildGroup);
						builddroid = 0;
						while((droid != NULLOBJECT) and (builddroid < 2))
						{
							if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
								builddroid = builddroid  + 1;
								lastPowergen = gameTime;
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
	}
}


// BASE BUILDING SCRIPT
event buildBaseQueue(buildBaseQueueTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(buildBaseQueue, inactive);
		}
		else
		{
			count = 0;
			pickStrQueueDepth = 0;
			while(count < numStructs)
			{
				count2 = 0;
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.15 " & player, player);
				initEnumStruct(FALSE,structs[count],player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					count2 = count2 + 1;
					structure = enumStruct();
				}
				if((isStructureAvailable(structs[count],player)) and (count2 < structsLimits[count]))
				{
					pickStrQueue[pickStrQueueDepth] = structs[count];
					pickStrQueueDepth = pickStrQueueDepth + 1;
				}
				count = count + 1;
			}
		}
	}
}
event buildBase(buildBaseTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(buildBase,      inactive);
		}
		else
		{
			if(pickStrQueueDepth > 0)
			{
				count = random(pickStrQueueDepth);
				if(isStructureAvailable(pickStrQueue[count],player))
				{
					buildX = baseX;                                 // pick a location
					buildY = baseY;
					if(idleGroup(buildGroup) > 0)
					{
						boolResult = pickStructLocation(pickStrQueue[count], ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{
							initIterateGroup(buildGroup);                   // find idle droids in build group.
							droid = iterateGroup(buildGroup);
							builddroid = 0;
							while((droid != NULLOBJECT) and (builddroid < 2))
							{
								if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,pickStrQueue[count],buildX,buildY);
									builddroid = builddroid  + 1;
								}
								droid = iterateGroup(buildGroup);
							}
						}
					}
				}
			}
		}
	}
}

event structureLimitHack(defendBaseTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(structureLimitHack,     inactive);
	}
	else
	{
		//limit hack
		initIterateGroup(buildGroup);                           // find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if((droid.order != DORDER_BUILD) and (droid.order != DORDER_HELPBUILD) and (droid.order != DORDER_RTB))
			{
				orderDroid(droid, DORDER_STOP);
				orderDroid(droid, DORDER_NONE);

			}
			if(droid.order == DORDER_MOVE)
			{
				orderDroid(droid, DORDER_STOP);
				orderDroid(droid, DORDER_NONE);
			}
			droid = iterateGroup(buildGroup);
		}
	}
}

//remove artifacts from world
event vanishArtifacts(managePowerTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vanishArtifacts,        inactive);
	}
	else
	{
		//remove artifacts from world
		initGetFeature(artefact,player,player);
		feature = getFeature(player);
		while(feature != NULLOBJECT)
		{
			destroyFeature(feature);
			feature = getFeature(player);
		}
	}
}





// BASE DEFENDING SCRIPT
event defendBaseQueue(defendBaseQueueTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(defendBaseQueue,        inactive);
		}
		else
		{
			//switch T level
			if(currentT == 0)
			{
				if(isStructureAvailable(TEdge[0],player))
				{
					currentT = 1;
				}
			}
			if(currentT == 1)
			{
				if(isStructureAvailable(TEdge[1],player))
				{
					currentT = 2;
				}
			}

			//build queue
			count = 0;
			pickDefQueueDepth = 0;
			while(count < numTStructs[currentT])
			{
				if(isStructureAvailable(defStructs[currentT][count],player))
				{
					pickDefQueue[pickDefQueueDepth] = defStructs[currentT][count];
					pickDefQueueDepth = pickDefQueueDepth + 1;
				}
				count = count + 1;
			}
		}
	}
}

event defendSpotSelect(defendSpotChangeTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(defendSpotSelect, inactive);
		}
		else
		{
			buildX = baseX;
			buildY = baseY;
			boolResult = pickStructLocation(factory, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{
				defSpotX = buildX;
				defSpotY = buildY;
			}
			else
			{
				defSpotX = baseX;
				defSpotY = baseY;
			}
		}
	}
}

event defendBase(defendBaseTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(defendBase,     inactive);
		}
		else
		{
			if((gameTime > defendDelay) or ((playerPower(player) > 5000) and (gameTime > defendDelayHP) ) )
			{
				//find idle truck
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				builddroid = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						builddroid = builddroid  + 1;
					}
					droid = iterateGroup(buildGroup);
				}
				if(builddroid  > 0) //idle droid detected
				{
					if((AAPx == -1) or ((gameTime - AAPtime) > 120))
					{
						if(playerPower(player) > 100)
						{
							if(pickDefQueueDepth > 0)
							{
								count = random(pickDefQueueDepth);
								if(isStructureAvailable(pickDefQueue[count],player))
								{
									if((defSpotX > 0) and (defSpotY > 0))
									{
										buildX = defSpotX;                              // pick a location
										buildY = defSpotY;
									}
									else
									{
										buildX = baseX;
										buildY = baseY;
									}
									boolResult = pickStructLocation(pickDefQueue[count], ref buildX, ref buildY,player);
									if(boolResult == TRUE)
									{
										initIterateGroup(buildGroup);           // find idle droids in build group.
										droid = iterateGroup(buildGroup);
										builddroid = 0;
										while((droid != NULLOBJECT) and (builddroid < 1))
										{
											if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
											{
												orderDroidStatsLoc(droid, DORDER_BUILD,pickDefQueue[count],buildX,buildY);
												builddroid = builddroid  + 1;
											}
											droid = iterateGroup(buildGroup);
										}
									}
								}
							}
						}
					}
					else
					{
						//// react to remote request and build AA defence
						initIterateGroup(buildGroup); // find idle droids in build group.
						droid = iterateGroup(buildGroup);
						builddroid = 0;
						while((droid != NULLOBJECT) and (builddroid < 1))
						{
							if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
							{
								buildX = AAPx;
								buildY = AAPy;
								count = 0;
								count2 = -1;
								while( count < numAA)
								{
									if(isStructureAvailable(vtolDefStruct[count],player))
									{
										count2 = count;
									}
									count = count + 1;
								}
								if(count2 != (-1) )
								{
									boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,player);
									if(boolResult == TRUE)
									{
										orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
										builddroid = builddroid  + 1;
										AAPx = -1;

									}
								}
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
	}
}



event defendBaseLP(defendBaseLPTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(defendBase,     inactive);
		}
		else
		{
			//find idle truck
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			builddroid = 0;
			while((droid != NULLOBJECT) and (builddroid < 1))
			{
				if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
				{
					builddroid = builddroid  + 1;
				}
				droid = iterateGroup(buildGroup);
			}
			if(builddroid  > 0) //idle droid detected
			{
				if((AAPx == -1) or ((gameTime - AAPtime) > 120))
				{
					if(pickDefQueueDepth > 0)
					{
						count = random(pickDefQueueDepth);
						if(isStructureAvailable(pickDefQueue[count],player))
						{
							if((defSpotX > 0) and (defSpotY > 0))
							{
								buildX = defSpotX;                                      // pick a location
								buildY = defSpotY;
							}
							else
							{
								buildX = baseX;
								buildY = baseY;
							}
							boolResult = pickStructLocation(pickDefQueue[count], ref buildX, ref buildY,player);
							if(boolResult == TRUE)
							{
								initIterateGroup(buildGroup);                   // find idle droids in build group.
								droid = iterateGroup(buildGroup);
								builddroid = 0;
								while((droid != NULLOBJECT) and (builddroid < 1))
								{
									if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
									{
										orderDroidStatsLoc(droid, DORDER_BUILD,pickDefQueue[count],buildX,buildY);
										builddroid = builddroid  + 1;
									}
									droid = iterateGroup(buildGroup);
								}
							}
						}
					}
				}
			}
			else
			{
				//// react to remote request and build AA defence
				initIterateGroup(buildGroup);   // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						buildX = AAPx;
						buildY = AAPy;
						count = 0;
						count2 = -1;
						while( count < numAA)
						{
							if(isStructureAvailable(vtolDefStruct[count],player))
							{
								count2 = count;
							}
							count = count + 1;
						}
						if(count2 != (-1) )
						{
							boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,player);
							if(boolResult == TRUE)
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
								builddroid = builddroid  + 1;
								AAPx = -1;

							}
						}
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
	}
}

event testColorFog(inactive)
{
	if(currentT == 0)       {       setFogColour(255,0,0);  }
	if(currentT == 1)       {       setFogColour(0,255,0);  }
	if(currentT == 2)       {       setFogColour(0,0,255);  }
}


//artillery building script
event buildBaseArty( buildBaseArtyTr )
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(buildBaseArty,inactive);
		}
		else
		{
			if( ((gameTime > defendDelay) or ((playerPower(player) > 5000) and (gameTime > defendDelayHP)) ) and (playerPower(player) > 100) )
			{
				//find idle truck
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				builddroid = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						builddroid = builddroid  + 1;
					}
					droid = iterateGroup(buildGroup);
				}
				if(builddroid  > 0) //idle droid detected
				{
					count = 0;
					while(count < numIncendrys)
					{
						if( isStructureAvailable(incendrys[count],player))
						{
							count2 = 0;
							ASSERT(player >= 0 and player < 8,      "player out of bounds:.16 " & player, player);
							initEnumStruct(FALSE,incendrys[count],player,player);
							structure =  enumStruct();
							while(structure != NULLOBJECT)
							{
								count2 = count2 + 1;
								structure =  enumStruct();
							}
							if(count2 < 14)
							{
								pickStructureQueue[pickStructureQueueDepth] = incendrys[count];
								pickStructureQueueDepth  = pickStructureQueueDepth  + 1;
							}
						}
						count = count + 1;
					}
					if(pickStructureQueueDepth > 0)
					{
						initIterateGroup(buildGroup);           // find idle droids in build group.
						droid = iterateGroup(buildGroup);
						builddroid = 0;
						boolResult = TRUE;
						while((droid != NULLOBJECT) and (builddroid < 1) and (boolResult == TRUE))
						{
							if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
							{
								count = 0;
								if(pickStructureQueueDepth < 2)
								{
									extraStruct = random(pickStructureQueueDepth);
								}
								else
								{
									extraStruct = random(2);
								}
								buildX = baseX;
								buildY = baseY;
								boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
								if(boolResult == TRUE)
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,pickStructureQueue[extraStruct], buildX,buildY);
									builddroid = builddroid  + 1;
								}
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
	}
}

// Structure (fac/res/pow) upgrades
event upgradeStructures(upgradeStructuresTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(upgradeStructures,inactive);
	}
	else
	{
		if(LIFE)        {
			initIterateGroup(buildGroup);                   // find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
				{
					ASSERT(player >= 0 and player < 8,      "player out of bounds:.17 " & player, player);
					initEnumStruct(FALSE,factory,player,player);
					structure= enumStruct();
					while(structure != NULLOBJECT)
					{
						if( isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ) and (structureComplete(structure)))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);
						}
						structure= enumStruct();
					}
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.18 " & player, player);
						initEnumStruct(FALSE,powGen,player,player);
						structure= enumStruct();
						while(structure != NULLOBJECT)
						{
							if( isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)) and (structureComplete(structure)))
							{
								orderDroidStatsLoc(droid,DORDER_BUILD,powModule, structure.x,structure.y);
							}
							structure= enumStruct();
						}
					}
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.19 " & player, player);
						initEnumStruct(FALSE,resLab,player,player);
						structure= enumStruct();
						while(structure != NULLOBJECT)
						{
							if( isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)) and (structureComplete(structure)))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,resModule, structure.x,structure.y);
							}
							structure= enumStruct();
						}
					}
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.20 " & player, player);
						initEnumStruct(FALSE,vtolFactory,player,player);
						structure= enumStruct();
						while(structure != NULLOBJECT)
						{
							if( isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ) and (structureComplete(structure)))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);
							}
							structure= enumStruct();
						}
					}
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}
}


//	Finish Building Part Built Structures
event finishStructs(finishStructsTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(finishStructs,  inactive);
	}
	else
	{
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.21 " & player, player);
		initEnumStruct(FALSE,factory,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}

		ASSERT(player >= 0 and player < 8,      "player out of bounds:.22 " & player, player);
		initEnumStruct(FALSE,cybFactory,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}

		ASSERT(player >= 0 and player < 8,      "player out of bounds:.23 " & player, player);
		initEnumStruct(FALSE,vtolFactory,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}

		ASSERT(player >= 0 and player < 8,      "player out of bounds:.24 " & player, player);
		initEnumStruct(FALSE,powGen,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}

		ASSERT(player >= 0 and player < 8,      "player out of bounds:.25 " & player, player);
		initEnumStruct(FALSE,resLab,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}

		ASSERT(player >= 0 and player < 8,      "player out of bounds:.26 " & player, player);
		initEnumStruct(FALSE,playerHQ,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);                           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid  = 0;
				while((droid != NULLOBJECT) and (builddroid < 1))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
						builddroid  = builddroid   + 1;
					}
					droid = iterateGroup(buildGroup);

				}
			}
			structure= enumStruct();
		}
	}
}




//  fortify base by builiding defensive structs on the edge of the base.
event newfortify(fortifyTr)
{
	if(LIFE)        {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(newfortify,     inactive);
		}
		else
		{
			boolResult = FALSE;
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while((boolResult == FALSE) and (droid != NULLOBJECT))
			{
				if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
				{
					tempx = baseX;
					tempy = baseY;
					count = random(numWallWeaps);
					failedTimes = 0;
					while(( isStructureAvailable(wallWeaps[count],player) == FALSE ) and (failedTimes < 64))
					{
						failedTimes = failedTimes + 1;
						count = random(numWallWeaps);
					}
					if(isStructureAvailable(wallWeaps[count],player) == TRUE)
					{
						skDefenseLocation(ref tempx,ref tempy,wallStruct,wallWeaps[count],droid,player);
						boolResult = TRUE;
					}
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}
}




// droid building rules
// deal with a droid being built
event droidBuilt(droidBuiltTr)
{
	if(droid != NULLOBJECT)
	{
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(droidBuilt,     inactive);
		}
		else
		{

// TANK
			if(droid.droidType == DROID_WEAPON)
			{
				groupAddDroid(tankGroup, droid);
			}


// CYBORG
			if(droid.propulsion == cyborgPropulsion)
			{
				groupAddDroid(cyborgGroup, droid);
			}



// VTOL

			boolResult = FALSE;
			if((isVtol(droid)) and (droid.droidType != DROID_CONSTRUCT))
			{
				if(vtolUnitGroup.members < 6)
				{
					groupAddDroid(vtolGroup, droid);
					if(droid.weapon != BBs)
					{
						groupAddDroid(vtolUnitGroup, droid);
						boolResult = TRUE;
						if(TCSVtolUnitArray != -1)
						{
							if(seenUnitArray[TCSVtolUnitArray] != NULLOBJECT)
							{
								orderDroidObj(droid, DORDER_ATTACK,seenUnitArray[TCSVtolUnitArray] );
							}
							else
							{
								orderDroid(droid, DORDER_RTR);
							}
						}
						else
						{
							orderDroid(droid, DORDER_RTR);
						}
					}
				}
				else
				{
					groupAddDroid(vtolGroup, droid);
				}

				if((boolResult == TRUE) and (vtolTarget != NULLOBJECT))
				{
					orderDroidObj(droid, DORDER_ATTACK,vtolTarget );
				}
				else
				{
					orderDroid(droid, DORDER_RTR);
				}
			}


// NEXUS

			if((droid.weapon == NEXUS_WEAPON1) or (droid.weapon == NEXUS_WEAPON2))
			{
				if(useNEXUS)
				{
					groupAddDroid(nexusGroup, droid);
				}
				else
				{
					groupAddDroid(tankGroup, droid);
				}
			}

// VTOL/CYBORG/TANK TRUCK

			if((droid.body == engBody) or (droid.droidType == DROID_CONSTRUCT))
			{
				if(harvesterGroup.members >= numHarvesters)
				{
					groupAddDroid(buildGroup, droid);
				}
				else
				{
					if(droid.body != engBody) { groupAddDroid(harvesterGroup, droid); } else{ groupAddDroid(buildGroup, droid); }
				}
			}

		}
		setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
		setDroidSecondary(droid,DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
		setDroidSecondary(droid,DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS);
		setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);

	}
}

// UNIT RESORTING SCRIPT
event reSortUnits(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(droidBuilt,     inactive);
	}
	else
	{
		groupAddArea(xGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
		initIterateGroup(xGroup);
		droid = iterateGroup(xGroup);
		while(droid != NULLOBJECT)
		{


// TANK
			if(droid.droidType == DROID_WEAPON)
			{
				groupAddDroid(tankGroup, droid);
			}


// CYBORG
			if(droid.propulsion == cyborgPropulsion)
			{
				groupAddDroid(cyborgGroup, droid);
			}



// VTOL

			boolResult = FALSE;
			if((isVtol(droid)) and (droid.droidType != DROID_CONSTRUCT))
			{
				if(vtolUnitGroup.members < 6)
				{
					groupAddDroid(vtolGroup, droid);
					if(droid.weapon != BBs)
					{
						groupAddDroid(vtolUnitGroup, droid);
					}
				}
				else
				{
					groupAddDroid(vtolGroup, droid);
				}
			}


// NEXUS

			if((droid.weapon == NEXUS_WEAPON1) or (droid.weapon == NEXUS_WEAPON2))
			{
				if(useNEXUS)
				{
					groupAddDroid(nexusGroup, droid);
				}
				else
				{
					groupAddDroid(tankGroup, droid);
				}
			}

// VTOL/CYBORG/TANK TRUCK

			if((droid.body == engBody) or (droid.droidType == DROID_CONSTRUCT))
			{
				if(harvesterGroup.members >= numHarvesters)
				{
					groupAddDroid(buildGroup, droid);
				}
				else
				{
					if(droid.body != engBody) { groupAddDroid(harvesterGroup, droid); } else{ groupAddDroid(buildGroup, droid); }
				}
			}
			droid = iterateGroup(xGroup);
		}
	}
}





////////////////// ADVANCED FACTORY PRODUCTION SCRIPT
event SelectRndTemplateRun(inactive)
{
	if(useTanks) { //GENERAL FEATURE OVERRIDE
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(SelectRndTemplateRun,inactive);
		}
		else
		{
			if(playerPower(player) > 100)
			{
				facLimit = 255;
			}
			else
			{
				facLimit = 2;
			}

			ASSERT(player >= 0 and player < 8,      "player out of bounds:.27 " & player, player);
			initEnumStruct(FALSE,factory,player,player);
			structure = enumStruct();
			while( (structure != NULLOBJECT) and (facLimit != 0) )
			{
				if(structureComplete(structure))
				{
					if(structureIdle(structure))
					{
						boolResult = FALSE;
						if((buildGroup.members + senseGroup.members < 4) and (gameTime < 1800)) { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 6) and (gameTime > 1800) and (gameTime < 3600))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 8) and (gameTime > 3600) and (gameTime < 5400))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 9) and (gameTime > 5400))        { boolResult = TRUE; }
						if(boolResult == TRUE) //TRUCK NEEDED
						{
							if((getDroidCount(player) < 80) and (structureIdle(structure) == TRUE))
							{
								buildDroid(constructor, structure, player, 1); // build tank constructor
							}
						}


						if((boolResult == FALSE) and (buildBBCheck < 6)) // NO TRUCK NEEDED AND ENOUGH BBs BUILT
						{
							count3 = numTmpls - 1;
							count2 = 0;
							boolResult2 = FALSE;
							while((count2 < numTmpls) and (boolResult2 == FALSE))
							{
								if(skCanBuildTemplate(player,structure, tmpl0[count2]) == TRUE)
								{
									count3 = count2;
									boolResult2 = TRUE;
								}
								count2 = count2 + 1;
							}

							count2 = 0;
							count4 = 0;
							boolResult2 = FALSE;
							if(count3 >= numTmpls - 6)
							{
								count2 = numTmpls - count3;
							}
							else
							{
								count2 = 6;
							}

							count4 = random(count2);
							count = count3 + count4;

							if((getDroidCount(player) < 80) and ((tankGroup.members) < 34) and (structureIdle(structure) == TRUE) and (skCanBuildTemplate(player,structure, tmpl0[count]) == TRUE ))
							{
								buildDroid(tmpl0[count],structure,player,1); //build droid
								buildBBCheck = buildBBCheck + 1;
							}
						}

						if((boolResult == FALSE) and (buildBBCheck == 6) and (structureIdle(structure) == TRUE) ) //  NEED BBs
						{
							buildBBCheck = 0;
							count3 = numBBs - 1;
							count2 = 0;
							boolResult2 = FALSE;
							while((count2 < numBBs) and (boolResult2 == FALSE))
							{
								if(skCanBuildTemplate(player,structure, tmpl1[count2]) == TRUE)
								{
									count3 = count2;
									boolResult2 = TRUE;
								}
								count2 = count2 + 1;
							}
							count = count3;

							if((getDroidCount(player) < 80) and ((tankGroup.members) < 34) and (structureIdle(structure) == TRUE) and (skCanBuildTemplate(player,structure, tmpl1[count]) == TRUE ))
							{
								buildDroid(tmpl1[count],structure,player,1); //build droid
							}
						}
					}
					facLimit = facLimit - 1;
				}
				structure = enumStruct();
			}
		}
	}
}

event SelectRndTemplate( tankBuildEventTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(SelectRndTemplate,inactive);
	}
	else
	{
		setEventTrigger(SelectRndTemplateRun,tankAttackTr1);
	}
}


////////////////// ADVANCED CYBORG PRODUCTION SCRIPT
event SelectRndTemplateCRun(inactive)
{
	if(useCyborgs) { //GENERAL FEATURE OVERRIDE
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(SelectRndTemplateCRun,inactive);
		}
		else
		{
			count5 = 0;
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.28 " & player, player);
			initEnumStruct(FALSE,factory,player,player);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				if(structureComplete(structure ))       {       count5 = count5  + 1;   }
				structure = enumStruct();
			}


			if(playerPower(player) > 100)
			{
				facLimit = 255;
			}
			else
			{
				facLimit = 1;
			}
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.29 " & player, player);
			initEnumStruct(FALSE,cybFactory,player,player);
			structure = enumStruct();
			while( (structure != NULLOBJECT) and (facLimit != 0) )
			{
				if(structureComplete(structure))
				{
					if(structureIdle(structure))
					{
						boolResult = FALSE;
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 5) and (gameTime < 1800))        { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 6) and (gameTime > 1800) and (gameTime < 3600))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 8) and (gameTime > 3600) and (gameTime < 5400))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 9) and (gameTime > 5400))        { boolResult = TRUE; }
						//don't build crappy cyborg engineers if not necessary (just remove follownig line to disable)
						if(count5 > 0)  {       boolResult = FALSE;     }
						if(boolResult == TRUE) //TRUCK NEEDED
						{
							if((getDroidCount(player) < 80) and (structureIdle(structure) == TRUE))
							{
								buildDroid(cybcondroid, structure, player, 1); // build cyborg constructor
							}
						}




						if(boolResult == FALSE) // NO TRUCK NEEDED
						{
							count3 = numSuperCyb - 1;
							count2 = 0;
							boolResult2 = FALSE;
							while((count2 < numSuperCyb ) and (boolResult2 == FALSE))
							{
								if(skCanBuildTemplate(player,structure, superCyb[count2]) == TRUE)                                                                      {
									count3 = count2;
									boolResult2 = TRUE;
								}
								count2 = count2 + 1;
							}

							count2 = 0;
							count4 = 0;
							boolResult2 = FALSE;
							if(count3 >= numSuperCyb - 6)
							{
								count2 = numSuperCyb - count3;
							}
							else
							{
								count2 = 6;
							}

							count4 = random(count2);
							count = count3 + count4;

							if((getDroidCount(player) < 80) and ((cyborgGroup.members) < 16) and (structureIdle(structure) == TRUE) and (skCanBuildTemplate(player,structure, superCyb[count]) == TRUE ))
							{
								buildDroid(superCyb[count],structure,player,1); //build droid
							}
						}
					}
					facLimit = facLimit - 1;
				}
				structure = enumStruct();
			}
		}
	}
}
event SelectRndTemplateC(cyborgBuildEventTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(SelectRndTemplateC,inactive);
	}
	else
	{
		setEventTrigger(SelectRndTemplateCRun,cyborgAttackTr1);
	}
}

// NEXUS technologies

event takeover(takeoverTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))   {
		setEventTrigger(takeover,       inactive);
	}
	else
	{
		if(droid != NULLOBJECT)
		{
			if( droid.player == player )
			{
				orderDroidLoc(droid, DORDER_MOVE,baseX,baseY);

//// ASSIGN UNIT
// TANK
				if(droid.droidType == DROID_WEAPON)
				{
					groupAddDroid(tankGroup, droid);
				}


// CYBORG
				if(droid.propulsion == cyborgPropulsion)
				{
					groupAddDroid(cyborgGroup, droid);
				}



// VTOL

				boolResult = FALSE;
				if((isVtol(droid)) and (droid.droidType != DROID_CONSTRUCT))
				{
					if(vtolUnitGroup.members < 6)
					{
						groupAddDroid(vtolGroup, droid);
						if(droid.weapon != BBs)
						{
							groupAddDroid(vtolUnitGroup, droid);
							boolResult = TRUE;
							if(TCSVtolUnitArray != -1)
							{
								if(seenUnitArray[TCSVtolUnitArray] != NULLOBJECT)
								{
									orderDroidObj(droid, DORDER_ATTACK,seenUnitArray[TCSVtolUnitArray] );

								}
								else
								{
									orderDroid(droid, DORDER_RTR);
								}
							}
							else
							{
								orderDroid(droid, DORDER_RTR);
							}
						}
					}
					else
					{
						groupAddDroid(vtolGroup, droid);
					}

					if((boolResult == TRUE) and (vtolTarget != NULLOBJECT))
					{
						orderDroidObj(droid, DORDER_ATTACK,vtolTarget );
					}
					else
					{
						orderDroid(droid, DORDER_RTR);
					}
				}



// NEXUS
				if((droid.weapon == NEXUS_WEAPON1) or (droid.weapon == NEXUS_WEAPON2))
				{
					groupAddDroid(nexusGroup, droid);
				}


// VTOL/CYBORG/TANK TRUCK

				if((droid.body == engBody) or (droid.droidType == DROID_CONSTRUCT))
				{
					if(harvesterGroup.members >= numHarvesters)
					{
						groupAddDroid(buildGroup, droid);
					}
					else
					{
						if(droid.body != engBody) { groupAddDroid(harvesterGroup, droid); } else{ groupAddDroid(buildGroup, droid); }
					}
				}


				setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
				setDroidSecondary(droid,DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
				setDroidSecondary(droid,DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS);
				setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
////  ASSIGN UNIT




				if(droid != NULLOBJECT)
				{
					if(isVtol(droid))
					{
						orderDroid(droid, DORDER_RTR);
					}
					else
					{
						orderDroid(droid, DORDER_RTB);
					}
				}
			}
		}
		setEventTrigger(reSortUnits,vtolAttackTr1);
	}
}

/*
   //// ATTACK STANCE SWITCH
   event attackStanceSwitch(stanceSwitchTr)
   {
        tankStance = random(2);
        if(tankStance == 0)
        {
                cyborgStance = 1;
        }
        else
        {
                cyborgStance = 0;
        }
   cyborgTarget = NULLOBJECT;
   tankTarget = NULLOBJECT;
   }*/


event takeoverDefend(EtakeoverTr)  //even this necessary cheating is minimised!
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(takeoverDefend, inactive);
	}
	else
	{
		setEventTrigger(reSortUnits,vtolAttackTr1);
		if((droid != NULLOBJECT) and (NEXUSActivatedTimes > 5))
		{
			if( droid.player != player)
			{
				completeResearch(nexusDefence,player);
				setEventTrigger(takeoverDefend, inactive);
			}

		}
		NEXUSActivatedTimes = NEXUSActivatedTimes + 1;
	}
}




/// LASER SATELLITE CONTROL v2 ///

///// STAGE 2  -  Emulate reload time
event lassatRecharge(lassatRechargetr)
{
	LasSatCharged = TRUE;
}

////// STAGE 1  -  BUILD LasSat & TARGETTING
event Buildlassat(doResearchTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(Buildlassat,    inactive);
	}
	else
	{
		structure = getStructure(lassat,player);
		if(structure == NULLOBJECT)
		{
			if(isStructureAvailable(lassat,player))
			{
				buildX = baseX;                                         // pick a location
				buildY = baseY;
				boolResult = pickStructLocation(lassat, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);           // find idle droids in build group.
					droid = iterateGroup(buildGroup);
					builddroid = 0;
					while((droid != NULLOBJECT) and (builddroid < 2))
					{
						if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,lassat, buildX,buildY);  // build LasSat
							builddroid = builddroid + 1;
						}
						droid = iterateGroup(buildGroup);
					}
					if(builddroid > 0)
					{
						LasSatCharged = FALSE;
						setEventTrigger(lassatRecharge,lassatRechargetr);
					}
				}
			}
		}
		else
		{
			if(lassatTarget == NULLOBJECT)
			{
				//SELECT RANDOM ENEMY FOR LASSAT ATTACK
				count = 0;
				plCount = 0;
				while(count < 8)
				{
					// DETECT ANY POTENTIAL TARGETS
					count2 = 0;
					structure = NULLOBJECT;
					while((count2 < numGroundTargets) and (structure == NULLOBJECT))
					{
						ASSERT(count >= 0 and count < 8,        "player out of bounds:.30 " & count, player);
						initEnumStruct(FALSE,structureTargets[count2],count,count);
						structure = enumStruct();
						count2 = count2 + 1;
					}
					if((structure != NULLOBJECT) and (count != player) and (allianceExistsBetween(count, player) == FALSE))
					{
						plNum[plCount] = count ;
						plCount = plCount + 1;
					}
					count = count + 1;
				}
				if(plCount > 0)
				{
					count3 = plNum[random(plCount)]; // target player
				}

				count = 0;
				minDistance = 0; // number of surrounding objects
				while(count < numGroundTargets)
				{
					ASSERT(count3 >= 0 and count3 < 8,      "player out of bounds:.31 " & count3, player);
					initEnumStruct(FALSE,structureTargets[count],count3,count3);
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						rectFixX = structure.x;
						rectFixY =  structure.y;
						rectFixRange = 256;
						/// PRECOMPILED SCRIPT
						rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
						/// PRECOMPILED SCRIPT

						count2 = numDroidsInArea(count3,rectFixX1,rectFixY1, rectFixX2,rectFixY2) + numStructsInArea(count3,rectFixX1,rectFixY1, rectFixX2,rectFixY2);
						if(count2 > minDistance)
						{
							minDistance = count2;
							lassatTarget = structure;
						}
						structure = enumStruct();
					}
					count = count + 1;
				}

				if(lassatTarget != NULLOBJECT)
				{
					if(allianceExistsBetween(player, lassatTarget.player))
					{
						lassatTarget = NULLOBJECT;
					}
				}
			}
		}
	}
}

////////// STAGE 3   -   Fire Laser Satellite
event activatelassat(lassatEventTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(activatelassat, inactive);
	}
	else
	{
		structure = getStructure(lassat,player);
		if((structure != NULLOBJECT) and (LasSatCharged == TRUE) and (lassatTarget != NULLOBJECT))
		{
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.32 " & player, player);
			initEnumStruct(FALSE,lassat,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				if(structureComplete(structure) == TRUE)
				{
					skFireLassat(player,lassatTarget);
					LasSatCharged = FALSE;
					targetSelected = FALSE;
				}
				structure= enumStruct();
			}
		}
	}
}

//////END - LASSAT/////




///////////////////////////////////////////////////
/////  ADVANCED ATTACKING SCRIPT MK-7 /////
/////////////////////// a.k.a. //////////////////////
///////////  "Tank Superior Assault Script"   //////////
///////////////////////////////////////////////////
////// INITIALIZATION
event tank_AAS_INIT(tankInitTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_INIT,inactive);
	}
	else
	{
		if(tankActive == FALSE)
		{
			// stop everything just in case
			tankActive = FALSE;
			tankMigrationBool1 = FALSE;
			tankAntiUnit1 = FALSE;
			tankSubInitBool2 = FALSE;
			tankPosBool1 = FALSE;
			tankSubInitBool1 = FALSE;
			tankTarget = NULLOBJECT;

			count = random(15);
			if( (tankGroup.members >= (12 + count)) and (gameTime - lastBaseAttacked > 300) )
			{
				//START MIGRATION
				randomiseSeed();        //this randomisation will differ for ach AI
				tankActive = TRUE;
				tankMigrationBool1 = TRUE;
				tankAntiUnit1 = FALSE;
				tankSubInitBool2 = FALSE;
				tankPosBool1 = FALSE;
				tankSubInitBool1 = FALSE;
			}
			else
			{
				if(tankGroup.members > 0)
				{
					boolResult = FALSE;
					structure = getStructure(factory, player);
					if(structure == NULLOBJECT)
					{
						structure = getStructure(playerHQ, player);
					}
					if(structure != NULLOBJECT)
					{
						buildX = structure.x;
						buildY = structure.y;
						boolResult = pickStructLocation(factory,ref buildX,ref buildY, player);
					}
					if((boolResult == TRUE) and (distBetweenTwoPoints(buildX, buildY,tankGroup.x, tankGroup.y) > 1200))
					{
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
							if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
							{
								orderDroidLoc(droid, DORDER_MOVE, buildX,buildY);
							}

							droid =  iterateGroup(tankGroup);
						}
					}
					else
					{
						buildX = tankGroup.x;
						buildY = tankGroup.y;
						boolResult = pickStructLocation(factory,ref buildX,ref buildY, player);
						if(boolResult == TRUE)
						{
							initIterateGroup(tankGroup);
							droid =  iterateGroup(tankGroup);
							while(droid != NULLOBJECT)
							{
								setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
								{
									orderDroidLoc(droid, DORDER_MOVE, buildX,buildY);
								}
								droid =  iterateGroup(tankGroup);
							}
						}
						else
						{
							orderGroupLoc(tankGroup, DORDER_MOVE, tankGroup.x, tankGroup.y);
						}
					}
				}
			}
		}
	}
}

////// MIGRATION
event tank_AAS_MIGRATION(emulateZeroWaitTr)     //ALWAYS ON (WAIT,0 - EMULATION)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_MIGRATION,inactive);
	}
	else
	{
		if(tankMigrationBool1)
		{
			boolResult3 = TRUE;
			//SELECT A PLAYER FOR ATTACK RUN
			if(targetPl != -1)
			{
				// DETECT ANY POTENTIAL TARGETS
				count2 = 0;
				structure = NULLOBJECT;
				while((count2 < numGroundTargets) and (structure == NULLOBJECT))
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.33 " & targetPl, player);
					initEnumStruct(FALSE,structureTargets[count2],targetPl,targetPl );
					structure = enumStruct();
					count2 = count2 + 1;
				}
				if(structure == NULLOBJECT)
				{
					targetPl = -1; // target invalid
				}
			}


			count = 0;
			plCount = 0;
			while(count < 8)
			{
				// DETECT ANY POTENTIAL TARGETS
				count2 = 0;
				structure = NULLOBJECT;
				while((count2 < numGroundTargets) and (structure == NULLOBJECT))
				{
					ASSERT(count >= 0 and count < 8,        "player out of bounds:.34 " & count, player);
					initEnumStruct(FALSE,structureTargets[count2],count,count);
					structure = enumStruct();
					count2 = count2 + 1;
				}
				if((structure != NULLOBJECT) and (count != player) and (allianceExistsBetween(count, player) == FALSE))
				{
					plNum[plCount] = count ;
					plCount = plCount + 1;
				}
				count = count + 1;
			}
			if((targetPl == -1) and (plCount > 0))
			{
				targetPl =  plNum[random(plCount)];
			}

			//SELECT BEST MIGRATION SPOT
			if(targetPl >-1)
			{
				count = 0;
				structure = NULLOBJECT;
				minDistance = 99999999;
				while(count < numInitialTargets)
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.35 " & targetPl, player);
					initEnumStruct(FALSE,initialTargets[count],targetPl,targetPl);
					structure2 = enumStruct();
					while(structure2 != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure2.x, structure2.y,baseX, baseY) < minDistance)
						{
							structure = structure2;
							minDistance = distBetweenTwoPoints(structure2.x, structure2.y,baseX, baseY);
						}
						structure2 = enumStruct();
					}
					count = count + 1;
				}

				if(structure != NULLOBJECT)
				{
					//select best X coordinates
					if(structure.x > tankGroup.x)
					{
						tankMigrationX = structure.x - ((structure.x - tankGroup.x) / 3);
					}
					else
					{
						tankMigrationX = structure.x + ((tankGroup.x - structure.x) / 3);

					}
					//select best Y coordinates
					if(structure.y > tankGroup.y)
					{
						tankMigrationY = structure.y - ((structure.y - tankGroup.y) / 3);
					}
					else
					{
						tankMigrationY = structure.y + ((tankGroup.y - structure.y) / 3);
					}
					//select best place for units gathering
					boolResult = pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);


					//NOW WE HAVE A SPOT, FORCE WHOLE GROUP TO MOVE
					initIterateGroup(tankGroup);
					droid =  iterateGroup(tankGroup);
					while(droid != NULLOBJECT)
					{
						//activate attack behaviour
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_HOLD);
						orderDroid(droid, DORDER_STOP);
						orderDroidLoc(droid, DORDER_MOVE, tankMigrationX,tankMigrationY);
						lastTankMove = gameTime;
						droid =  iterateGroup(tankGroup);
					}

					//ACTIVATE SUBINIT1
					tankSubInitBool1 = TRUE;
					tankMigrationBool1 = FALSE;
				}
				else
				{
					//NO BIG STRUCTURE TARGETS LEFT, CLEAN UP :p
					tankMigrationX = tankGroup.x;
					tankMigrationY = tankGroup.y;
					pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
					tankSubInitBool1 = TRUE;
					tankMigrationBool1 = FALSE;
				}
			}
			else
			{
				//DEACTIVATE - NO TARGETS AT ALL
				tankActive = FALSE;
				tankSubInitBool1 = FALSE;
				tankSubInitBool2 = FALSE;
				tankAntiUnit1 = FALSE;
				tankPosBool1 = FALSE;
				tankMigrationBool1 = FALSE;
				targetPl= -1;
			}
		}
	}
}


////// SUBINIT 1
event tank_AAS_SUBINIT1(emulateZeroWaitTr)      //ALWAYS ON
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_SUBINIT1,inactive);
	}
	else
	{
		if(tankSubInitBool1)
		{
			count = 0;
			initIterateGroup(tankGroup);
			droid =  iterateGroup(tankGroup);
			while(droid != NULLOBJECT)
			{
				if( (distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) < 1536) )
				{
					count = count + 1;
				}
				else
				{
					if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
					{
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_HOLD);
						orderDroidLoc(droid, DORDER_MOVE, tankMigrationX,tankMigrationY);
						lastTankMove = gameTime;
					}
				}
				droid =  iterateGroup(tankGroup);
			}
			if( (count >= (tankGroup.members / 3*2)) or ( idleGroup(tankGroup) > tankGroup.members / 3*2) )
			{
				//ACTIVATE POSITIONING
				tankSubInitBool1 = FALSE;
				tankPosBool1 = TRUE;
			}

		}
	}
}


////// POSITIONING
event tank_AAS_POSITIONING(emulateZeroWaitTr)   //ALWAYS ON (WAIT,0 - EMULATION)
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_POSITIONING,inactive);
	}
	else
	{
		if(tankPosBool1)
		{
			count = 99999999;
			droid2 = NULLOBJECT;
			initIterateGroup(tankGroup);
			droid =  iterateGroup(tankGroup);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) <  count)
				{
					droid2  = droid;
					count = distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY);
				}
				droid =  iterateGroup(tankGroup);
			}

			// TRY SELECT TARGET BUT IGNORE DECOYS
			count = 0;
			minDistance = 99999999;
			tankTarget = NULLOBJECT;

			while(count < numGroundTargets && targetPl !=-1 )
			{
				ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.36 " & targetPl, player);
				initEnumStruct(FALSE,structureTargets[count],targetPl,targetPl);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(structureComplete(structure) == TRUE)
					{
						if(droid2 != NULLOBJECT)
						{
							if(distBetweenTwoPoints( structure.x, structure.y,droid2.x, droid2.y) < minDistance)
							{
								minDistance = distBetweenTwoPoints(structure.x, structure.y,droid2.x, droid2.y);
								tankTarget = structure;
							}
						}
						else
						{
							if(distBetweenTwoPoints( structure.x, structure.y,tankGroup.x, tankGroup.y) < minDistance)
							{
								minDistance = distBetweenTwoPoints(structure.x, structure.y,tankGroup.x, tankGroup.y);
								tankTarget = structure;
							}
						}
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			// SELECT TARGET EVEN DECOYS
			if(tankTarget == NULLOBJECT)
			{
				count = 0;
				minDistance = 99999999;
				tankTarget = NULLOBJECT;
				while(count < numGroundTargets && targetPl != -1)
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.37 " & targetPl, player);
					initEnumStruct(FALSE,structureTargets[count],targetPl,targetPl);
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure.x, structure.y,baseX, baseY) < minDistance)
						{
							minDistance = distBetweenTwoPoints(structure.x, structure.y,baseX, baseY);
							tankTarget = structure;
						}
						structure = enumStruct();
					}
					count = count + 1;
				}
			}

			if(tankTarget == NULLOBJECT)
			{
				//ATTACK TANKS FIRST
				tankMigrationX = tankGroup.x;
				tankMigrationY = tankGroup.y;
				pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
				tankTarget = NULLOBJECT;
				//ACTIVATE AT
				tankAntiUnit1 = TRUE;
				tankPosBool1 = FALSE;
				tankUnitAttacked = 0;
			}
			else
			{

				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(tankGroup);
				droid =  iterateGroup(tankGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY);
					}
					droid =  iterateGroup(tankGroup);
				}

				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = tankMigrationX;
					rectFixY =  tankMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
				//check attack priority, attack structures or tanks first?
				if(rectValid == 1)
				{
					if( numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2 ) <= numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1,rectFixX2,rectFixY2) / 3 )
					{
						//NOW WE HAVE A TARGET, FORCE WHOLE GROUP TO ATTACK STRUCTURE AND STORE NEW COORDS
						if(tankTarget != NULLOBJECT)
						{
							tankMigrationX = tankTarget.x;
							tankMigrationY = tankTarget.y;
						}
						else
						{
							tankMigrationX = tankGroup.x;
							tankMigrationY = tankGroup.y;
							pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
						}
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							if(distBetweenTwoPoints(droid.x, droid.y,tankTarget.x, tankTarget.y) <  4480)
							{
								if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == tankTarget.x) and (droid.ordery == tankTarget.y)) ) )
								{
									orderDroidObj(droid, DORDER_ATTACK, tankTarget);
									lastGroundAttack = gameTime ;
									lastTankMove = gameTime;

								}
							}
							else
							{
								if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )

								{
									orderDroidLoc(droid, DORDER_MOVE, tankTarget.x,tankTarget.y);
									lastTankMove = gameTime;
								}
							}
							droid =  iterateGroup(tankGroup);
						}
						//ACTIVATE SUBINIT2
						tankSubInitBool2 = TRUE;
						tankPosBool1 = FALSE;
						tankUnitAttacked = 0;
					}
					else
					{
						//ATTACK TANKS FIRST
						if(tankTarget != NULLOBJECT)
						{
							tankMigrationX = tankTarget.x;
							tankMigrationY = tankTarget.y;
						}
						else
						{
							tankMigrationX = tankGroup.x;
							tankMigrationY = tankGroup.y;
							pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
						}
						tankTarget = NULLOBJECT;
						//ACTIVATE AT
						tankAntiUnit1 = TRUE;
						tankPosBool1 = FALSE;
						tankUnitAttacked = 0;
					}
				}
				else
				{
					tankMigrationX = tankGroup.x;
					tankMigrationY = tankGroup.y;
					pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
					//ACTIVATE SUBINIT2
					tankSubInitBool2 = TRUE;
					tankPosBool1 = FALSE;
					tankUnitAttacked = 0;
				}
			}
		}
	}
}

////// SUBINIT 2
event tank_AAS_SUBINIT2(emulateZeroWaitTr)      //ALWAYS ON
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_SUBINIT2,inactive);
	}
	else
	{
		if(tankSubInitBool2)
		{
			if(tankTarget == NULLOBJECT)    //target destroyed (we still have migration coords, so why not use this creatively ;)
			{
				tankSubInitBool2 = FALSE;
				tankAntiUnit1 = TRUE;
				tankUnitAttacked = 0;
			}
			else
			{
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(tankGroup);
				droid =  iterateGroup(tankGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY);
					}
					droid =  iterateGroup(tankGroup);
				}
				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = tankMigrationX;
					rectFixY =  tankMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
				if(rectValid == 1)
				{
					if( numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) <= numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 3*2 )
					{
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							if(distBetweenTwoPoints(droid.x, droid.y,tankTarget.x, tankTarget.y) <  4480)
							{
								if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == tankTarget.x) and (droid.ordery == tankTarget.y)) ) )
								{
									orderDroidObj(droid, DORDER_ATTACK, tankTarget);
									lastGroundAttack = gameTime ;
									lastTankMove = gameTime;
								}
							}
							else
							{
								if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
								{
									orderDroidLoc(droid, DORDER_MOVE, tankTarget.x,tankTarget.y);
									lastTankMove = gameTime;
								}
							}
							droid =  iterateGroup(tankGroup);
						}
					}
					else
					{
						// we are ambushed by units
						if(droid2 != NULLOBJECT)
						{
							tankMigrationX = droid2.x;
							tankMigrationY = droid2.y;
						}
						else
						{
							tankMigrationX = tankGroup.x;
							tankMigrationY = tankGroup.y;
							pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);

						}
						tankTarget = NULLOBJECT;
						tankSubInitBool2 = FALSE;
						tankAntiUnit1 = TRUE;
						tankUnitAttacked = 0;
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order == DORDER_ATTACK)
							{
								orderDroid(droid, DORDER_STOP);
							}
							droid =  iterateGroup(tankGroup);
						}
					}
				}
			}
		}
	}
}

////// ANTI-TANK
event tank_AAS_AT1(emulateZeroWaitTr)   //ALWAYS ON
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_AT1,inactive);
	}
	else
	{
		if(tankAntiUnit1)
		{
			if(tankTarget == NULLOBJECT)
			{
				//// SIEGE STANCE ////
				tankUnitAttacked = tankUnitAttacked + 1;
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(tankGroup);
				droid =  iterateGroup(tankGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY);
					}
					droid =  iterateGroup(tankGroup);
				}
				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = tankMigrationX;
					rectFixY =  tankMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT


				if(rectValid == 1)
				{
					count4 = 3;
					if( (numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 2) < numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) )       {       count4 = 2;     }
					if(numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) >( numStructsButNotWallsInArea(targetPl,rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 2) ) {       count4 = 9;     }
					if(numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) >( numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 3) )        {       count4 = 14;    }
					droid =  droidTargetInArea(targetPl,-1,rectFixX1,rectFixY1, rectFixX2,rectFixY2);
					if((droid != NULLOBJECT) and (tankUnitAttacked < count4))
					{
						if(isVtol(droid) == FALSE)
						{
							tankTarget = droid;
							initIterateGroup(tankGroup);
							droid =  iterateGroup(tankGroup);
							while(droid != NULLOBJECT)
							{
								if(distBetweenTwoPoints(droid.x, droid.y,tankTarget.x, tankTarget.y) <  4480)
								{
									if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == tankTarget.x) and (droid.ordery == tankTarget.y)) ) )
									{
										orderDroidObj(droid, DORDER_ATTACK, tankTarget);
										lastGroundAttack = gameTime ;
										lastTankMove = gameTime;
									}
								}
								else
								{
									if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
									{
										orderDroidLoc(droid, DORDER_MOVE, tankTarget.x,tankTarget.y);
										lastTankMove = gameTime;
									}
								}
								droid =  iterateGroup(tankGroup);
							}
						}
						else
						{
							//ACTIVATE OVERRUN
							tankPosBool1 = TRUE;
							tankAntiUnit1= FALSE;
						}
					}
					else
					{
						//ACTIVATE OVERRUN
						tankPosBool1 = TRUE;
						tankAntiUnit1= FALSE;
					}
				}
				else
				{
					//ACTIVATE OVERRUN
					tankPosBool1 = TRUE;
					tankAntiUnit1= FALSE;
				}
			}
			else
			{
				initIterateGroup(tankGroup);
				droid =  iterateGroup(tankGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,tankTarget.x, tankTarget.y) <  4480)
					{
						if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == tankTarget.x) and (droid.ordery == tankTarget.y)) ) )
						{
							orderDroidObj(droid, DORDER_ATTACK, tankTarget);
							lastGroundAttack = gameTime ;
							lastTankMove = gameTime;
						}
					}
					else
					{
						if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
						{
							orderDroidLoc(droid, DORDER_MOVE, tankTarget.x,tankTarget.y);
							lastTankMove = gameTime;
						}
					}
					droid =  iterateGroup(tankGroup);
				}
				// target not in attack range
				if( distBetweenTwoPoints(tankMigrationX,tankMigrationY,tankTarget.x,tankTarget.y)  > 1536)
				{
					tankTarget = NULLOBJECT;
				}
			}
		}
	}
}

event tank_AAS_WITHDRAW(tankMoveTr)             //every, 50
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tank_AAS_WITHDRAW,inactive);
	}
	else
	{
		if(tankActive == TRUE)
		{

			//DETECT CLOSEST ATTACKER
			boolResult = FALSE;
			if((tankTarget != NULLOBJECT) and (tankSubInitBool1 != TRUE) and (tankMigrationBool1  != TRUE))
			{
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(tankGroup);
				droid =  iterateGroup(tankGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,tankMigrationX, tankMigrationY);
					}
					droid =  iterateGroup(tankGroup);
				}

				if(count > 4096)
				{
					tankActive = FALSE;
					tankSubInitBool1 = FALSE;
					tankSubInitBool2 = FALSE;
					tankAntiUnit1 = FALSE;
					tankPosBool1 = FALSE;
					tankMigrationBool1 = FALSE;
				}
			}

			// DETECT ANY POTENTIAL TARGETS
			count2 = 0;
			structure = NULLOBJECT;
			while((count2 < numGroundTargets) and (structure == NULLOBJECT) && (targetPl != -1))
			{
				ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.38 " & targetPl, player);
				initEnumStruct(FALSE,structureTargets[count2],targetPl,targetPl );
				structure = enumStruct();
				count2 = count2 + 1;
			}


			// DETECT THREAT IN BASE
			rectFixX = baseX;
			rectFixY =  baseY;
			rectFixRange = 1024;
/// PRECOMPILED SCRIPT
			rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
			if(rectValid == 1)
			{
				count = 0;
				while(count < 8)
				{
					if((count != player) and (allianceExistsBetween(count, player) == FALSE))
					{
						if(numDroidsInArea(count, rectFixX1,rectFixY1, rectFixX2,rectFixY2) > 6)
						{
							// BASE IN PERIL
							//DEACTIVATE ALL
							tankTarget = NULLOBJECT;
							targetPl= count;
							tankActive = FALSE;
							tankMigrationBool1 = FALSE;
							tankSubInitBool1 = FALSE;
							tankSubInitBool2 = FALSE;
							tankAntiUnit1 = FALSE;
							tankPosBool1 = FALSE;
							tankMigrationX = baseX;
							tankMigrationY = baseY;
							pickStructLocation(factory, ref tankMigrationX, ref tankMigrationY,player);
							if(tankGroup.members > 0)
							{
								lastTankMove = gameTime;
								lastBaseAttacked = gameTime;
							}
						}
					}
					count = count  +1;
				}
			}

			if((tankGroup.members < 4) or (structure == NULLOBJECT) or (gameTime - lastTankMove > 1200))
			{
				//DEACTIVATE ALL
				tankTarget = NULLOBJECT;
				tankActive = FALSE;
				tankMigrationBool1 = FALSE;
				tankSubInitBool1 = FALSE;
				tankSubInitBool2 = FALSE;
				tankAntiUnit1 = FALSE;
				tankPosBool1 = FALSE;
				tankMigrationX = baseX;
				tankMigrationY = baseY;
				if(structure == NULLOBJECT)
				{
					targetPl= -1;
					// restart even cyborgs
					cyborgTarget  = NULLOBJECT;
					cyborgActive = FALSE;
					cyborgMigrationBool1 = FALSE;
					cyborgSubInitBool1  = FALSE;
					cyborgSubInitBool2   = FALSE;
					cyborgAntiUnit1  = FALSE;
					cyborgPosBool1  = FALSE;
					cyborgMigrationX = baseX;
					cyborgMigrationY = baseY;
				}
			}
		}
	}
}



///////////////////////////////////////////////////
/////  ADVANCED ATTACKING SCRIPT MK-7 /////
/////////////////////// a.k.a. //////////////////////
///////////  "Cyborg Superior Assault Script"   //////////
///////////////////////////////////////////////////
////// INITIALIZATION
event cyborg_AAS_INIT(cyborgInitTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_INIT,inactive);
	}
	else
	{
		if(cyborgActive == FALSE)
		{
			// stop everything just in case
			cyborgActive = FALSE;
			cyborgMigrationBool1 = FALSE;
			cyborgAntiUnit1  = FALSE;
			cyborgSubInitBool2   = FALSE;
			cyborgPosBool1  = FALSE;
			cyborgSubInitBool1  = FALSE;
			cyborgTarget  = NULLOBJECT;

			count = random(8);
			if( (cyborgGroup.members >= (6 + count)) and (gameTime - lastBaseAttacked > 600) )
			{
				//START MIGRATION
				randomiseSeed();        //this randomisation will differ for ach AI
				cyborgActive = TRUE;
				cyborgMigrationBool1 = TRUE;
				cyborgAntiUnit1  = FALSE;
				cyborgSubInitBool2   = FALSE;
				cyborgPosBool1  = FALSE;
				cyborgSubInitBool1  = FALSE;
			}
			else
			{
				if(cyborgGroup.members > 0)
				{
					boolResult = FALSE;
					structure = getStructure(factory, player);
					if(structure == NULLOBJECT)
					{
						structure = getStructure(playerHQ, player);
					}
					if(structure != NULLOBJECT)
					{
						buildX = structure.x;
						buildY = structure.y;
						boolResult = pickStructLocation(factory,ref buildX,ref buildY, player);
					}
					if((boolResult == TRUE) and (distBetweenTwoPoints(buildX, buildY,cyborgGroup.x, cyborgGroup.y) > 1200))
					{
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
							if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
							{
								orderDroidLoc(droid, DORDER_MOVE, buildX,buildY);
							}

							droid =  iterateGroup(cyborgGroup);
						}
					}
					else
					{
						buildX = cyborgGroup.x;
						buildY = cyborgGroup.y;
						boolResult = pickStructLocation(factory,ref buildX,ref buildY, player);
						if(boolResult == TRUE)
						{
							initIterateGroup(cyborgGroup);
							droid =  iterateGroup(cyborgGroup);
							while(droid != NULLOBJECT)
							{
								setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
								{
									orderDroidLoc(droid, DORDER_MOVE, buildX,buildY);
								}
								droid =  iterateGroup(cyborgGroup);
							}
						}
						else
						{
							orderGroupLoc(cyborgGroup, DORDER_MOVE, cyborgGroup.x, cyborgGroup.y);
						}
					}
				}
			}
		}
	}
}

////// MIGRATION
event cyborg_AAS_MIGRATION(emulateZeroWaitTr)   //ALWAYS ON (WAIT,0 - EMULATION)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_MIGRATION,inactive);
	}
	else
	{
		if(cyborgMigrationBool1)
		{
			boolResult3 = TRUE;
			//SELECT A PLAYER FOR ATTACK RUN
			if(targetPl != -1)
			{
				// DETECT ANY POTENTIAL TARGETS
				count2 = 0;
				structure = NULLOBJECT;
				while((count2 < numGroundTargets) and (structure == NULLOBJECT) && (targetPl != -1 ) )
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.39 " & targetPl, player);
					initEnumStruct(FALSE,structureTargets[count2],targetPl,targetPl );
					structure = enumStruct();
					count2 = count2 + 1;
				}
				if(structure == NULLOBJECT)
				{
					targetPl = -1; // target invalid
				}
			}


			count = 0;
			plCount = 0;
			while(count < 8)
			{
				// DETECT ANY POTENTIAL TARGETS
				count2 = 0;
				structure = NULLOBJECT;
				while((count2 < numGroundTargets) and (structure == NULLOBJECT))
				{
					ASSERT(count >= 0 and count < 8,        "player out of bounds:.40 " & count, player);
					initEnumStruct(FALSE,structureTargets[count2],count,count);
					structure = enumStruct();
					count2 = count2 + 1;
				}
				if((structure != NULLOBJECT) and (count != player) and (allianceExistsBetween(count, player) == FALSE))
				{
					plNum[plCount] = count ;
					plCount = plCount + 1;
				}
				count = count + 1;
			}
			if((targetPl == -1) and (plCount > 0))
			{
				targetPl =  plNum[random(plCount)];
			}

			//SELECT BEST MIGRATION SPOT
			if(targetPl >-1)
			{
				count = 0;
				structure = NULLOBJECT;
				minDistance = 99999999;
				while(count < numCyborgGroundTargets) // initial
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.41 " & targetPl, player);
					initEnumStruct(FALSE,structureTargets[count],targetPl,targetPl);
					structure2 = enumStruct();
					while(structure2 != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure2.x, structure2.y,baseX, baseY) < minDistance)
						{
							structure = structure2;
							minDistance = distBetweenTwoPoints(structure2.x, structure2.y,baseX, baseY);
						}
						structure2 = enumStruct();
					}
					count = count + 1;
				}

				if(structure != NULLOBJECT)
				{
					//select best X coordinates
					if(structure.x > cyborgGroup.x)
					{
						cyborgMigrationX = structure.x - ((structure.x - cyborgGroup.x) / 3);
					}
					else
					{
						cyborgMigrationX = structure.x + ((cyborgGroup.x - structure.x) / 3);

					}
					//select best Y coordinates
					if(structure.y > cyborgGroup.y)
					{
						cyborgMigrationY = structure.y - ((structure.y - cyborgGroup.y) / 3);
					}
					else
					{
						cyborgMigrationY = structure.y + ((cyborgGroup.y - structure.y) / 3);
					}
					//select best place for units gathering
					boolResult = pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);


					//NOW WE HAVE A SPOT, FORCE WHOLE GROUP TO MOVE
					initIterateGroup(cyborgGroup);
					droid =  iterateGroup(cyborgGroup);
					while(droid != NULLOBJECT)
					{
						//activate attack behaviour
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_HOLD);
						orderDroid(droid, DORDER_STOP);
						orderDroidLoc(droid, DORDER_MOVE, cyborgMigrationX,cyborgMigrationY);
						lastCybMove  = gameTime;
						droid =  iterateGroup(cyborgGroup);
					}

					//ACTIVATE SUBINIT1
					cyborgSubInitBool1  = TRUE;
					cyborgMigrationBool1 = FALSE;
				}
				else
				{
					//NO BIG STRUCTURE TARGETS LEFT, CLEAN UP :p
					cyborgMigrationX = cyborgGroup.x;
					cyborgMigrationY = cyborgGroup.y;
					pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
					cyborgSubInitBool1  = TRUE;
					cyborgMigrationBool1 = FALSE;
				}
			}
			else
			{
				//DEACTIVATE - NO TARGETS AT ALL
				cyborgActive = FALSE;
				cyborgSubInitBool1  = FALSE;
				cyborgSubInitBool2   = FALSE;
				cyborgAntiUnit1  = FALSE;
				cyborgPosBool1  = FALSE;
				cyborgMigrationBool1 = FALSE;
				targetPl= -1;
			}
		}
	}
}


////// SUBINIT 1
event cyborg_AAS_SUBINIT1(emulateZeroWaitTr)    //ALWAYS ON
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_SUBINIT1,inactive);
	}
	else
	{
		if(cyborgSubInitBool1 )
		{
			count = 0;
			initIterateGroup(cyborgGroup);
			droid =  iterateGroup(cyborgGroup);
			while(droid != NULLOBJECT)
			{
				if( (distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) < 1536) )
				{
					count = count + 1;
				}
				else
				{
					if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
					{
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_HOLD);
						orderDroidLoc(droid, DORDER_MOVE, cyborgMigrationX,cyborgMigrationY);
						lastCybMove  = gameTime;
					}
				}
				droid =  iterateGroup(cyborgGroup);
			}
			if( (count >= (cyborgGroup.members / 3*2)) or ( idleGroup(cyborgGroup) > cyborgGroup.members / 3*2) )
			{
				//ACTIVATE POSITIONING
				cyborgSubInitBool1  = FALSE;
				cyborgPosBool1  = TRUE;
			}

		}
	}
}


////// POSITIONING
event cyborg_AAS_POSITIONING(emulateZeroWaitTr) //ALWAYS ON (WAIT,0 - EMULATION)
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_POSITIONING,inactive);
	}
	else
	{
		if(cyborgPosBool1 )
		{
			count = 99999999;
			droid2 = NULLOBJECT;
			initIterateGroup(cyborgGroup);
			droid =  iterateGroup(cyborgGroup);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) <  count)
				{
					droid2  = droid;
					count = distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY);
				}
				droid =  iterateGroup(cyborgGroup);
			}

			// SELECT TARGET EVEN DECOYS
			count = 0;
			minDistance = 99999999;
			cyborgTarget  = NULLOBJECT;
			while( (count < numCyborgGroundTargets) && (targetPl != -1 ))
			{
				ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.42 " & targetPl, player);
				initEnumStruct(FALSE,structureTargets[count],targetPl,targetPl);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(droid2 != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure.x, structure.y,droid2.x, droid2.y) < minDistance)
						{
							minDistance = distBetweenTwoPoints(structure.x, structure.y,droid2.x, droid2.y);
							cyborgTarget  = structure;
						}
					}
					else
					{
						if(distBetweenTwoPoints( structure.x, structure.y,cyborgGroup.x, cyborgGroup.y) < minDistance)
						{
							minDistance = distBetweenTwoPoints(structure.x, structure.y,cyborgGroup.x, cyborgGroup.y);
							cyborgTarget  = structure;
						}
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			if(cyborgTarget  == NULLOBJECT)
			{
				//ATTACK TANKS FIRST
				cyborgMigrationX = cyborgGroup.x;
				cyborgMigrationY = cyborgGroup.y;
				pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
				cyborgTarget  = NULLOBJECT;
				//ACTIVATE AT
				cyborgAntiUnit1  = TRUE;
				cyborgPosBool1  = FALSE;
				cyborgUnitAttacked = 0;
			}
			else
			{

				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(cyborgGroup);
				droid =  iterateGroup(cyborgGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY);
					}
					droid =  iterateGroup(cyborgGroup);
				}

				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = cyborgMigrationX;
					rectFixY =  cyborgMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
				//check attack priority, attack structures or tanks first?
				if(rectValid == 1)
				{
					if( numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2 ) <= numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1,rectFixX2,rectFixY2) / 3 )
					{
						//NOW WE HAVE A TARGET, FORCE WHOLE GROUP TO ATTACK STRUCTURE AND STORE NEW COORDS
						if(cyborgTarget  != NULLOBJECT)
						{
							cyborgMigrationX = cyborgTarget.x;
							cyborgMigrationY = cyborgTarget.y;
						}
						else
						{
							cyborgMigrationX = cyborgGroup.x;
							cyborgMigrationY = cyborgGroup.y;
							pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
						}
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							if(distBetweenTwoPoints(droid.x, droid.y,cyborgTarget.x, cyborgTarget.y) <  4480)
							{
								if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == cyborgTarget.x) and (droid.ordery == cyborgTarget.y)) ) )
								{
									orderDroidObj(droid, DORDER_ATTACK, cyborgTarget );
									lastGroundAttack = gameTime ;
									lastCybMove  = gameTime;

								}
							}
							else
							{
								if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )

								{
									orderDroidLoc(droid, DORDER_MOVE, cyborgTarget.x,cyborgTarget.y);
									lastCybMove  = gameTime;
								}
							}
							droid =  iterateGroup(cyborgGroup);
						}
						//ACTIVATE SUBINIT2
						cyborgSubInitBool2   = TRUE;
						cyborgPosBool1  = FALSE;
						cyborgUnitAttacked = 0;
					}
					else
					{
						//ATTACK TANKS FIRST
						if(cyborgTarget  != NULLOBJECT)
						{
							cyborgMigrationX = cyborgTarget.x;
							cyborgMigrationY = cyborgTarget.y;
						}
						else
						{
							cyborgMigrationX = cyborgGroup.x;
							cyborgMigrationY = cyborgGroup.y;
							pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
						}
						cyborgTarget  = NULLOBJECT;
						//ACTIVATE AT
						cyborgAntiUnit1  = TRUE;
						cyborgPosBool1  = FALSE;
						cyborgUnitAttacked = 0;
					}
				}
				else
				{
					cyborgMigrationX = cyborgGroup.x;
					cyborgMigrationY = cyborgGroup.y;
					pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
					//ACTIVATE SUBINIT2
					cyborgSubInitBool2   = TRUE;
					cyborgPosBool1  = FALSE;
					cyborgUnitAttacked = 0;
				}
			}
		}
	}
}

////// SUBINIT 2
event cyborg_AAS_SUBINIT2(emulateZeroWaitTr)    //ALWAYS ON
{

	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_SUBINIT2,inactive);
	}
	else
	{
		if(cyborgSubInitBool2  )
		{
			if(cyborgTarget  == NULLOBJECT) //target destroyed (we still have migration coords, so why not use this creatively ;)
			{
				cyborgSubInitBool2   = FALSE;
				cyborgAntiUnit1  = TRUE;
				cyborgUnitAttacked = 0;
			}
			else
			{
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(cyborgGroup);
				droid =  iterateGroup(cyborgGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY);
					}
					droid =  iterateGroup(cyborgGroup);
				}
				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = cyborgMigrationX;
					rectFixY =  cyborgMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
				if(rectValid == 1)
				{
					if( numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) <= numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 3*2 )
					{
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							if(distBetweenTwoPoints(droid.x, droid.y,cyborgTarget.x, cyborgTarget.y) <  4480)
							{
								if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == cyborgTarget.x) and (droid.ordery == cyborgTarget.y)) ) )
								{
									orderDroidObj(droid, DORDER_ATTACK, cyborgTarget );
									lastGroundAttack = gameTime ;
									lastCybMove  = gameTime;
								}
							}
							else
							{
								if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
								{
									orderDroidLoc(droid, DORDER_MOVE, cyborgTarget.x,cyborgTarget.y);
									lastCybMove  = gameTime;
								}
							}
							droid =  iterateGroup(cyborgGroup);
						}
					}
					else
					{
						// we are ambushed by units
						if(droid2 != NULLOBJECT)
						{
							cyborgMigrationX = droid2.x;
							cyborgMigrationY = droid2.y;
						}
						else
						{
							cyborgMigrationX = cyborgGroup.x;
							cyborgMigrationY = cyborgGroup.y;
							pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);

						}
						cyborgTarget  = NULLOBJECT;
						cyborgSubInitBool2   = FALSE;
						cyborgAntiUnit1  = TRUE;
						cyborgUnitAttacked = 0;
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order == DORDER_ATTACK)
							{
								orderDroid(droid, DORDER_STOP);
							}
							droid =  iterateGroup(cyborgGroup);
						}
					}
				}
			}
		}
	}
}

////// ANTI-TANK
event cyborg_AAS_AT1(emulateZeroWaitTr) //ALWAYS ON
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_AT1,inactive);
	}
	else
	{
		if(cyborgAntiUnit1 )
		{
			if(cyborgTarget  == NULLOBJECT)
			{
				//// SIEGE STANCE ////
				cyborgUnitAttacked = cyborgUnitAttacked + 1;
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(cyborgGroup);
				droid =  iterateGroup(cyborgGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY);
					}
					droid =  iterateGroup(cyborgGroup);
				}
				if(droid2 != NULLOBJECT)
				{
					rectFixX = droid2.x;
					rectFixY =  droid2.y;
				}
				else
				{
					rectFixX = cyborgMigrationX;
					rectFixY =  cyborgMigrationY;
				}
				rectFixRange = 640;
/// PRECOMPILED SCRIPT
				rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT


				if(rectValid == 1)
				{
					count4 = 3;
					if( (numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 2) < numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) )       {       count4 = 2;     }
					if(numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) >( numStructsButNotWallsInArea(targetPl,rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 2) ) {       count4 = 9;     }
					if(numDroidsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) >( numStructsButNotWallsInArea(targetPl, rectFixX1,rectFixY1, rectFixX2,rectFixY2) / 3) )        {       count4 = 14;    }
					droid =  droidTargetInArea(targetPl,-1,rectFixX1,rectFixY1, rectFixX2,rectFixY2);
					if((droid != NULLOBJECT) and (cyborgUnitAttacked < count4))
					{
						if(isVtol(droid) == FALSE)
						{
							cyborgTarget  = droid;
							initIterateGroup(cyborgGroup);
							droid =  iterateGroup(cyborgGroup);
							while(droid != NULLOBJECT)
							{
								if(distBetweenTwoPoints(droid.x, droid.y,cyborgTarget.x, cyborgTarget.y) <  4480)
								{
									if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == cyborgTarget.x) and (droid.ordery == cyborgTarget.y)) ) )
									{
										orderDroidObj(droid, DORDER_ATTACK, cyborgTarget );
										lastGroundAttack = gameTime ;
										lastCybMove  = gameTime;
									}
								}
								else
								{
									if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
									{
										orderDroidLoc(droid, DORDER_MOVE, cyborgTarget.x,cyborgTarget.y);
										lastCybMove  = gameTime;
									}
								}
								droid =  iterateGroup(cyborgGroup);
							}
						}
						else
						{
							//ACTIVATE OVERRUN
							cyborgPosBool1  = TRUE;
							cyborgAntiUnit1 = FALSE;
						}
					}
					else
					{
						//ACTIVATE OVERRUN
						cyborgPosBool1  = TRUE;
						cyborgAntiUnit1 = FALSE;
					}
				}
				else
				{
					//ACTIVATE OVERRUN
					cyborgPosBool1  = TRUE;
					cyborgAntiUnit1 = FALSE;
				}
			}
			else
			{
				initIterateGroup(cyborgGroup);
				droid =  iterateGroup(cyborgGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,cyborgTarget.x, cyborgTarget.y) <  4480)
					{
						if((droid.order != DORDER_ATTACK) and (not ((droid.orderx == cyborgTarget.x) and (droid.ordery == cyborgTarget.y)) ) )
						{
							orderDroidObj(droid, DORDER_ATTACK, cyborgTarget );
							lastGroundAttack = gameTime ;
							lastCybMove  = gameTime;
						}
					}
					else
					{
						if( (droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) and (gameTime - lastBaseAttacked > 300) )
						{
							orderDroidLoc(droid, DORDER_MOVE, cyborgTarget.x,cyborgTarget.y);
							lastCybMove  = gameTime;
						}
					}
					droid =  iterateGroup(cyborgGroup);
				}
				// target not in attack range
				if( distBetweenTwoPoints(cyborgMigrationX,cyborgMigrationY,cyborgTarget.x,cyborgTarget.y)  > 1536)
				{
					cyborgTarget  = NULLOBJECT;
				}
			}
		}
	}
}

event cyborg_AAS_WITHDRAW(cyborgMoveTr)         //every, 50
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(cyborg_AAS_WITHDRAW,inactive);
	}
	else
	{
		if(cyborgActive == TRUE)
		{

			//DETECT CLOSEST ATTACKER
			boolResult = FALSE;
			if((cyborgTarget  != NULLOBJECT) and (cyborgSubInitBool1  != TRUE) and (cyborgMigrationBool1  != TRUE))
			{
				// Determine attack head -> droid2
				count = 99999999;
				droid2 = NULLOBJECT;
				initIterateGroup(cyborgGroup);
				droid =  iterateGroup(cyborgGroup);
				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY) <  count)
					{
						droid2  = droid;
						count = distBetweenTwoPoints(droid.x, droid.y,cyborgMigrationX, cyborgMigrationY);
					}
					droid =  iterateGroup(cyborgGroup);
				}

				if(count > 4096)
				{
					cyborgActive = FALSE;
					cyborgSubInitBool1  = FALSE;
					cyborgSubInitBool2   = FALSE;
					cyborgAntiUnit1  = FALSE;
					cyborgPosBool1  = FALSE;
					cyborgMigrationBool1 = FALSE;
				}
			}

			// DETECT ANY POTENTIAL TARGETS
			count2 = 0;
			structure = NULLOBJECT;
			while((count2 < numGroundTargets) and (structure == NULLOBJECT) && (targetPl != -1 ) )
			{
				ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.43 " & targetPl, player);
				initEnumStruct(FALSE,structureTargets[count2],targetPl,targetPl );
				structure = enumStruct();
				count2 = count2 + 1;
			}


			// DETECT THREAT IN BASE
			rectFixX = baseX;
			rectFixY =  baseY;
			rectFixRange = 1024;
/// PRECOMPILED SCRIPT
			rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
			if(rectValid == 1)
			{
				count = 0;
				while(count < 8)
				{
					if((count != player) and (allianceExistsBetween(count, player) == FALSE))
					{
						if(numDroidsInArea(count, rectFixX1,rectFixY1, rectFixX2,rectFixY2) > 6)
						{
							// BASE IN PERIL
							//DEACTIVATE ALL
							cyborgTarget  = NULLOBJECT;
							targetPl= count;
							cyborgActive = FALSE;
							cyborgMigrationBool1 = FALSE;
							cyborgSubInitBool1  = FALSE;
							cyborgSubInitBool2   = FALSE;
							cyborgAntiUnit1  = FALSE;
							cyborgPosBool1  = FALSE;
							cyborgMigrationX = baseX;
							cyborgMigrationY = baseY;
							pickStructLocation(factory, ref cyborgMigrationX, ref cyborgMigrationY,player);
							if(cyborgGroup.members > 0)
							{
								lastCybMove  = gameTime;
								lastBaseAttacked = gameTime;
							}
						}
					}
					count = count  +1;
				}
			}

			if((cyborgGroup.members < 3) or (structure == NULLOBJECT) or (gameTime - lastCybMove  > 1200))
			{
				//DEACTIVATE ALL
				cyborgTarget  = NULLOBJECT;
				cyborgActive = FALSE;
				cyborgMigrationBool1 = FALSE;
				cyborgSubInitBool1  = FALSE;
				cyborgSubInitBool2   = FALSE;
				cyborgAntiUnit1  = FALSE;
				cyborgPosBool1  = FALSE;
				cyborgMigrationX = baseX;
				cyborgMigrationY = baseY;
				if(structure == NULLOBJECT)
				{
					targetPl= -1;
					// restart even tanks
					tankTarget  = NULLOBJECT;
					tankActive = FALSE;
					tankMigrationBool1 = FALSE;
					tankSubInitBool1  = FALSE;
					tankSubInitBool2   = FALSE;
					tankAntiUnit1  = FALSE;
					tankPosBool1  = FALSE;
					tankMigrationX = baseX;
					tankMigrationY = baseY;
				}
			}
		}
	}
}

// Research Rules Now does true research.
// do research

event doResearch(doResearchTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(doResearch,     inactive);
	}
	else
	{
		if(playerPower(player) > 100)
		{
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.44 " & player, player);
			initEnumStruct(FALSE,resLab,player,player);
			structure= enumStruct();
			count = 0;
			while(structure != NULLOBJECT)
			{
				skDoResearch(structure,player,1);
				structure= enumStruct();
			}
		}
	}
}

event doResearchLP(doResearchLPTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(doResearch,     inactive);
	}
	else
	{
		if(playerPower(player) > 100)
		{
			facLimit = 255;
		}
		else
		{
			facLimit = 2;
		}
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.45 " & player, player);
		initEnumStruct(FALSE,resLab,player,player);
		structure= enumStruct();
		while( (structure != NULLOBJECT) and (facLimit != 0) )
		{
			skDoResearch(structure,player,1);
			facLimit = facLimit - 1;
			structure= enumStruct();
		}
	}
}


// power management.
// if running low on power research vital power upgrade
event managePower(managePowerTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(managePower,    inactive);
	}
	else
	{
		if( playerPower(player) < 50 )  // research upgrade.
		{
			completeResearch(powerAddOn,player);
			setEventTrigger(managePower,    inactive);
		}
	}
}

/////// VTOLs ////
// build vtol strucutures&rebuild HQ.
event vtolStructs(scoutMainTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtolStructs,inactive);
	}
	else
	{
		if((isStructureAvailable(vtolFactory,player)) and (isStructureAvailable(vtolPad,player)) and (useVtols))
		{
			count = 0;
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.46 " & player, player);
			initEnumStruct(FALSE,vtolFactory,player,player);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				count = count + 1;
				structure = enumStruct();
			}
			count2 = 0;
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.47 " & player, player);
			initEnumStruct(FALSE,vtolPad,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				count2 = count2 + 1;
				structure= enumStruct();
			}
			count3 = 0;
			if((count == 0) and (count2 == 0))
			{
				count3 = 1;
			}


			if((count < 2) and (count2 > 3))
			{
				count3 = 2;
			}

			if((count3 == 2) or (count3 == 1))                                      // if missing build it.
			{
				if(count < 3)
				{
					// build factory
					buildX = baseX;                                                 // pick a location
					buildY = baseY;
					boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						initIterateGroup(buildGroup);           // find idle droids in build group.
						droid = iterateGroup(buildGroup);
						boolResult = FALSE;                                     // only send 1 droid to do the job
						while( (boolResult == FALSE) and (droid != NULLOBJECT))
						{
							if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,vtolFactory, buildX,buildY);
								boolResult = TRUE;
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}

			count4 = 0;
			if((count > 0) and (count2 < 4))
			{
				count4 = 1;
			}

			if((count > 1) and (count2 < 10))
			{
				count4 = 2;
			}


			if((count4 == 2) or (count4 == 1))      // if missing build it.
			{
				if(count2 < 10)
				{
					// build vtol rearm pads.
					buildX = baseX;                                                 // pick a location
					buildY = baseY;
					boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						initIterateGroup(buildGroup);           // find idle droids in build group.
						droid = iterateGroup(buildGroup);
						builddroid = 0;
						while((droid != NULLOBJECT) and (builddroid < 1))
						{
							if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,vtolPad, buildX,buildY);
								builddroid = builddroid  + 1;
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
		// check HQ
		count2 = 0;
		ASSERT(player >= 0 and player < 8,      "player out of bounds:.48 " & player, player);
		initEnumStruct(FALSE,playerHQ,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			count2 = count2 + 1;
			structure= enumStruct();
		}
		if(count2==0)
		{
			// build HQ
			buildX = baseX;                                                 // pick a location
			buildY = baseY;
			boolResult = pickStructLocation(playerHQ, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{
				initIterateGroup(buildGroup);           // find idle droids in build group.
				droid = iterateGroup(buildGroup);
				builddroid = 0;                                         while((droid != NULLOBJECT) and (builddroid < 2))
				{
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,playerHQ, buildX,buildY);
						builddroid = builddroid +1;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
	}
}








////////////////// ADVANCED VTOL PRODUCTION SCRIPT
event SelectRndTemplateVRun(inactive)
{
	if(useVtols) { //GENERAL FEATURE OVERRIDE
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(SelectRndTemplateVRun,inactive);
		}
		else
		{
			if(playerPower(player) > 100)
			{
				facLimit = 255;
			}
			else
			{
				facLimit = 1;
			}
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.49 " & player, player);
			initEnumStruct(FALSE,vtolFactory,player,player);
			structure = enumStruct();
			while( (structure != NULLOBJECT) and (facLimit != 0) )
			{
				if(structureComplete(structure))
				{
					if(structureIdle(structure))
					{
						boolResult = FALSE;
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 5) and (gameTime < 1800))        { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 6) and (gameTime > 1800) and (gameTime < 3600))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 8) and (gameTime > 3600) and (gameTime < 5400))  { boolResult = TRUE; }
						if((buildGroup.members + senseGroup.members + harvesterGroup.members < 9) and (gameTime > 5400))        { boolResult = TRUE; }
						if(boolResult == TRUE) //TRUCK NEEDED
						{
							if((getDroidCount(player) < 80) and (structureIdle(structure) == TRUE))
							{
								boolResult = FALSE; //buildDroid(vtolTruck, structure, player, 1);   //1.11 feature !!
							}
						}

						if(boolResult == FALSE) // NO TRUCK NEEDED
						{
							count3 = numVtols - 1;
							count2 = 0;
							boolResult2 = FALSE;
							while((count2 < numVtols ) and (boolResult2 == FALSE))
							{
								if(skCanBuildTemplate(player,structure, vtols[count2]) == TRUE)
								{
									count3 = count2;
									boolResult2 = TRUE;
								}
								count2 = count2 + 1;
							}

							count2 = 0;
							count4 = 0;
							boolResult2 = FALSE;
							if(count3 >= numVtols - 2)
							{
								count2 = numVtols - count3;
							}
							else
							{
								count2 = 2;
							}

							count4 = random(count2);
							count = count3 + count4;

							if((getDroidCount(player) < 80) and ( vtolGroup.members + vtolUnitGroup.members < 14) and (structureIdle(structure) == TRUE) and (skCanBuildTemplate(player,structure, vtols[count]) == TRUE ))
							{
								buildDroid(vtols[count],structure,player,1); //build droid
							}
						}
					}
					facLimit = facLimit - 1;
				}
				structure = enumStruct();
			}
		}
	}
}
event SelectRndTemplateV(cyborgBuildEventTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(SelectRndTemplateVRun,inactive);
	}
	else
	{
		setEventTrigger(SelectRndTemplateVRun,cyborgAttackTr1);
	}
}



/////////////////////////////////////////////////////////////////////////////////
/////////////////////// TOTAL CONTROL SCRIPT: //////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///////////////// VTOL&NEXUS TOTAL CONTROL SCRIPT  /////////////////////
/////////////////////////////////////////////////////////////////////////////////

///////////////////////////////
// KEEP TARGETS (LIST OF AVAILABLE TARGETS)
///////////////////////////////////////////////////////////////////
event intruderDetected(vtolDefendTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(intruderDetected,inactive);
	}
	else
	{
		if(baseobj != NULLOBJECT)
		{
			if(baseobj.type == OBJ_DROID)
			{
				droid = objToDroid(baseobj);
				if(droid != NULLOBJECT)
				{
					///////////////////
					//// IF targetPl NOT SET - PUNISH THE OFFENDER
					if((targetPl == -1) and (droid.player != player) and (allianceExistsBetween(droid.player, player) == FALSE))
					{
						targetPl = droid.player;
					}



					if((droid.player != player) and (WhosMyLord != droid.player) and (allianceExistsBetween(droid.player,player) == FALSE))
					{
						boolResult = FALSE;
						structure = getStructure(playerHQ, droid.player);
						boolResult = FALSE;
						if(isVtol(droid) == TRUE)
						{
							boolResult = TRUE;
						}

						if(structure != NULLOBJECT)
						{
							if(distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y) < 2100 )
							{
								boolResult = TRUE;
							}
						}

						if(boolResult == FALSE)
						{
							count = 0;
							while((boolResult2 == FALSE) and (count < 10))
							{                                                       if(seenUnitArray[count] == NULLOBJECT)                                                                                  {
															count3 = 0;
															boolResult3 = FALSE;
															while(count3 < 10)
															{
																if(seenUnitArray[count3] == droid )
																{
																	boolResult3 = TRUE;
																}
																count3 = count3 + 1;
															}

															if(boolResult3 == FALSE)
															{
																seenUnitArray[count] = droid;                                                                                                   boolResult2 = TRUE;
																targetExpire[count] = gameTime;
															}
															else
															{
																boolResult2 = TRUE;
															}
														}
								                                                count = count + 1;}
						}
					}
				}
			}
		}
	}
}



event newObjectReport(newDroidReportTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(newObjectReport,inactive);
	}
	else
	{
		if(droid != NULLOBJECT)
		{
			if((droid.player != player) and (WhosMyLord != droid.player) and (allianceExistsBetween(droid.player,player) == FALSE))
			{
				boolResult = FALSE;
				structure = getStructure(playerHQ, droid.player);
				boolResult = FALSE;
				if(isVtol(droid) == TRUE)
				{
					boolResult = TRUE;
				}

				if(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y) < 2100 )
					{
						boolResult = TRUE;
					}
				}

				if(boolResult == FALSE)
				{
					count = 0;
					while((boolResult2 == FALSE) and (count < 10))
					{
						if(seenUnitArray[count] == NULLOBJECT)
						{
							count3 = 0;
							boolResult3 = FALSE;
							while(count3 < 10)
							{
								if(seenUnitArray[count3] == droid )
								{
									boolResult3 = TRUE;
								}
								count3 = count3 + 1;
							}

							if(boolResult3 == FALSE)
							{
								seenUnitArray[count] = droid;
								boolResult2 = TRUE;
								targetExpire[count] = gameTime;
							}
							else
							{
								boolResult2 = TRUE;
							}
						}
						count = count + 1;
					}
				}
			}
		}
	}
}




///////////////////////////////
// NEXUS FIRST - SEND NEXUS TEAM
///////////////////////////////////////////////////////////////////
event sendNEXUS(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(sendNEXUS,inactive);
	}
	else
	{
		if(nexusGroup.members > 0)
		{
////Target list recheck
			while(count < 10)
			{
				if(seenUnitArray[count] != NULLOBJECT)
				{
					structure = getStructure(playerHQ, seenUnitArray[count].player);
					if(structure != NULLOBJECT)
					{
						if((seenUnitArray[count].player == player) or (seenUnitArray[count].player == WhosMyLord) or (allianceExistsBetween(seenUnitArray[count].player,player) == TRUE) or (distBetweenTwoPoints(structure.x, structure.y, seenUnitArray[count].x, seenUnitArray[count].y) < 2100))
						{
							seenUnitArray[count] = NULLOBJECT;
							if(lastNEXUSArray == count)
							{
								lastNEXUSArray = -1;
								orderGroup(nexusGroup,DORDER_RTB);
							}
						}
					}
					else
					{
						if((seenUnitArray[count].player == player) or (seenUnitArray[count].player == WhosMyLord) or (allianceExistsBetween(seenUnitArray[count].player,player) == TRUE))
						{
							seenUnitArray[count] = NULLOBJECT;
							if(lastNEXUSArray == count)
							{
								lastNEXUSArray = -1;
								orderGroup(nexusGroup,DORDER_RTB);
							}
						}

					}

				}
				else
				{
					if(lastNEXUSArray == count)
					{
						lastNEXUSArray = -1;
						orderGroup(nexusGroup,DORDER_RTB);
					}
				}
				count = count + 1;
			}

//// Attack !!!
			boolResult = FALSE;
			boolResult2 = FALSE;
			boolResult3 = FALSE;
			count = 0;
			count2 = 0;

			if(lastNEXUSArray != -1)
			{
				if(seenUnitArray[lastNEXUSArray] != NULLOBJECT)
				{
					initIterateGroup(nexusGroup);
					droid = iterateGroup(nexusGroup);
					while(droid != NULLOBJECT)
					{

// if((droid.order == DORDER_NONE) or (droid.order == DORDER_STOP) or (droid.order == DORDER_RTB) or (droid.order == DORDER_RTR))

						if(droid.order != DORDER_MOVE)
						{
							if(distBetweenTwoPoints(droid.x,droid.y,seenUnitArray[lastNEXUSArray].x,seenUnitArray[lastNEXUSArray].y) < linkRange*128)
							{
								orderDroidObj(droid,DORDER_ATTACK,seenUnitArray[lastNEXUSArray] );
							}
							else
							{
								orderDroidLoc(droid,DORDER_MOVE,seenUnitArray[lastNEXUSArray].x,seenUnitArray[lastNEXUSArray].y);
							}
							//if(isHumanPlayer(player) == FALSE)
							//{
							//resetPlayerVisibility(player);
							//}
						}
						droid = iterateGroup(nexusGroup);
					}
				}
				else
				{
					lastNEXUSArray  = -1;
				}
			}
			else
			{
				initIterateGroup(nexusGroup);
				droid = iterateGroup(nexusGroup);
				while(droid != NULLOBJECT)
				{
					//// Select last target from array
					boolResult = FALSE;
					count = 9;
					while((count > -1) and (boolResult == FALSE))
					{
						if(seenUnitArray[count] != NULLOBJECT)
						{
							orderDroidObj(droid, DORDER_ATTACK,seenUnitArray[count]);
							lastNEXUSArray = count;
							boolResult = TRUE;
						}
						count = count - 1;
					}
					droid = iterateGroup(nexusGroup);
				}
			}
		}
	}
	setEventTrigger(sendNEXUS,inactive);
}


event sendNEXUSACTIVATE(NEXUSTeamGoTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(sendNEXUSACTIVATE,inactive);
	}
	else
	{
		setEventTrigger(sendNEXUS,vtolAttackTr1);
	}
}


event NEXUS_RTB (NEXUSCheckTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(NEXUS_RTB,      inactive);
	}
	else
	{
		if(nexusGroup.members > 0)
		{
			if((LastNexusX == nexusGroup.x) and (LastNexusY == nexusGroup.y))
			{
				initIterateGroup(nexusGroup);
				droid = iterateGroup(nexusGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order != DORDER_ATTACK)
					{
						orderDroid(droid,DORDER_RTB);
					}
					else
					{
						setEventTrigger(reSortUnits,vtolAttackTr1);
					}
					droid = iterateGroup(nexusGroup);
				}
			}

			LastNexusX = nexusGroup.x;
			LastNexusY = nexusGroup.y;
		}
	}
}

event engageAndOvertakeAtWill(NEXUSStopAndEngage)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(engageAndOvertakeAtWill,inactive);
	}
	else
	{
		if((droid != NULLOBJECT) and (baseobj != NULLOBJECT))
		{
			if(groupMember(nexusGroup,droid) == TRUE)
			{
				if((droid.player == player) and (baseobj.player != player) and (allianceExistsBetween(baseobj.player,player) == FALSE))
				{
					orderDroidObj(droid, DORDER_ATTACK, baseobj);
				}
			}
		}
	}
}

///////////////////////////////
// VTOLS UNIT ATTACKS - SEND VTOL-UNIT TEAM
///////////////////////////////////////////////////////////////////



event sendVtols(inactive)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(sendVtols,inactive);
	}
	else
	{
		if(vtolUnitGroup.members > 0)
		{
////Target list recheck
			count = 0;
			while(count < 10)
			{
				if(seenUnitArray[count] != NULLOBJECT)
				{
					structure = getStructure(playerHQ, seenUnitArray[count].player);
					if(structure != NULLOBJECT)
					{
						if((seenUnitArray[count].player == player) or (seenUnitArray[count].player == WhosMyLord) or (allianceExistsBetween(seenUnitArray[count].player,player) == TRUE) or (distBetweenTwoPoints(structure.x, structure.y, seenUnitArray[count].x, seenUnitArray[count].y) < 2100))
						{
							seenUnitArray[count] = NULLOBJECT;
							if(TCSVtolUnitArray == count)
							{
								TCSVtolUnitArray = -1;
								orderGroup(vtolUnitGroup,DORDER_RTR);
							}
						}
					}
					else
					{
						if((seenUnitArray[count].player == player) or (seenUnitArray[count].player == WhosMyLord) or (allianceExistsBetween(seenUnitArray[count].player,player) == TRUE))
						{
							seenUnitArray[count] = NULLOBJECT;
							if(TCSVtolUnitArray == count)
							{
								TCSVtolUnitArray = -1;
								orderGroup(vtolUnitGroup,DORDER_RTR);
							}
						}

					}

				}
				count = count + 1;
			}

//// Attack !!!
			boolResult = FALSE;
			boolResult2 = FALSE;
			boolResult3 = FALSE;
			count = 0;
			count2 = 0;                             //FIND NEW TARGET
			initIterateGroup(vtolUnitGroup);
			droid = iterateGroup(vtolUnitGroup);
			while(droid != NULLOBJECT)
			{
				//// Select first target from array
				count = 0;
				boolResult = FALSE;
				while((count < 10) and (boolResult  == FALSE))
				{
					// may want to also check against -1 (is it possible?) :FIX ME: ?
					if(seenUnitArray[count] != NULLOBJECT)
					{

						//////////////////////////////////////////////////////////////////////////////////////////////
						//// ALLRIGHT, WE'VE GOT A TARGET, NOW CHECK IF IT'S PROTECTED BY AA GUNS /////
						count3 = 0;
						count4 = 0;
						while(count3 < numGenAA) //Number of available AA strux
						{
							ASSERT(seenUnitArray[count].player >= 0 and seenUnitArray[count].player < 8,    "player out of bounds:.50 " & seenUnitArray[count].player, player);
							initEnumStruct(FALSE,vtolGenStruct[count3],seenUnitArray[count].player,seenUnitArray[count].player);
							structure3 = enumStruct();
							while(structure3 != NULLOBJECT)
							{
								if(distBetweenTwoPoints(seenUnitArray[count].x,seenUnitArray[count].y,structure3.x,structure3.y) < 1536)
								{
									count4 = count4 + 1;
								}
								structure3 = enumStruct();
							}
							count3 = count3 + 1;
						}
						if(count4 < 5)
						{
							minDistance = 99999999;
							count3 = 0;
							boolResult3 = FALSE;
							while(count3 < numGenAA) //Number of available AA strux
							{
								ASSERT(seenUnitArray[count].player >= 0 and seenUnitArray[count].player < 8,    "player out of bounds:.51 " & seenUnitArray[count].player, player);
								initEnumStruct(FALSE,vtolGenStruct[count3],seenUnitArray[count].player,seenUnitArray[count].player);
								structure3 = enumStruct();
								while((structure3 != NULLOBJECT) and (boolResult3 == FALSE))
								{
									if( (distBetweenTwoPoints(seenUnitArray[count].x,seenUnitArray[count].y,structure3.x,structure3.y) < 1536) and (distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < minDistance) )
									{
										minDistance = distBetweenTwoPoints(seenUnitArray[count].x,seenUnitArray[count].y,structure3.x,structure3.y);
										baseobj2 = structure3;
										boolResult3 = TRUE;
									}
									structure3 = enumStruct();
								}
								count3 = count3 + 1;
							}
						}
						//////////////////////////////////////////////////////////////////////////////////////////////

						if(boolResult3 == FALSE)
						{
							if((droid.order != DORDER_RTR) and (droid.order != DORDER_ATTACK))
							{
								orderDroidObj(droid, DORDER_ATTACK,seenUnitArray[count] );
								boolResult = TRUE;
								TCSVtolUnitArray = count;

							}
						}
						else
						{
							if((droid.order != DORDER_RTR) and (droid.order != DORDER_ATTACK))
							{
								if(baseobj2 != NULLOBJECT)
								{
									orderDroidObj(droid, DORDER_ATTACK,baseobj2 );                                                                                                                         TCSVtolUnitArray = -1;
									boolResult = TRUE;
								}
							}
						}
					}
					count = count + 1;
				}
				droid = iterateGroup(vtolUnitGroup);
			}
		}
	}
	setEventTrigger(sendVtols,inactive);
}

event aimingPrecissionFix(NEXUSTeamGoTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(aimingPrecissionFix,inactive);
	}
	else
	{
		if(TCSVtolUnitArray != -1)
		{
			if(seenUnitArray[TCSVtolUnitArray] != NULLOBJECT)
			{
				initIterateGroup(vtolUnitGroup);
				droid = iterateGroup(vtolUnitGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_ATTACK)
					{
						boolResult = FALSE;
						ASSERT(player >= 0 and player < 8,      "player out of bounds:.52 " & player, player);
						initEnumStruct(FALSE,vtolPad,player,player);
						structure = enumStruct();
						while((structure != NULLOBJECT) and (boolResult == FALSE))
						{
							if(distBetweenTwoPoints(droid.x,droid.y,structure.x,structure.y) < 385)
							{
								boolResult = TRUE;
							}
							structure = enumStruct();
						}
						if(boolResult == FALSE)
						{
							orderDroidObj(droid, DORDER_ATTACK,seenUnitArray[count] );
						}
					}
					droid = iterateGroup(vtolUnitGroup);
				}
			}
		}
	}
}

event sendVtolsACTIVATE(VtolsTeamGoTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(sendVtolsACTIVATE,inactive);
	}
	else
	{
		setEventTrigger(sendVtols,vtolAttackTr1);
	}
}


event vanishScreen(inactive) //vtolAttackTr2)
{
	if(isHumanPlayer(player) == FALSE)
	{
		resetPlayerVisibility(player);
	}
}

//DELETE TARGET FROM LIST AFTER 4 MINUTES IF UNACTIVE
event targetExpirationCheck(NEXUSTeamGoTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(targetExpirationCheck,inactive);
	}
	else
	{
		count = 0;
		while(count < 10)
		{
			if(seenUnitArray[count] != NULLOBJECT)
			{
				if(targetExpire[count] != -1)
				{
					if(((gameTime - 2400) > targetExpire[count]) and (TCSVtolUnitArray != count) and (lastNEXUSArray != count))
					{
						seenUnitArray[count] = NULLOBJECT;
						//resetPlayerVisibility(player);
						targetExpire[count] = -1;
					}
				}
			}
			count = count + 1;
		}
	}
}

///////////////////////////////
// BATTLEDROID TOTAL CONTROL SCRIPT (BATTLEDROID SURVIVAL METHOD)
///////////////////////////////////////////////////////////////////
event groundTCS(TankTCSTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(groundTCS,      inactive);
	}
	else
	{
		if( (droid != NULLOBJECT) and (baseobj != NULLOBJECT))
		{
			if(((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB)) and (droid.order != DORDER_MOVE) and (droid.order != DORDER_ATTACK))
			{
				if( (droid.player == player) and (baseobj.player != player) and (allianceExistsBetween(baseobj.player,droid.player) == FALSE) )
				{
					droid2 = objToDroid(baseobj);
					if(droid2 != NULLOBJECT)                //attacker is a droid
					{
						if(isVtol(droid2) == FALSE)
						{
							orderDroidObj(droid, DORDER_ATTACK, baseobj);
						}
						else                    //attacker is a VTOL
						{
							orderDroidLoc(droid, DORDER_MOVE,droid.x,droid.y);      //just move
						}
					}
					else                            //attacker is a structure
					{
						orderDroidObj(droid, DORDER_ATTACK, baseobj);
					}
				}
				else
				{
					orderDroid(droid, DORDER_RTB);
				}
			}
		}
	}
}

////////////////////////////////
// DROID GROUPS TCS - PROTECTS BASE AGAINST LONG RANGE ATTACKS
event LiveShield(vtolDefendTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(LiveShield,     inactive);
	}
	else
	{
		boolResult = FALSE;
		if((structure != NULLOBJECT) and (baseobj != NULLOBJECT))
		{
			if(baseobj.type == OBJ_DROID)
			{
				if(objToDroid(baseobj) != NULLOBJECT)   //just in case
				{
					if(isVtol(objToDroid(baseobj)) == FALSE)
					{
						//no attack is going on
						//if((distBetweenTwoPoints(baseX,baseY,baseobj.x,baseobj.y) < 2600 ) or (distBetweenTwoPoints(baseX,baseY,tankGroup.x,tankGroup.y) < 2000 ))
						//{
						if(tankActive == FALSE)
						{
							initIterateGroup(tankGroup);
							droid =  iterateGroup(tankGroup);
							while(droid != NULLOBJECT)
							{
								if((structure.stat != derrick) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]))
								{
									if(baseobj.player != player)
									{
										if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
										{
											lastBaseAttacked = gameTime;
											orderDroidLoc(droid, DORDER_MOVE, baseobj.x, baseobj.y);
											RTBTriggerT = TRUE;
										}
									}
								}
								droid =  iterateGroup(tankGroup);
							}
						}
						else            //an attack is i progress
						{
							initIterateGroup(tankGroup);
							droid =  iterateGroup(tankGroup);
							while(droid != NULLOBJECT)
							{
								if( (structure.stat != derrick) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 4096) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]) )
								{
									if(baseobj.player != player)
									{
										if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
										{
											lastBaseAttacked = gameTime;
											orderDroidLoc(droid, DORDER_MOVE, baseobj.x, baseobj.y);
											RTBTriggerT = TRUE;
										}
									}
								}
								droid =  iterateGroup(tankGroup);
							}
						}
						//}

						//no attack is going on
						//if((distBetweenTwoPoints(baseX,baseY,baseobj.x,baseobj.y) < 2600 ) or (distBetweenTwoPoints(baseX,baseY,cyborgGroup.x,cyborgGroup.y) < 2000 ))
						//{

						if(cyborgActive == FALSE)
						{
							initIterateGroup(cyborgGroup);
							droid =  iterateGroup(cyborgGroup);
							while(droid != NULLOBJECT)
							{
								if((structure.stat != derrick) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]) )
								{
									if(baseobj.player != player)
									{
										if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
										{
											lastBaseAttacked = gameTime;
											orderDroidLoc(droid, DORDER_MOVE, baseobj.x, baseobj.y);
											RTBTriggerC = TRUE;
										}
									}
								}
								droid =  iterateGroup(cyborgGroup);
							}
						}
						else            //an attack is i progress
						{
							initIterateGroup(cyborgGroup);
							droid =  iterateGroup(cyborgGroup);
							while(droid != NULLOBJECT)
							{
								if( (structure.stat != derrick) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 4096) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]) )
								{
									if(baseobj.player != player)
									{
										if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
										{
											lastBaseAttacked = gameTime;
											orderDroidLoc(droid, DORDER_MOVE, baseobj.x, baseobj.y);
											RTBTriggerC = TRUE;
										}
									}
								}
								droid =  iterateGroup(cyborgGroup);
							}
						}
						//}
					}
				}
			}
			else
			{
				if(baseobj != NULLOBJECT)       //just in case
				{
					////no attack is going on
					//if((distBetweenTwoPoints(baseX,baseY,baseobj.x,baseobj.y) < 2600 ) or (distBetweenTwoPoints(baseX,baseY,tankGroup.x,tankGroup.y) < 2000 ))
					//{
					if(tankActive == FALSE)
					{
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							if((structure.stat != derrick) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]) )
							{
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
								{
									lastBaseAttacked = gameTime;
									orderDroidLoc(droid, DORDER_MOVE, baseobj.x,baseobj.y);
									RTBTriggerT = TRUE;
								}
							}
							droid =  iterateGroup(tankGroup);
						}
					}
					else            //an attack is i progress
					{
						initIterateGroup(tankGroup);
						droid =  iterateGroup(tankGroup);
						while(droid != NULLOBJECT)
						{
							if( (structure.stat != derrick) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 3000) and (structure.stat != sense[0]) and (structure.stat != sense[1]) and (structure.stat != sense[2]))
							{
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
								{
									lastBaseAttacked = gameTime;
									orderDroidLoc(droid, DORDER_MOVE, baseobj.x,baseobj.y);
									RTBTriggerT = TRUE;
								}
							}
							droid =  iterateGroup(tankGroup);
						}
					}
					//}
					////no attack is going on
					//if((distBetweenTwoPoints(baseX,baseY,baseobj.x,baseobj.y) < 2600 ) or (distBetweenTwoPoints(baseX,baseY,cyborgGroup.x,cyborgGroup.y) < 2000 ))
					//{
					if(cyborgActive == FALSE)
					{
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							if(structure.stat != derrick)
							{
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
								{
									lastBaseAttacked = gameTime;
									orderDroidLoc(droid, DORDER_MOVE, baseobj.x,baseobj.y);
									RTBTriggerC = TRUE;
								}
							}
							droid =  iterateGroup(cyborgGroup);
						}
					}
					else            //an attack is i progress
					{
						initIterateGroup(cyborgGroup);
						droid =  iterateGroup(cyborgGroup);
						while(droid != NULLOBJECT)
						{
							if( (structure.stat != derrick) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 3000))
							{
								if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE) )
								{
									lastBaseAttacked = gameTime;
									orderDroidLoc(droid, DORDER_MOVE, baseobj.x,baseobj.y);
									RTBTriggerC = TRUE;
								}
							}
							droid =  iterateGroup(cyborgGroup);
						}
					}
					//}
				}
			}
		}
	}
}



/////////////////////////////////////////////////////////
/////  ADVANCED VTOL ATTACKING SCRIPT MK-V /////
/////////////////////// a.k.a. ///////////////////////////
///////////  "VTOL Supreme Assault Script"   ////////////
////////////////////////////////////////////////////////
////// INITIALIZATION
event vtol_AAS_INIT(vtolInitTr) //unactive after init
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtol_AAS_INIT,inactive);
	}
	else
	{
		if(vtolActive == FALSE)
		{
			count = random(2);
			if(vtolGroup.members >= (4 + count))
			{
				//START MIGRATION
				vtolActive = TRUE;
				vtolMigrationBool1 = TRUE;
			}
		}
	}
}

////// FIRST ATTACK
event vtol_AAS_FirstAttack(emulateZeroWaitTr)   //ALWAYS ON (WAIT,0 - EMULATION)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtol_AAS_FirstAttack,inactive);
	}
	else
	{
		if(vtolMigrationBool1)
		{
			//SELECT A PLAYER FOR ATTACK RUN
			count = 0;
			plCount = 0;
			while(count < 8)
			{
				if((anyStructButWallsLeft(count) == TRUE) and (count != player) and (allianceExistsBetween(count, player) == FALSE))
				{
					plNum[plCount] = count ;
					plCount = plCount + 1;
				}
				count = count + 1;
			}
			if((targetPl == -1) and (plCount > 0))
			{
				targetPl =  plNum[random(plCount)];
			}

			//SELECT BEST TARGET
			if(targetPl >-1)
			{
				structure = NULLOBJECT;
				count = 0;
				minDistance = 99999999;
				while(count < numVtolTargets)
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.53 " & targetPl, player);
					initEnumStruct(FALSE,vtolTargets[count],targetPl,targetPl);
					structure2 = enumStruct();
					while(structure2 != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure2.x, structure2.y,vtolGroup.x, vtolGroup.y) < minDistance)
						{
							minDistance = distBetweenTwoPoints(structure2.x, structure2.y,vtolGroup.x, vtolGroup.y);
							structure = structure2;
						}
						structure2 = enumStruct();
					}
					count = count + 1;
				}

				//////////////////////////////////////////////////////////////////////////////////////////////
				//// ALLRIGHT, WE'VE GOT A TARGET, NOW CHECK IF IT'S PROTECTED BY AA GUNS /////
				count3 = 0;
				count4 = 0;
				while(count3 < numGenAA) //Number of available AA strux
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.54 " & targetPl, player);
					initEnumStruct(FALSE,vtolGenStruct[count3],targetPl,targetPl );
					structure3 = enumStruct();
					while(structure3 != NULLOBJECT)
					{
						if(distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < 1536)
						{
							count4 = count4 + 1;
						}
						structure3 = enumStruct();
					}
					count3 = count3 + 1;
				}
				if(count4 < 5)
				{
					minDistance = 99999999;
					count3 = 0;
					boolResult3 = FALSE;
					while(count3 < numGenAA) //Number of available AA strux
					{
						ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.55 " & targetPl, player);
						initEnumStruct(FALSE,vtolGenStruct[count3],targetPl,targetPl );
						structure3 = enumStruct();
						while((structure3 != NULLOBJECT) and (boolResult3 == FALSE))
						{
							if( (distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < 1536) and (distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < minDistance) )
							{
								minDistance = distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y);
								structure = structure3;
							}
							structure3 = enumStruct();
						}
						count3 = count3 + 1;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////////////

				if(structure != NULLOBJECT)
				{
					vtolTarget = structure;
					//NOW WE HAVE A STRUCTURE, FORCE WHOLE GROUP TO ATTACK
					initIterateGroup(vtolGroup);
					droid =  iterateGroup(vtolGroup);
					while(droid != NULLOBJECT)
					{
						orderDroidObj(droid, DORDER_ATTACK, vtolTarget );
						lastVtolMove = gameTime;
						droid =  iterateGroup(vtolGroup);
					}

					//ASSIGN VTOL UNIT GROUP IF TCS IS IDLE
					count = 0;
					count2 = 0;
					while(count < 10)
					{
						if(seenUnitArray[count] != NULLOBJECT)
						{
							count2 = count2 + 1;
						}
						count = count + 1;
					}
					if(count2 == 0)
					{
						initIterateGroup(vtolUnitGroup);
						droid =  iterateGroup(vtolUnitGroup);
						while(droid != NULLOBJECT)
						{
							orderDroidObj(droid, DORDER_ATTACK, vtolTarget);
							lastVtolMove = gameTime;
							droid =  iterateGroup(vtolUnitGroup);
						}
					}

					//ACTIVATE SUBINIT1
					vtolSubInitBool1 = TRUE;
					vtolMigrationBool1 = FALSE;
				}
			}
			else
			{
				vtolActive = FALSE;
			}
		}
	}
}


////// SUBINIT 1
event vtol_AAS_SUBINIT1(emulateZeroWaitTr)      //ALWAYS ON
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtol_AAS_SUBINIT1,inactive);
	}
	else
	{
		if(vtolSubInitBool1)
		{
			if(vtolTarget == NULLOBJECT)
			{
				//ACTIVATE POSITIONING
				vtolPosBool1 = TRUE;
				vtolSubInitBool1 = FALSE;
			}
		}
	}
}


////// REPEAT ATTACKS
event vtol_AAS_RepeatAttack(emulateZeroWaitTr)  //ALWAYS ON (WAIT,0 - EMULATION)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtol_AAS_RepeatAttack,inactive);
	}
	else
	{
		if(vtolPosBool1)
		{
			//SELECT BEST TARGET
			if(targetPl >-1)
			{
				structure = NULLOBJECT;
				count = 0;
				minDistance = 99999999;
				while(count < numVtolTargets)
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.56 " & targetPl, player);
					initEnumStruct(FALSE,vtolTargets[count],targetPl,targetPl);
					structure2 = enumStruct();
					while(structure2 != NULLOBJECT)
					{
						if(distBetweenTwoPoints( structure2.x, structure2.y,vtolGroup.x, vtolGroup.y) < minDistance)
						{
							minDistance = distBetweenTwoPoints(structure2.x, structure2.y,vtolGroup.x, vtolGroup.y);
							structure = structure2;
						}
						structure2 = enumStruct();
					}
					count = count + 1;
				}

				//////////////////////////////////////////////////////////////////////////////////////////////
				//// ALLRIGHT, WE'VE GOT A TARGET, NOW CHECK IF IT'S PROTECTED BY AA GUNS /////
				count3 = 0;
				count4 = 0;
				while(count3 < numGenAA) //Number of available AA strux
				{
					ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.57 " & targetPl, player);
					initEnumStruct(FALSE,vtolGenStruct[count3],targetPl,targetPl );
					structure3 = enumStruct();
					while(structure3 != NULLOBJECT)
					{
						if(distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < 1536)
						{
							count4 = count4 + 1;
						}
						structure3 = enumStruct();
					}
					count3 = count3 + 1;
				}
				if(count4 < 5)
				{
					minDistance = 99999999;
					count3 = 0;
					boolResult3 = FALSE;
					while(count3 < numGenAA) //Number of available AA strux
					{
						ASSERT(targetPl >= 0 and targetPl < 8,  "player out of bounds:.58 " & targetPl, player);
						initEnumStruct(FALSE,vtolGenStruct[count3],targetPl,targetPl );
						structure3 = enumStruct();
						while((structure3 != NULLOBJECT) and (boolResult3 == FALSE))
						{
							if( (distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < 1536) and (distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y) < minDistance) )
							{
								minDistance = distBetweenTwoPoints(structure.x,structure.y,structure3.x,structure3.y);
								structure = structure3;
							}
							structure3 = enumStruct();
						}
						count3 = count3 + 1;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////////////

				if(structure != NULLOBJECT)
				{
					vtolTarget = structure;
					//NOW WE HAVE A STRUCTURE, FORCE WHOLE GROUP TO ATTACK
					initIterateGroup(vtolGroup);
					droid =  iterateGroup(vtolGroup);
					while(droid != NULLOBJECT)
					{
						orderDroidObj(droid, DORDER_ATTACK, vtolTarget );
						lastVtolMove = gameTime;
						droid =  iterateGroup(vtolGroup);
					}

					//ASSIGN VTOL UNIT GROUP IF TCS IS IDLE
					count = 0;
					count2 = 0;
					while(count < 10)
					{
						if(seenUnitArray[count] != NULLOBJECT)
						{
							count2 = count2 + 1;
						}
						count = count + 1;
					}
					if(count2 == 0)
					{
						initIterateGroup(vtolUnitGroup);
						droid =  iterateGroup(vtolUnitGroup);
						while(droid != NULLOBJECT)
						{
							orderDroidObj(droid, DORDER_ATTACK, vtolTarget);
							lastVtolMove = gameTime;
							droid =  iterateGroup(vtolUnitGroup);
						}
					}

					//ACTIVATE SUBINIT1
					vtolSubInitBool1 = TRUE;
					vtolPosBool1 = FALSE;
				}
			}
			else
			{
				vtolActive = FALSE;
			}
		}
	}
}

event vtol_AAS_WITHDRAW(vtolMoveTr)             //every, 50
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtol_AAS_WITHDRAW,inactive);
	}
	else
	{
		if(vtolActive == TRUE)
		{
			if(((vtolGroup.members < 2) or (anyStructButWallsLeft(targetPl) == FALSE)) or ((gameTime - lastVtolMove) > 1800))
			{
				//DEACTIVATE ALL
				vtolActive = FALSE;
				vtolSubInitBool1 = FALSE;
				vtolPosBool1 = FALSE;
				vtolMigrationBool1 = FALSE;
				if(vtolGroup.members > 0)
				{
					orderGroup(vtolGroup, DORDER_RTR);
				}
			}
		}
	}
}


////////////////////////////////////////////////
// watch for incoming vtols
event vtolDefend(vtolDefendTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtolDefend,inactive);
	}
	else
	{
		if((gameTime - lastAA) > 120)
		{
			if(baseobj != NULLOBJECT)
			{
				if(baseobj.type == OBJ_DROID)
				{
					if(isVtol(objToDroid(baseobj)))
					{
						if(structure != NULLOBJECT)
						{
							if(structure.stat != sensorTower)
							{
								AAPx = structure.x;
								AAPy = structure.y;
								AAPtime = gameTime;
							}
						}
					}
				}
			}
		}
	}
}



// Preventive AA building
event vtolPrevention(buildBaseQueueTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(vtolPrevention,inactive);
	}
	else
	{
		if(playerPower(player) > 100)
		{
//FACTORY AA
			boolResult2 = TRUE;
			ASSERT(player >= 0 and player < 8,      "player out of bounds:.59 " & player, player);
			initEnumStruct(FALSE,factory,player,player);
			structure= enumStruct();
			while((structure != NULLOBJECT) and (boolResult2 == TRUE))
			{
				buildX = structure.x;
				buildY = structure.y;
				boolResult = FALSE;
				count = 0;
				while((count < numAA) and (boolResult == FALSE))
				{
					if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 1024, player) != NULLOBJECT)
					{
						boolResult = TRUE;
					}
					count = count + 1;
				}
				if(boolResult == FALSE)
				{
					buildX = structure.x;
					buildY = structure.y;
					pickStructLocation(sensorTower,ref buildX, ref buildY, player);
					count = 0;
					while((count < numAA) and (boolResult == FALSE))
					{
						if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 768, player) != NULLOBJECT)
						{
							boolResult = TRUE;
						}
						count = count + 1;
					}
				}
				if(boolResult == FALSE)
				{
					boolResult2 = FALSE;
				}
				structure= enumStruct();
			}
//RES LAB AA
			if(boolResult == TRUE)
			{
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.60 " & player, player);
				initEnumStruct(FALSE,resLab,player,player);
				structure= enumStruct();
				while((structure != NULLOBJECT) and (boolResult2 == TRUE))
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = FALSE;
					count = 0;
					while((count < numAA) and (boolResult == FALSE))
					{
						if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 1024, player) != NULLOBJECT)
						{
							boolResult = TRUE;
						}
						count = count + 1;
					}
					if(boolResult == FALSE)
					{
						buildX = structure.x;
						buildY = structure.y;
						pickStructLocation(sensorTower,ref buildX, ref buildY, player);
						count = 0;
						while((count < numAA) and (boolResult == FALSE))
						{
							if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 768, player) != NULLOBJECT)
							{
								boolResult = TRUE;
							}
							count = count + 1;
						}
					}
					if(boolResult == FALSE)
					{
						boolResult2 = FALSE;
					}
					structure= enumStruct();
				}
			}
//VTOL FACTORY AA
			if(boolResult == TRUE)
			{
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.61 " & player, player);
				initEnumStruct(FALSE,vtolFactory,player,player);
				structure= enumStruct();
				while((structure != NULLOBJECT) and (boolResult2 == TRUE))
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = FALSE;
					count = 0;
					while((count < numAA) and (boolResult == FALSE))
					{
						if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 1024, player) != NULLOBJECT)
						{
							boolResult = TRUE;
						}
						count = count + 1;
					}
					if(boolResult == FALSE)
					{
						buildX = structure.x;
						buildY = structure.y;
						pickStructLocation(sensorTower,ref buildX, ref buildY, player);
						count = 0;
						while((count < numAA) and (boolResult == FALSE))
						{
							if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 768, player) != NULLOBJECT)
							{
								boolResult = TRUE;
							}
							count = count + 1;
						}
					}
					if(boolResult == FALSE)
					{
						boolResult2 = FALSE;
					}
					structure= enumStruct();
				}
			}
//CYB FACTORY AA
			if(boolResult == TRUE)
			{
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.62 " & player, player);
				initEnumStruct(FALSE,cybFactory,player,player);
				structure= enumStruct();
				while((structure != NULLOBJECT) and (boolResult2 == TRUE))
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = FALSE;
					count = 0;
					while((count < numAA) and (boolResult == FALSE))
					{
						if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 1024, player) != NULLOBJECT)
						{
							boolResult = TRUE;
						}
						count = count + 1;
					}
					if(boolResult == FALSE)
					{
						buildX = structure.x;
						buildY = structure.y;
						pickStructLocation(sensorTower,ref buildX, ref buildY, player);
						count = 0;
						while((count < numAA) and (boolResult == FALSE))
						{
							if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 768, player) != NULLOBJECT)
							{
								boolResult = TRUE;
							}
							count = count + 1;
						}
					}
					if(boolResult == FALSE)
					{
						boolResult2 = FALSE;
					}
					structure= enumStruct();
				}
			}
//LASSAT AA
			if(boolResult == TRUE)
			{
				ASSERT(player >= 0 and player < 8,      "player out of bounds:.63 " & player, player);
				initEnumStruct(FALSE,lassat,player,player);
				structure= enumStruct();
				while((structure != NULLOBJECT) and (boolResult2 == TRUE))
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = FALSE;
					count = 0;
					while((count < numAA) and (boolResult == FALSE))
					{
						if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 1024, player) != NULLOBJECT)
						{
							boolResult = TRUE;
						}
						count = count + 1;
					}
					if(boolResult == FALSE)
					{
						buildX = structure.x;
						buildY = structure.y;
						pickStructLocation(sensorTower,ref buildX, ref buildY, player);
						count = 0;
						while((count < numAA) and (boolResult == FALSE))
						{
							if(structureBuiltInRange(vtolDefStruct[count], buildX, buildY, 768, player) != NULLOBJECT)
							{
								boolResult = TRUE;
							}
							count = count + 1;
						}
					}
					if(boolResult == FALSE)
					{
						boolResult2 = FALSE;
					}
					structure= enumStruct();
				}
			}



			if((structure != NULLOBJECT) and (boolResult2 == FALSE))
			{
				if((gameTime - lastAA) > 120)
				{
					AAPx = buildX;
					AAPy = buildY;
					AAPtime = gameTime;
				}
			}
		}
	}
}



//event difficultyModifier(inactive) //upgradeStructuresTr)  -cheat disabled
//{
//	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
//	{
//		setEventTrigger(difficultyModifier,	inactive);
//	}
//	else
//	{
//		skDifficultyModifier(player);
//	}
//}


//// TRUCKS SURVIVAL SCRIPT MK3
event truckSurvival(upgradeStructuresTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(truckSurvival,  inactive);
	}
	else
	{
		initIterateGroup(harvesterGroup);
		droid =  iterateGroup(harvesterGroup);
		while(droid != NULLOBJECT)
		{
			count = 0;
			while(count < 8)
			{
				if((count != player) and (count != WhosMyLord) and (allianceExistsBetween(player,count) == FALSE))
				{
					if((droidInRange(count, droid.x,droid.y, 1280)) or (objectInRange(count, droid.x,droid.y, 1280)))
					{
						structure = getStructure(playerHQ,player);
						if(structure != NULLOBJECT)
						{
							if(distBetweenTwoPoints(droid.x,droid.y,structure.x,structure.y) > 3840)
							{
								if(isVtol(droid) == FALSE)
								{
									if((droid.orderx != baseX) and (droid.ordery != baseY) and (droid.order != DORDER_RTB) and (distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y) > 300) )
									{
										rectFixX = droid.x;
										rectFixY =  droid.y;
										rectFixRange = 1000;
/// PRECOMPILED SCRIPT
										rectFixX1 = rectFixX - rectFixRange; rectFixY1 = rectFixY - rectFixRange; rectFixX2 = rectFixX + rectFixRange; rectFixY2 = rectFixY + rectFixRange; rectValidX = 0; rectValidY = 0; rectValid = 0; if((rectFixX1 < rectFixX2) and (rectFixX1 >= 0) and (rectFixX2 < (mapWidth * 128)) ){ rectValidX = 1;} else{ if(rectFixX1 < 0) { rectFixX1 = 0; } if(rectFixX2 > (mapWidth * 128)) { rectFixX2 = mapWidth * 128; } if(rectFixX1 != rectFixX2) { rectValidX = 1; }} if((rectFixX1 > rectFixX2) and (rectFixX2 >= 0) and (rectFixX1 < (mapWidth * 128))){ rectValidX = 1;} else{ if(rectFixX2 < 0) { rectFixX2 = 0; } if(rectFixX1 > (mapWidth * 128)) { rectFixX1 = mapWidth * 128; } if(rectFixX2 != rectFixX1) { rectValidX = 1; }} if((rectFixY1 < rectFixY2) and (rectFixY1 >= 0) and (rectFixY2 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY1 < 0) { rectFixY1 = 0; } if(rectFixY2 > (mapWidth * 128)) { rectFixY2 = mapWidth * 128; } if(rectFixY1 != rectFixY2) { rectValidY = 1; }} if((rectFixY1 > rectFixY2) and (rectFixY2 >= 0) and (rectFixY1 < (mapHeight * 128))){ rectValidY = 1;} else{ if(rectFixY2 < 0) { rectFixY2 = 0; } if(rectFixY1 > (mapWidth * 128)) { rectFixY1 = mapWidth * 128; } if(rectFixY2 != rectFixY1) { rectValidY = 1; }} if((rectValidX == 1) and (rectValidY == 1)){ rectValid = 1;} else{ rectValid = 0;}
/// PRECOMPILED SCRIPT
										droid2 = droidTargetInArea(count,player,rectFixX1,rectFixY1,rectFixX2,rectFixY2);
										if(droid2 != NULLOBJECT)
										{
											if((droid2.droidType != DROID_CONSTRUCT) or (numDroidsInArea(player,count2,count3,count4,count5) > 1))
											{
												orderDroidLoc(droid, DORDER_MOVE, baseX,baseY);
											}
										}
										else
										{
											orderDroidLoc(droid, DORDER_MOVE, baseX,baseY);
										}
									}
								}
							}
						}
					}
				}
				count = count + 1;
			}
			//return to action if all clear
			if((droid.order == DORDER_RTB) or ((droid.orderx == baseX) and (droid.ordery == baseY)))
			{
				boolResult = FALSE;
				count = 0;
				while(count < 8)
				{
					if((count != player) and (count != WhosMyLord) and (allianceExistsBetween(player,count) == FALSE))
					{
						if((droidInRange(count, droid.x,droid.y, 2400)) or (objectInRange(count, droid.x,droid.y, 2400)))
						{
							boolResult = TRUE;
						}
					}
					count = count + 1;
				}
				if(boolResult == FALSE)
				{
					orderDroid(droid, DORDER_STOP);
				}
			}
			droid =  iterateGroup(harvesterGroup);
		}
	}
}

event tankRepairs(scoutMainTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(tankRepairs,    inactive);
	}
	else
	{
		if(getStructure(repairFacility, player) != NULLOBJECT)
		{
			//tanks
			boolResult = FALSE;
			initIterateGroup(tankGroup);
			droid = iterateGroup(tankGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				if((droid.health < 99) and (droid.order == DORDER_NONE) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 4480))
				{
					orderDroid(droid,DORDER_RTR);
				}
				droid = iterateGroup(tankGroup);
			}
			//cyborgs
			initIterateGroup(cyborgGroup);
			droid = iterateGroup(cyborgGroup);
			while((droid != NULLOBJECT) and (boolResult == FALSE))
			{
				if((droid.health < 99) and (droid.order == DORDER_NONE) and (distBetweenTwoPoints(droid.x,droid.y, baseX,baseY) < 4480))
				{
					orderDroid(droid,DORDER_RTR);
				}
				droid = iterateGroup(cyborgGroup);
			}

		}
	}
}


//////////////// EVERY METHOD OF ENEMY DETECTION HAVE FAILED -  USE 'skLocateEnemy' INTERNAL WZ2100 METHOD
event skLocateEnemyMethod(tankAttackTr5)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(skLocateEnemyMethod,    inactive);
	}
	else
	{
		if(gameTime - lastGroundAttack > 14400 )
		{
			count = 0;
			count2 = 0;
			while(count < 8)        {
				if(anyStructButWallsLeft(count) == TRUE)
				{
					if((count != player) and (count != WhosMyLord) and (allianceExistsBetween(player,count) == FALSE))
					{
						count2 = count2 + 1;
					}
				}
				count = count + 1;
			}
			if(count2 == 0)         {
				count = 0;
				while((count < 8) and (baseobj == NULLOBJECT))
				{
					if((anyStructButWallsLeft(count) == FALSE) and (anyDroidsLeft(count) == TRUE))
					{
						if((count != player) and (count != WhosMyLord) and (allianceExistsBetween(player,count) == FALSE))
						{
							baseobj = skLocateEnemy(count2);
						}
					}
					count = count + 1;
				}

				if(baseobj != NULLOBJECT)
				{
					initIterateGroup(cyborgGroup);
					droid = iterateGroup(cyborgGroup);
					if(droid != NULLOBJECT)
					{
						if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
						{
							orderGroupLoc(cyborgGroup,DORDER_MOVE,baseobj.x,baseobj.y);
						}
					}

					initIterateGroup(tankGroup);
					droid = iterateGroup(tankGroup);
					if(droid != NULLOBJECT)
					{
						if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_MOVE))
						{
							orderGroupLoc(tankGroup,DORDER_MOVE,baseobj.x,baseobj.y);
						}
					}
				}
			}
		}
	}
}

// check if all units are assigned to a group !!!
event unitAssignationCheck(upgradeStructuresTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(unitAssignationCheck,   inactive);
	}
	else
	{
		if( (vtolGroup.members + vtolUnitGroup.members + tankGroup.members +  buildGroup.members + harvesterGroup.members + senseGroup.members  + cyborgGroup.members + nexusGroup.members) != numDroidsInArea(player, 0, 0, (mapWidth*128), (mapHeight*128)) )
		{
			setEventTrigger(reSortUnits,vtolAttackTr1);
		}
		if(anyStructButWallsLeft(player) == FALSE)
		{
			if((tankGroup.members == 0) and (cyborgGroup.members == 0) and (buildGroup.members > 0) and (harvesterGroup.members > 0) )
			{
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while((droid != NULLOBJECT) and ((gameTime - lastTE) > 100))
				{
					orderDroid(droid,DORDER_STOP);
					baseX = droid.x;
					baseY = droid.y;
					lastTE = gameTime;
					droid = iterateGroup(buildGroup);
				}
			}
		}
	}
}



//// HELP ME!!!
event restoreAttacks (inactive)
{
	if(attacksOnHold == TRUE)
	{
		attacksOnHold = FALSE;
		orderGroup(tankGroup, DORDER_RTB);
		orderGroup(cyborgGroup, DORDER_RTB);
	}
}


event sendHelpNow(sendHelpNowTr)
{
	if(IamBOT == TRUE)
	{       if((count == WhosMyLord) or (count2 == WhosMyLord))
		{
			if((isHumanPlayer(count) == FALSE) or (isHumanPlayer(count2) == FALSE))
			{
				structure = getStructure(playerHQ, WhosMyLord);
				if(structure != NULLOBJECT)
				{
					if(tankGroup.members  != 0)
					{
						orderGroupLoc(tankGroup, DORDER_MOVE, structure.x,structure.y);
					}

					if(cyborgGroup.members  != 0)
					{
						orderGroupLoc(cyborgGroup, DORDER_MOVE, structure.x,structure.y);
					}

					if(attacksOnHold == FALSE)
					{
						setEventTrigger(restoreAttacks, restoreAttacksTr );
						attacksOnHold = TRUE;
					}
				}
				else
				{
					setEventTrigger(reSortUnits,vtolAttackTr1);
				}
				//TRUCK HELP
				if(anyDroidsLeft(WhosMyLord) == FALSE)
				{
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					count3 = (buildGroup.members / 2);
					while((droid != NULLOBJECT) and (count3 > 0))
					{
						if(droid != NULLOBJECT)
						{
							takeOverSingleDroid(droid,WhosMyLord);
						}
						droid = iterateGroup(buildGroup);
						count3 = count3 - 1;
					}
				}
			}
		}}
}

// CHEAT SCRIPTS:
event CheatIfYouCan(CheatsTr)
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(CheatIfYouCan,inactive);
	}
	else
	{
		if(IamBOT == FALSE)
		{
			if((CheatLevel == 3) or (CheatLevel == 4) or (CheatLevel == 5) or (CheatLevel == 6)) //Research Speed
			{
				skDifficultyModifier(player);
			}

			if((CheatLevel == 1) or (CheatLevel == 4)) // Light MoneyCheat
			{
				addPower(800, player);
			}

			if((CheatLevel == 2) or (CheatLevel == 5)) // Heavy MoneyCheat
			{
				addPower(3500, player);
			}

			if(CheatLevel == 6)                     // Unlimited MoneyCheat
			{
				addPower(6500, player);
			}

		}
		else
		{
			if((CheatLevel == 3) or (CheatLevel == 4) or (CheatLevel == 5)) //BOT - Research Speed
			{                       skDifficultyModifier(player);}

			if((CheatLevel == 1) or (CheatLevel == 4))              //BOT - Light MoneyCheat
			{
				addPower(500, player);
			}

			if((CheatLevel == 2) or (CheatLevel == 5) or (CheatLevel == 6)) //BOT - Heavy MoneyCheat
			{
				addPower(2500, player);
			}

		}
	}
}
// CHEATS END


event plannedResort (upgradeStructuresTr)
{
	if(doResortUnits == TRUE)
	{
		setEventTrigger(reSortUnits,executeScriptTr);
		doResortUnits = FALSE;
	}
}


//////////////////////////////////////////////////////////////////////////////
//////////////// REINCARNATION SCRIPT ///////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//// PLAYER BLESSES
event playerBlesses(blessTr)
{
	if(useReincarnation)            {
		if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
		{
			setEventTrigger(playerBlesses,inactive);
		}
		else
		{
			count = 0;
			while(count < 8)
			{
				if((anyDroidsLeft(count) == FALSE) and (anyFactoriesLeft(count) == FALSE) and (allianceExistsBetween(player,count)) and (count != player))
				{
					if(buildGroup.members > 4)
					{
						count3 = 0;
						count2 = buildGroup.members - 4;
						initIterateGroup(buildGroup);
						droid =  iterateGroup(buildGroup);
						while((droid != NULLOBJECT) and (count2 > 0) and (count3 < 2))
						{
							if(droid.order != DORDER_BUILD)
							{
								takeOverSingleDroid(droid,count);
								count2 = count2  - 1;
							}
							droid =  iterateGroup(buildGroup);
						}
						//power bless
						if(playerPower(player) > 2500)
						{
							addPower((playerPower(player) /3 *2), count);
							setPowerLevel((playerPower(player) /3 *2), player);
						}
					}
				}
				count = count + 1;
			}
		}
	}
}


//// PLAYER REBORN
event playerReborn(scoutMainTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(playerReborn,inactive);
	}
	else
	{
		if(LIFE == FALSE)
		{
			if((anyFactoriesLeft(player) == TRUE) or (anyDroidsLeft(player) == TRUE))
			{
				LIFE = FALSE;
//restore all
				setEventTrigger(playerReborn,scoutMainTr );
				setEventTrigger(playerBlesses,blessTr);
				setEventTrigger(CheatIfYouCan,CheatsTr);
				setEventTrigger(sendHelpNow,sendHelpNowTr);
				setEventTrigger(restoreAttacks,inactive);
				setEventTrigger(unitAssignationCheck,upgradeStructuresTr );
				setEventTrigger(skLocateEnemyMethod,tankAttackTr5);
				setEventTrigger(tankRepairs,scoutMainTr);
				setEventTrigger(truckSurvival,upgradeStructuresTr);
				setEventTrigger(vtolPrevention,fortifyTr);
				setEventTrigger(vtolDefend,vtolDefendTr);
				setEventTrigger(vtol_AAS_WITHDRAW,vtolMoveTr);
				setEventTrigger(vtol_AAS_RepeatAttack,emulateZeroWaitTr);
				setEventTrigger(vtol_AAS_SUBINIT1,emulateZeroWaitTr);
				setEventTrigger(vtol_AAS_FirstAttack,emulateZeroWaitTr);
				setEventTrigger(vtol_AAS_INIT,vtolInitTr);
				setEventTrigger(LiveShield,vtolDefendTr);
				setEventTrigger(groundTCS,TankTCSTr );
				setEventTrigger(targetExpirationCheck,NEXUSTeamGoTr);
				setEventTrigger(vanishScreen,inactive);
				setEventTrigger(sendVtolsACTIVATE,VtolsTeamGoTr);
				setEventTrigger(aimingPrecissionFix,NEXUSTeamGoTr);
				setEventTrigger(sendVtols,inactive);
				setEventTrigger(engageAndOvertakeAtWill,NEXUSStopAndEngage);
				setEventTrigger(NEXUS_RTB,NEXUSCheckTr);
				setEventTrigger(sendNEXUSACTIVATE,NEXUSTeamGoTr);
				setEventTrigger(sendNEXUS,inactive);
				setEventTrigger(newObjectReport,newDroidReportTr);
				setEventTrigger(intruderDetected,vtolDefendTr);
				setEventTrigger(SelectRndTemplateV,cyborgBuildEventTr );
				setEventTrigger(SelectRndTemplateVRun,inactive);
				setEventTrigger(vtolStructs,scoutMainTr);
				setEventTrigger(managePower,managePowerTr);
				setEventTrigger(doResearchLP,doResearchLPTr);
				setEventTrigger(doResearch,doResearchTr);
				setEventTrigger(cyborg_AAS_WITHDRAW,cyborgMoveTr);
				setEventTrigger(cyborg_AAS_AT1,emulateZeroWaitTr);
				setEventTrigger(cyborg_AAS_SUBINIT2,emulateZeroWaitTr);
				setEventTrigger(cyborg_AAS_POSITIONING,emulateZeroWaitTr);
				setEventTrigger(cyborg_AAS_SUBINIT1,emulateZeroWaitTr);
				setEventTrigger(cyborg_AAS_MIGRATION,emulateZeroWaitTr);
				setEventTrigger(cyborg_AAS_INIT,cyborgInitTr);
				setEventTrigger(tank_AAS_WITHDRAW,tankMoveTr);
				setEventTrigger(tank_AAS_AT1,emulateZeroWaitTr);
				setEventTrigger(tank_AAS_SUBINIT2,emulateZeroWaitTr);
				setEventTrigger(tank_AAS_POSITIONING,emulateZeroWaitTr);
				setEventTrigger(tank_AAS_SUBINIT1,emulateZeroWaitTr);
				setEventTrigger(tank_AAS_MIGRATION,emulateZeroWaitTr);
				setEventTrigger(tank_AAS_INIT,tankInitTr);
				setEventTrigger(activatelassat,lassatEventTr);
				setEventTrigger(Buildlassat,doResearchTr);
				setEventTrigger(lassatRecharge,inactive);
				setEventTrigger(takeoverDefend,EtakeoverTr);
				setEventTrigger(takeover,takeoverTr);
				setEventTrigger(SelectRndTemplateC,cyborgBuildEventTr );
				setEventTrigger(SelectRndTemplateCRun,inactive);
				setEventTrigger(SelectRndTemplate, tankBuildEventTr );
				setEventTrigger(SelectRndTemplateRun,inactive);
				setEventTrigger(reSortUnits,planExecuteTr);
				setEventTrigger(droidBuilt,droidBuiltTr);
				setEventTrigger(newfortify,fortifyTr);
				setEventTrigger(finishStructs,finishStructsTr);
				setEventTrigger(upgradeStructures,upgradeStructuresTr );
				setEventTrigger(buildBaseArty, buildBaseArtyTr );
				setEventTrigger(defendBaseLP,defendBaseLPTr);
				setEventTrigger(defendBase,defendBaseTr);
				setEventTrigger(defendSpotSelect,defendSpotChangeTr);
				setEventTrigger(defendBaseQueue,defendBaseQueueTr);
				setEventTrigger(vanishArtifacts,managePowerTr);
				setEventTrigger(structureLimitHack,defendBaseTr);
				setEventTrigger(buildBase,buildBaseTr);
				setEventTrigger(buildBaseQueue,buildBaseQueueTr);
				setEventTrigger(buildPowerGenerators,buildPowerGeneratorsTr);
				setEventTrigger(buildSense,buildSenseTr);
				setEventTrigger(incendryStart,incendryTr);
				setEventTrigger(incendryStop,inactive);
				setEventTrigger(incendry,inactive);
				setEventTrigger(defendOilEnhanced,extraOilDefensesTr);
				setEventTrigger(harvesterBuildersSlider,buildDerrickTr);
				setEventTrigger(harvesterOperate,buildDerrickTr);
				setEventTrigger(buildPowFirst,initOverrideMostEssentialTr  );
				setEventTrigger(buildResFirst,initOverrideMinorTr );
				setEventTrigger(buildFactoryFirst,initOverrideMostEssentialTr );
				setEventTrigger(buildRepFirst,initOverrideMinorTr);
				setEventTrigger(buildCybFactoryFirst,initOverrideMinorTr);
				setEventTrigger(basedetails,basedetailsTr);
				setEventTrigger(DBM_MoveBase,fortifyTr);
				setEventTrigger(changeFogColor,upgradeStructuresTr);
				setEventTrigger(weatherSetUp,changeWeatherTargetTr);
				setEventTrigger(ReAllyBOTs,buildBaseTr);
				setEventTrigger(BOTSettings,buildDerrickTr);
				setEventTrigger(DEBUG_MODE_ENABLER,buildBaseTr);
				setEventTrigger(ForceBuildHQ,buildHQTopPriority);
				setEventTrigger(oilHack1,executeScriptTr);
				setEventTrigger(AutoBases,inactive);
				setEventTrigger(initialisedEvent,executeScriptTr);
				setEventTrigger(plannedResort,upgradeStructuresTr);
				doResortUnits = TRUE;
				lastNEXUSArray = -1;
				IamBOT = FALSE;
				WhosMyLord = -1;
//end restore all
			}
		}
	}
}



//// PLAYER DEFEATED
event playerDefeated(scoutMainTr )
{
	if(( (player == selectedPlayer) or (not myResponsibility(player)) ) and (AIControl == FALSE))
	{
		setEventTrigger(playerDefeated,inactive);
	}
	else
	{
		if((anyFactoriesLeft(player) == FALSE) and (anyDroidsLeft(player) == FALSE))    //literally if player is dead
		{
			LIFE = FALSE;
//disable all
			setEventTrigger(playerReborn,scoutMainTr );
			setEventTrigger(playerDefeated,scoutMainTr );
			setEventTrigger(playerBlesses,blessTr);
			setEventTrigger(CheatIfYouCan,CheatsTr);
			setEventTrigger(sendHelpNow,inactive );
			setEventTrigger(restoreAttacks,inactive );
			setEventTrigger(unitAssignationCheck,inactive );
			setEventTrigger(skLocateEnemyMethod,inactive );
			setEventTrigger(tankRepairs,inactive );
			setEventTrigger(truckSurvival,inactive );
			setEventTrigger(vtolPrevention,inactive );
			setEventTrigger(vtolDefend,inactive );
			setEventTrigger(vtol_AAS_WITHDRAW,inactive );
			setEventTrigger(vtol_AAS_RepeatAttack,inactive );
			setEventTrigger(vtol_AAS_SUBINIT1,inactive );
			setEventTrigger(vtol_AAS_FirstAttack,inactive );
			setEventTrigger(vtol_AAS_INIT,inactive );
			setEventTrigger(LiveShield,inactive );
			setEventTrigger(groundTCS,inactive );
			setEventTrigger(targetExpirationCheck,inactive );
			setEventTrigger(vanishScreen,inactive );
			setEventTrigger(sendVtolsACTIVATE,inactive );
			setEventTrigger(aimingPrecissionFix,inactive );
			setEventTrigger(sendVtols,inactive);
			setEventTrigger(engageAndOvertakeAtWill,inactive );
			setEventTrigger(NEXUS_RTB,inactive );
			setEventTrigger(sendNEXUSACTIVATE,inactive );
			setEventTrigger(sendNEXUS,inactive );
			setEventTrigger(newObjectReport,inactive );
			setEventTrigger(intruderDetected,inactive );
			setEventTrigger(SelectRndTemplateV,inactive );
			setEventTrigger(SelectRndTemplateVRun,inactive );
			setEventTrigger(vtolStructs,inactive );
			setEventTrigger(managePower,inactive );
			setEventTrigger(doResearchLP,inactive );
			setEventTrigger(doResearch,inactive );
			setEventTrigger(cyborg_AAS_WITHDRAW,inactive );
			setEventTrigger(cyborg_AAS_AT1,inactive );
			setEventTrigger(cyborg_AAS_SUBINIT2,inactive );
			setEventTrigger(cyborg_AAS_POSITIONING,inactive );
			setEventTrigger(cyborg_AAS_SUBINIT1,inactive );
			setEventTrigger(cyborg_AAS_MIGRATION,inactive );
			setEventTrigger(cyborg_AAS_INIT,inactive );
			setEventTrigger(tank_AAS_WITHDRAW,inactive );
			setEventTrigger(tank_AAS_AT1,inactive );
			setEventTrigger(tank_AAS_SUBINIT2,inactive );
			setEventTrigger(tank_AAS_POSITIONING,inactive );
			setEventTrigger(tank_AAS_SUBINIT1,inactive );
			setEventTrigger(tank_AAS_MIGRATION,inactive );
			setEventTrigger(tank_AAS_INIT,inactive );
			setEventTrigger(activatelassat,inactive );
			setEventTrigger(Buildlassat,inactive );
			setEventTrigger(lassatRecharge,inactive );
			setEventTrigger(takeoverDefend,inactive );
			setEventTrigger(takeover,inactive );
			setEventTrigger(SelectRndTemplateC,inactive );
			setEventTrigger(SelectRndTemplateCRun,inactive );
			setEventTrigger(SelectRndTemplate, inactive );
			setEventTrigger(SelectRndTemplateRun,inactive );
			setEventTrigger(reSortUnits,inactive );
			setEventTrigger(droidBuilt,inactive );
			setEventTrigger(newfortify,inactive );
			setEventTrigger(finishStructs,inactive );
			setEventTrigger(upgradeStructures,inactive );
			setEventTrigger(buildBaseArty, inactive );
			setEventTrigger(defendBaseLP,inactive );
			setEventTrigger(defendBase,inactive );
			setEventTrigger(defendSpotSelect,inactive );
			setEventTrigger(defendBaseQueue,inactive );
			setEventTrigger(vanishArtifacts,inactive );
			setEventTrigger(structureLimitHack,inactive );
			setEventTrigger(buildBase,inactive );
			setEventTrigger(buildBaseQueue,inactive );
			setEventTrigger(buildPowerGenerators,inactive );
			setEventTrigger(buildSense,inactive );
			setEventTrigger(incendryStart,inactive );
			setEventTrigger(incendryStop,inactive );
			setEventTrigger(incendry,inactive );
			setEventTrigger(defendOilEnhanced,inactive );
			setEventTrigger(harvesterBuildersSlider,inactive );
			setEventTrigger(harvesterOperate,inactive );
			setEventTrigger(buildPowFirst,inactive );
			setEventTrigger(buildResFirst,inactive );
			setEventTrigger(buildFactoryFirst,inactive );
			setEventTrigger(buildRepFirst,inactive );
			setEventTrigger(buildCybFactoryFirst,inactive );
			setEventTrigger(basedetails,inactive );
			setEventTrigger(DBM_MoveBase,inactive );
			setEventTrigger(changeFogColor,inactive );
			setEventTrigger(weatherSetUp,inactive );
			setEventTrigger(ReAllyBOTs,inactive );
			setEventTrigger(BOTSettings,inactive );
			setEventTrigger(DEBUG_MODE_ENABLER,inactive );
			setEventTrigger(ForceBuildHQ,inactive );
			setEventTrigger(oilHack1,inactive );
			setEventTrigger(AutoBases,inactive );
			setEventTrigger(initialisedEvent,inactive );
			setEventTrigger(plannedResort,inactive);
			doResortUnits = TRUE;
			lastNEXUSArray = -1;
			IamBOT = FALSE;
			WhosMyLord = -1;
// end disable all
		}
	}
}


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ RESTART IF PLAYER LEFT +*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*


event reassignPlayers(reassignTr)
{
	LIFE = FALSE;
	setEventTrigger(playerReborn,scoutMainTr );
	setEventTrigger(playerDefeated,scoutMainTr );
	setEventTrigger(playerBlesses,blessTr);
	setEventTrigger(CheatIfYouCan,CheatsTr);
	setEventTrigger(sendHelpNow,sendHelpNowTr);
	setEventTrigger(restoreAttacks,inactive);
	setEventTrigger(unitAssignationCheck,upgradeStructuresTr );
	setEventTrigger(skLocateEnemyMethod,tankAttackTr5);
	setEventTrigger(tankRepairs,scoutMainTr);
	setEventTrigger(truckSurvival,upgradeStructuresTr);
	setEventTrigger(vtolPrevention,fortifyTr);
	setEventTrigger(vtolDefend,vtolDefendTr);
	setEventTrigger(vtol_AAS_WITHDRAW,vtolMoveTr);
	setEventTrigger(vtol_AAS_RepeatAttack,emulateZeroWaitTr);
	setEventTrigger(vtol_AAS_SUBINIT1,emulateZeroWaitTr);
	setEventTrigger(vtol_AAS_FirstAttack,emulateZeroWaitTr);
	setEventTrigger(vtol_AAS_INIT,vtolInitTr);
	setEventTrigger(LiveShield,vtolDefendTr);
	setEventTrigger(groundTCS,TankTCSTr );
	setEventTrigger(targetExpirationCheck,NEXUSTeamGoTr);
	setEventTrigger(vanishScreen,inactive);
	setEventTrigger(sendVtolsACTIVATE,VtolsTeamGoTr);
	setEventTrigger(aimingPrecissionFix,NEXUSTeamGoTr);
	setEventTrigger(sendVtols,inactive);
	setEventTrigger(engageAndOvertakeAtWill,NEXUSStopAndEngage);
	setEventTrigger(NEXUS_RTB,NEXUSCheckTr);
	setEventTrigger(sendNEXUSACTIVATE,NEXUSTeamGoTr);
	setEventTrigger(sendNEXUS,inactive);
	setEventTrigger(newObjectReport,newDroidReportTr);
	setEventTrigger(intruderDetected,vtolDefendTr);
	setEventTrigger(SelectRndTemplateV,cyborgBuildEventTr );
	setEventTrigger(SelectRndTemplateVRun,inactive);
	setEventTrigger(vtolStructs,scoutMainTr);
	setEventTrigger(managePower,managePowerTr);
	setEventTrigger(doResearchLP,doResearchLPTr);
	setEventTrigger(doResearch,doResearchTr);
	setEventTrigger(cyborg_AAS_WITHDRAW,cyborgMoveTr);
	setEventTrigger(cyborg_AAS_AT1,emulateZeroWaitTr);
	setEventTrigger(cyborg_AAS_SUBINIT2,emulateZeroWaitTr);
	setEventTrigger(cyborg_AAS_POSITIONING,emulateZeroWaitTr);
	setEventTrigger(cyborg_AAS_SUBINIT1,emulateZeroWaitTr);
	setEventTrigger(cyborg_AAS_MIGRATION,emulateZeroWaitTr);
	setEventTrigger(cyborg_AAS_INIT,cyborgInitTr);
	setEventTrigger(tank_AAS_WITHDRAW,tankMoveTr);
	setEventTrigger(tank_AAS_AT1,emulateZeroWaitTr);
	setEventTrigger(tank_AAS_SUBINIT2,emulateZeroWaitTr);
	setEventTrigger(tank_AAS_POSITIONING,emulateZeroWaitTr);
	setEventTrigger(tank_AAS_SUBINIT1,emulateZeroWaitTr);
	setEventTrigger(tank_AAS_MIGRATION,emulateZeroWaitTr);
	setEventTrigger(tank_AAS_INIT,tankInitTr);
	setEventTrigger(activatelassat,lassatEventTr);
	setEventTrigger(Buildlassat,doResearchTr);
	setEventTrigger(lassatRecharge,inactive);
	setEventTrigger(takeoverDefend,EtakeoverTr);
	setEventTrigger(takeover,takeoverTr);
	setEventTrigger(SelectRndTemplateC,cyborgBuildEventTr );
	setEventTrigger(SelectRndTemplateCRun,inactive);
	setEventTrigger(SelectRndTemplate, tankBuildEventTr );
	setEventTrigger(SelectRndTemplateRun,inactive);
	setEventTrigger(reSortUnits,executeScriptTr);
	setEventTrigger(droidBuilt,droidBuiltTr);
	setEventTrigger(newfortify,fortifyTr);
	setEventTrigger(finishStructs,finishStructsTr);
	setEventTrigger(upgradeStructures,upgradeStructuresTr );
	setEventTrigger(buildBaseArty, buildBaseArtyTr );
	setEventTrigger(defendBaseLP,defendBaseLPTr);
	setEventTrigger(defendBase,defendBaseTr);
	setEventTrigger(defendSpotSelect,defendSpotChangeTr);
	setEventTrigger(defendBaseQueue,defendBaseQueueTr);
	setEventTrigger(vanishArtifacts,managePowerTr);
	setEventTrigger(structureLimitHack,defendBaseTr);
	setEventTrigger(buildBase,buildBaseTr);
	setEventTrigger(buildBaseQueue,buildBaseQueueTr);
	setEventTrigger(buildPowerGenerators,buildPowerGeneratorsTr);
	setEventTrigger(buildSense,buildSenseTr);
	setEventTrigger(incendryStart,incendryTr);
	setEventTrigger(incendryStop,inactive);
	setEventTrigger(incendry,inactive);
	setEventTrigger(defendOilEnhanced,extraOilDefensesTr);
	setEventTrigger(harvesterBuildersSlider,buildDerrickTr);
	setEventTrigger(harvesterOperate,buildDerrickTr);
	setEventTrigger(buildPowFirst,initOverrideMostEssentialTr  );
	setEventTrigger(buildResFirst,initOverrideMinorTr );
	setEventTrigger(buildFactoryFirst,initOverrideMostEssentialTr );
	setEventTrigger(buildRepFirst,initOverrideMinorTr);
	setEventTrigger(buildCybFactoryFirst,initOverrideMinorTr);
	setEventTrigger(basedetails,basedetailsTr);
	setEventTrigger(DBM_MoveBase,fortifyTr);
	setEventTrigger(changeFogColor,upgradeStructuresTr);
	setEventTrigger(weatherSetUp,changeWeatherTargetTr);
	setEventTrigger(ReAllyBOTs,buildBaseTr);
	setEventTrigger(BOTSettings,buildDerrickTr);
	setEventTrigger(DEBUG_MODE_ENABLER,buildBaseTr);
	setEventTrigger(ForceBuildHQ,buildHQTopPriority);
	setEventTrigger(oilHack1,executeScriptTr);
	setEventTrigger(AutoBases,inactive);
	setEventTrigger(initialisedEvent,executeScriptTr);
	setEventTrigger(plannedResort,upgradeStructuresTr);

	doResortUnits = TRUE;
	lastNEXUSArray = -1;
	IamBOT = FALSE;
	WhosMyLord = -1;

	setEventTrigger(BOTSettings,buildDerrickTr);
	setEventTrigger(reassignPlayers,reassignTr);
	setEventTrigger(reSortUnits,vtolAttackTr1);
}






