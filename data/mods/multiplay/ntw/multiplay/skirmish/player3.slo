//------------------------------------------------------
//	Public variables
//------------------------------------------------------
public	STRUCTURESTAT		legoSt[12],derrick,powGen,factory,resLab,powModule,facModule,resModule,vtolFactory,wall,
				repairFacility,extraStructs[5],defenses[18],structChoice[5],baseStructs[13],vtolPad,vtolDefStruct[5],sens[3],arty[5],attackStructs[5],cybFactory;
public	FEATURESTAT		oilRes;
public	INT			numLego,player,numTemplates,numExtraStructs,numDefenses,numBaseStructs,numSVtolTemplates,numTVtolTemplates,sPref[6],numVtolDefStr,numAttackStructs;
public	TEMPLATE		tmpl[2][12],constructor,sVtols[2][1],tVtols[2][3],tmplRep[2],cybMechanic,cybTmpl[11],Transport;
public	WEAPON			sVtolWeapon[3],tVtolWeapon[3];
public	TEXTSTRING		ai_ally_msg[5],DebugMsg[15];
public	PROPULSION		cyborgProp,vtolProp;	

//------------------------------------------------------
//	Private variables
//------------------------------------------------------
private GROUP			buildGroup,tempGroup,sendOutpostGr,sendAttackGr,collectSendGr,attackGroup,scoutGroup[3],oilGr,sVtolGr,tVtolGr,defendGr,repGr,repairedGroup,transportGr,dropGr;
private INT			count,count2,result,result2,result3,result4,temp,buildX,buildY,baseX,baseY,tempX,tempY,maxy,maxx,miny,minx,outpostDist;
private INT			minAttackH,maxAttackH,maxOilGr,scoutX[2],scoutY[2],stuckX,stuckY,stuckTimes,maxTVtols,maxSVtols,maxDefenders;
private	INT			oilX,oilY;
private DROID			droid,tempDroid,outpostDroid,repDefendDroid[2],toRepDefendDroid[2],transportDroid,transportDroid2;
private	INT			numRetreats,NumOldDefenders,helpAllyPlayer,helpAllyPlayerX,helpAllyPlayerY;
private BOOL			boolResult,boolResult2,haveOutpost,powerSaving,defendingBase;
private FEATURE			feature,feature2;
private TEMPLATE		tmplChoice[5];
private STRUCTURE		structure,structure2;	//attackDerrick;

private BOOL			actPlayer[8],allyPlayer[8],debugMode,dropEnabled,alreadyAttacked,bigMap;
private BASEOBJ			baseobj,attackObject,defendObject,tVtolObject,sVtolObject;

private INT			numEnemies,Enemies[8],EnemyX[8],EnemyY[8],LZ_X,LZ_Y,transportZ,cybTemplate;
private	INT			allianceTime[8];

//------------------------------------------------------
//	Static private variables
//------------------------------------------------------
private INT			mainPhase,curLegoStr,TemplDepth,maxTrucks,curEnemy,curEnemyX,curEnemyY,dropPhase,
				attackPhase,maxScouts,extraStruct,curEnEdgeX,curEnEdgeY,KeepDist,numRushers,maxRepairing,maxRetreats,muchoPower;

//===============================================================================================
//
//						Triggers
//
//===============================================================================================

//------------------------------------------------------
//	Lego
//------------------------------------------------------
trigger StartGameTr			(wait, 10);
trigger LegoBuildTr			(every, 10);

//------------------------------------------------------
//	Rush
//------------------------------------------------------
trigger RushTr				(every, 30);
trigger RushControlTr			(every, 80);	//Was 80

//------------------------------------------------------
//	Rush preparations
//------------------------------------------------------
trigger BuildAttackForceTr		(every, 80);
trigger buildCyborgsTr			(every, 100);
trigger buildVtolsTr			(every, 100);
trigger doResearchTr			(every, 20);	
trigger buildDerricksTr			(every, 80);	//was 60
trigger sendScoutsTr			(every, 200);
trigger expandBaseTr			(every, 150);	//was 150
trigger buildDefensesTr			(every, 80);
trigger buildVtolPadsTr			(every, 80);
trigger basedetailsTr			(every, 50);
trigger oilDefensesTr			(every, 100);

//------------------------------------------------------
//	Other
//------------------------------------------------------
trigger droidDestroyedTr		(CALL_DROID_DESTROYED,  player, ref droid);
trigger nowTr				(wait, 1);
trigger keepTrackTr			(every, 60);
trigger chooseEnemyTr			(every, 70);
trigger LegoTrucksTr			(every, 10);
trigger buildPowerGeneratorsTr		(every, 60);
trigger droidBuiltTr			(CALL_NEWDROID,player, ref droid,ref structure);
trigger difficultyModTr			(every, 600);
trigger upgradeStructuresTr		(every, 50);
trigger moveIfAttackedTr		(CALL_DROID_ATTACKED, player, ref droid, ref baseobj);
trigger BuildOutpostTr			(every, 100);
trigger updateDetailsTr			(every, 40);
trigger savePowerTr			(every, 20);
trigger destroyOilTr			(every, 60);
trigger stuckTr				(every, 80);
trigger vtolAttackTr			(every, 50);
trigger vtolDefendTr			(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj);
trigger formAllianceEventTr		(every, 170);
trigger humanAllianceTr			(CALL_ALLIANCEOFFER,ref count, ref count2);
trigger	FinishStructuresTr		(every, 120);
trigger	repairStuffTr			(every, 130);
trigger	cyborgDropTr			(every, 999);
trigger	manageDropAttacksTr		(every, 999);
trigger WatchDefendBaseTr		(every, 160);	//was 200
trigger WatchHelpAllyTr			(every, 200);
trigger agressiveDefenceTr		(every, 80);
trigger additVTOLDefensesTr		(every, 180);
trigger	PowerBoostTr		(every, 50);	//Same as research timer

//===============================================================================================
//
//					Events
//
//===============================================================================================
event endPhaseOne;
event initializeRushPrep;
event BuildAttackForce;
event doResearch;
event buildDerricks;
event chooseEnemy;
event RushControl;
event sendScouts;
event expandBase;
event buildDefenses;
event basedetails;
event oilDefenses;
event LegoTrucks;
event stopAttack;
event BuildOutpost;
event updateDetails;
event savePower;
event destroyOil;
event buildVtolPads;
event StartGame;
event FinishStructures;
event WatchDefendBase;
event WatchHelpAlly;
event agressiveDefence;
event additVTOLDefenses;
event PowerBoost;


/*%? Help1	=	"This will only have an effect untill the early-mid - mid game.\n
After gaining the most vital technology and being low on power, 
GK will manage research speed by itself. 
You can only additionaly limit the speed, but you can't make GK do more research at that time." */

/*%? Help2	=	"Hint: play as AI ..." */


//===============================================================================================
//
//					[LEGO PHASE]
//
//===============================================================================================

//------------------------------------------------------
//	Initialize
//------------------------------------------------------
event StartGame(StartGameTr)
{

	//Initialize variables
	//--------------------
	mainPhase = 0;
	curLegoStr = 0;
	maxTrucks = 5;

	temp = random(16);
	if(temp > 12)
	{
		numRushers = 8;		//Early rush
	}
	else if((temp >= 5) and (temp <= 12))
	{
		numRushers = 17;	//Mass attack
	}
	else
	{
		numRushers = 12;	//Normal attack
	}

	curEnemy = -1;
	curEnemyX = -1;
	curEnemyY = -1;
	attackPhase = 0;
	TemplDepth = 1;				//From how many different templates to choose a template randomly, depends on res phase
	maxScouts = 1;				//Enable atleast 1 scout at startup, otherwise might take too long (if 20 attackers)
	extraStruct = 0;
	curEnEdgeX = -1;

	//Distance to keep of the enemy base when sending attackGr for regrouping
	KeepDist = (19 * 128);			/*%!	ID="OutpostDistance",
						MainDesc="Distance from GK outpost to enemy base",
						type="asn",		//Assign
						val="19",
						ArgDesc="19 Tiles (Default)",
						val="5",
						ArgDesc="5 Tiles",
						val="10",
						ArgDesc="10 Tiles",
						val="15",
						ArgDesc="15 Tiles",
						val="25",
						ArgDesc="25 Tiles",
						val="30",
						ArgDesc="30 Tiles"	*/



	minAttackH = 47;			//Min attack health. Retreat if < minAttackH
	maxAttackH = 90;			//Attack only if health > maxAttackH, must be bigger than minAttackH
	//numRepairing = 0;			//How many attackers are repairing at the moment
	haveOutpost = FALSE;			//Outpost to retreat to and where to repair damadged units
	powerSaving = FALSE;			//If we are in power saving mode
	defendingBase = FALSE;			//Attackers are currently defending the base
	maxOilGr = 4;				//Number of droids in the oilGr
	//attackOilX = -1;			//Coordinates of enemy derrick
	//attackOilY = -1;			//Coordinates of enemy derrick
	//attackDerrick = NULLOBJECT;		//No enemy derricks to attack yet
	maxTVtols = 8;				//Max number of antitank VTOLs
	maxSVtols = 10;				//Max number of antistructure  VTOLs
	maxDefenders = 5;			//Max number of defenders
	outpostDist = 0;			//Remember the distance between the enemy base and the outpost
	maxRetreats = 6;			//Max time to retreat before alloutattack
	muchoPower = 3500;			//If this amount of power is available, then start building expensive templates
	transportDroid = NULLOBJECT;		//Cyborg transport
	dropPhase = 0;				//Phase of the vurrent cyborg drop
	transportZ = 0;				//Height of the transport when landing
	cybTemplate = 0;			//Cyborg template to use for drops
	dropEnabled = FALSE;			//Wheather to drop or not to drop
	alreadyAttacked = FALSE;		//Wheather we have already attacked an enemy base atleast 1 time
	//toRepDefendDroid = NULLOBJECT;		//Defender, which is about to be repaired by the repair unit
	NumOldDefenders = 0;			//How many defenders there were, before base defence was turned on (revert to this number)
	
	helpAllyPlayer = -1;			//No ally in danger right now
	helpAllyPlayerX = -1;			//Coords of where to send help for the ally
	helpAllyPlayerY = -1;			//Coords of where to send help for the ally

	bigMap = FALSE;
	if((mapHeight > 150) and (mapWidth > 150))
	{
		bigMap = TRUE;
	}

	oilX = 0;
	oilY = 0;


	temp = (9 * 128);

	scoutX[0] = temp;				//Bottom left
	scoutY[0] = (mapHeight * 128) - temp;
	scoutX[1] = (mapWidth * 128) - temp;	//Top right
	scoutY[1] = temp;

	//Prepair features for future use
	//-------------------------------
	initGetFeature(oilRes,player,player);

	//Temp base
	//---------
	baseX = (128*mapWidth)/2;
	baseY = (128*mapHeight)/2;

	//Add all droids to a group and sort out constructors
	//---------------------------------------------------
	groupAddArea(tempGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
	initIterateGroup(tempGroup);
	droid = iterateGroup(tempGroup);
	while(droid != NULLOBJECT)
	{
		if(droid.droidType == DROID_CONSTRUCT)	//If a constructor
		{
			//forceDamageObject(droid, 50);

			baseX = droid.x;	//Base coordinates
			baseY = droid.y;

			droidLeaveGroup(droid);
			groupAddDroid(buildGroup,droid);
		}
		droid = iterateGroup(tempGroup);
	}


	//Send one truck to build factory
	//-------------------------------
	boolResult = FALSE;
	buildX = baseX;
	buildY = baseY;
	initIterateGroup(buildGroup);
	droid = iterateGroup(buildGroup);
	while((boolResult == FALSE) and (droid != NULLOBJECT))
	{
		if(droid.order == DORDER_NONE)
		{
			boolResult2 = pickStructLocation(factory, ref buildX, ref buildY,player);
			if(boolResult2 == TRUE)
			{
				orderDroidStatsLoc(droid, DORDER_BUILD, factory, buildX,buildY);
				boolResult = TRUE;
			}
		}
		droid = iterateGroup(buildGroup);
	}

	//transportDroid = addDroid(Transport, baseX, baseY, player);
}


//------------------------------------------------------
//	Build all necessary structures
//------------------------------------------------------
event LegoBuild(LegoBuildTr)
{
	//DERRICKS
	//--------
	initGetFeature(oilRes,player,player);
	feature = getFeature(player);
	if(feature != NULLOBJECT)
	{
		buildX = feature.x;
		buildY = feature.y;

		//If no no trucks already trying to build the same derrick
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		count = 0;
		while((droid != NULLOBJECT) and (count == 0))
		{
			if((droid.orderx == buildX) and (droid.ordery == buildY))
			{
				count = count + 1;	//Count trucks
			}
			droid = iterateGroup(buildGroup);
		}

		if(count == 0)		//Send only 1 truck to each derrick
		{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			boolResult = FALSE;
			while((boolResult == FALSE) and (droid != NULLOBJECT))
			{
				if(droid.order == DORDER_NONE)
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);
					boolResult = TRUE;
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}

	//Upgrade factories if it is T3
	//-----------------------------
	if(isStructureAvailable(facModule,player))		//If Factory module is already available
	{
		initEnumStruct(FALSE,factory,player,player);			
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			//if((skGetFactoryCapacity(structure) < 2) and (skCanBuildTemplate(player,structure, tmpl[0][8])))		//No fac module and T3 (if we have Trck Python HC)		
			if(skGetFactoryCapacity(structure) < 2)
			{
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				//boolResult = TRUE;			//Send only 1 truck
				//while((droid != NULLOBJECT) and (boolResult))
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE)
					{
						//boolResult = FALSE;
						orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x,structure.y);
					}
					droid = iterateGroup(buildGroup);
				}
			}
			structure = enumStruct();
		}
	}

	//STRUCTURES
	//----------
	if(curLegoStr < numLego)
	{
		buildX = baseX;
		buildY = baseY;
		droid = NULLOBJECT;
		boolResult = FALSE;

		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult == FALSE))
		{
			if(droid.order == DORDER_NONE)
			{
				boolResult2 = pickStructLocation(legoSt[curLegoStr], ref buildX, ref buildY,player);
				if(boolResult2 == TRUE)
				{
					tempDroid = droid;
					boolResult = TRUE;
				}
			}
			droid = iterateGroup(buildGroup);	//Next droid
		}

		//Find out if a truck is already building on the spot where another truck might try to build and will fail
		if(boolResult)
		{
			boolResult = TRUE;
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult == TRUE))
			{
				if(droid != tempDroid)
				{
					if(droid.order == DORDER_BUILD)
					{
						if((buildX == droid.orderx) and (buildY == droid.ordery))
						{
							boolResult = FALSE;
						}
					}
				}
				droid = iterateGroup(buildGroup);
			}
		}

		//Build
		if(boolResult)
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD,legoSt[curLegoStr], buildX,buildY);
			curLegoStr = curLegoStr + 1;
		}
	}

	//End Lego phase, start rush preparations
	//---------------------------------------
	if(mainPhase == 0)	//If not already activated
	{
		if(curLegoStr == (numLego - 1))		// (numLego - HQ)
		{
			setEventTrigger(endPhaseOne,nowTr);
		}
	}

	//Now that HQ is built we can deactivate it
	//-----------------------------------------
	if(curLegoStr == numLego)
	{
		setEventTrigger(LegoBuild, inactive);
	}
}


//------------------------------------------------------
//	End Lego phase, start rush preparations
//------------------------------------------------------
event endPhaseOne(inactive)
{
	//Start rush preparation phase
	//----------------------------
	setEventTrigger(doResearch,doResearchTr);
	setEventTrigger(buildDerricks,buildDerricksTr);
	setEventTrigger(initializeRushPrep,nowTr);
	setEventTrigger(RushControl,RushControlTr);
	//setEventTrigger(sendScouts,sendScoutsTr);
	setEventTrigger(expandBase,expandBaseTr);
	setEventTrigger(buildDefenses,buildDefensesTr);
	setEventTrigger(oilDefenses,oilDefensesTr);
	//setEventTrigger(updateDetails,updateDetailsTr);
	setEventTrigger(savePower,savePowerTr);
	setEventTrigger(destroyOil,destroyOilTr);
	setEventTrigger(buildVtolPads,buildVtolPadsTr);
	setEventTrigger(FinishStructures,FinishStructuresTr);

	setEventTrigger(LegoTrucks,inactive);
	setEventTrigger(endPhaseOne, inactive);
	
}

//=============================================================================================
//					[RUSH]
//=============================================================================================

//------------------------------------------------------
//	Send units to the outpost, near the enemy base
//------------------------------------------------------
event Rush(RushTr)
{
	if((sendOutpostGr.members + attackGroup.members + collectSendGr.members) > numRushers)
	{
		//setFogColour(random(200) + 50, 1, 1);
		if(curEnemy != -1)	//We have an enemy and not already on our way
		{
			//setFogColour(1, random(200) + 50, 1);
			if((curEnEdgeX > 0) and (attackPhase == 0))
			{
				maxTrucks = 12;							//Maximum number of the trucks to be built in this phase

				if(bigMap)
				{
					maxScouts = 3;
				}
				else
				{
					maxScouts = 2;
				}
				groupAddGroup(sendOutpostGr, collectSendGr);		//From collectSendGr to sendOutpostGr
				groupAddGroup(sendOutpostGr, attackGroup);		//From attackGroup to sendOutpostGr
				setGroupSecondary(sendOutpostGr, DSO_HALTTYPE, DSS_HALT_GUARD);	//Don't start attacking the base
				orderGroupLoc(sendOutpostGr, DORDER_MOVE, curEnEdgeX, curEnEdgeY);
				attackPhase = 1;						//On our way

				alreadyAttacked = TRUE;

				//If we were making an early rush then make sure we build more units before we attack again (otherwise will be slowly increased by 1)
				//if(numRushers < 10)
				//{
				//	numRushers = 10;
				//}

				setEventTrigger(BuildOutpost,BuildOutpostTr);		//Start building outpost
				setEventTrigger(Rush,inactive);
			}
		}
	}
}

//------------------------------------------------------
//	Cancel current attack
//------------------------------------------------------
event stopAttack(inactive)
{
	showConsoleText(DebugMsg[4], player);		//Attack stopped

	attackPhase = 0;
	curEnemy = -1;
	curEnEdgeX = -1;
	curEnEdgeY = -1;
	curEnemyX = -1;
	curEnemyY = -1;
	numRetreats = 0;

	groupAddGroup(sendOutpostGr, attackGroup);	//Add attackGroup to sendOutpostGr
	groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
	groupAddGroup(sendOutpostGr, repairedGroup);	//Add repairedGroup to sendOutpostGr
	groupAddGroup(repGr, repairedGroup);		//Add repGr to sendOutpostGr

	//setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);
	//orderGroupLoc(attackGroup, DORDER_MOVE,attackGroup.x,attackGroup.y);	//Collect them a bit
	setGroupSecondary(sendOutpostGr, DSO_HALTTYPE, DSS_HALT_GUARD);
	orderGroupLoc(sendOutpostGr, DORDER_MOVE,attackGroup.x,attackGroup.y);	//Collect them a bit
	setEventTrigger(Rush,RushTr);

	setEventTrigger(stopAttack,inactive);
}

//------------------------------------------------------
//	Control the attack
//------------------------------------------------------
event RushControl(inactive)
{
	//=====================================================================
	//		attackPhase explaination:
	//	0:	idle
	//	1:	on our way to the enemy 'edge' (waiting for regrouping)
	//	2:	on our way to the base
	//	3:	attacking
	//=====================================================================

	if((not defendingBase) and (helpAllyPlayer < 0))	//Attackers not busy
	{

		temp = (KeepDist / 2);			//Enemy base range

		//maxRepairing = numRushers * 3 / 7 + 1;		//Max number of units allowed to be repairing before retreating

		//Max number of units that may be going to repair at the same time before retreat
		//-------------------------------------------------------------------------------
		result = attackGroup.members + repGr.members;		//Total available units (+repGr units to make it more precise)

		//if(numRushers > attackGroup.members)
		//{
		//	result = numRushers;		//Use numRushers or number of attackers to calculate how many units may repair at a time (whatever number is bigger)
		//}

		maxRepairing = attackGroup.members * 3 / 7 + 2;		//Max number of units allowed to be repairing before retreating



		//------------------------
		//Stop attack if necessary
		//------------------------
		if((attackPhase > 0) and (curEnemy != -1))	//If dead
		{
			if(not actPlayer[curEnemy])
			{
			//Retreat if enemy is dead
				//------------------------
				setEventTrigger(stopAttack,nowTr);	//Cancel attack, clear variables
				attackPhase = 0;
			}
		}

		//Add units from collectSendGr to sendOutpostGr if we have a small group which can protect itself (prevent ant-tail)
		if(collectSendGr.members > 6)
		{
			groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
		}

		//-------------------------------------------------------------
		//Add units to attack group after they have reached the outpost
		//-------------------------------------------------------------
		if(attackPhase > 0)	//If on our way to the outpost
		{
			//If all attack units were killed or alloutattack, then make defend units attackers
			//---------------------------------------------------------------------------------
			if(((attackGroup.members + sendOutpostGr.members + repGr.members) < (numRushers / 2)) or (numRetreats > maxRetreats))
			{
				if(defendGr.members > (maxDefenders / 2))		//Enough defenders
				{
					showConsoleText(DebugMsg[5], player);		//Adding some defenders to attackers

					initIterateGroup(defendGr);
					droid = iterateGroup(defendGr);
					count = defendGr.members;
					count2 = defendGr.members;
					while((count > (count2 / 2)) and (droid != NULLOBJECT))	//Leave atleast 50% of available number of defenders
					{
						if(droid.droidType != DROID_REPAIR)		//Leave them the repair unit, so this will not screw up everything
						{
							groupAddDroid(sendOutpostGr, droid);	//Add to attackers
							count = count - 1;
						}
						droid = iterateGroup(defendGr);		//Next droid
					}

					toRepDefendDroid[0] = NULLOBJECT;		//Make repairer stop following this unit if it became an attacker
					toRepDefendDroid[1] = NULLOBJECT;
				}
			}

			//Do alloutattack if failed too many times already
			//------------------------------------------------
			if(numRetreats > maxRetreats)
			{
				//if(not defendingBase)		//(Done earlier now)
				//{
					showConsoleText(DebugMsg[3], player);		//Alloutattack
					groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
					groupAddGroup(sendOutpostGr, attackGroup);	//Add attackGroup to sendOutpostGr
					groupAddGroup(sendOutpostGr, scoutGroup[0]);	//Add scout group1 to sendOutpostGr
					groupAddGroup(sendOutpostGr, scoutGroup[1]);	//Add scout group2 to sendOutpostGr
					groupAddGroup(sendOutpostGr, oilGr);		//Add oil attacking group to sendOutpostGr
	
					numRetreats = 0;	//Reset (necessary?)
				//}
			}

			//Send newly-built units to the edge
			//----------------------------------
			boolResult = FALSE;
			if(((attackGroup.members + sendOutpostGr.members) > (numRushers / 2)) and (sendOutpostGr.members > 3))		//Check this condition only one time
			{
				//showConsoleText(DebugMsg[2], player);	//reinforcements on the way
				boolResult = TRUE;
			}

			//tempX = sendOutpostGr.x;			//Find center of the group
			//tempY = sendOutpostGr.y;
			//result = tempGroup.members;		//By accessing another group we make WZ clear the cached sendOutpostGr member variables, to reinitialize them next time we run this event (otherwise values won't change)

			initIterateGroup(sendOutpostGr);
			droid = iterateGroup(sendOutpostGr);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y, curEnEdgeX, curEnEdgeY) > temp)		//If not in the outpost
				{
					//Prevent the ant-tail, send units to the center of the group if too far away ahead
					//if(distBetweenTwoPoints(droid.orderx, droid.ordery, curEnEdgeX, curEnEdgeY) < temp)		//If was already sent to the outpost
					//{
					//	if(distBetweenTwoPoints(droid.x, droid.y, tempX, tempY) > (9 * 128))		//If too far away from its buddies
					//	{
					//		orderDroidLoc(droid, DORDER_MOVE, tempX, tempY);		//Prevent ant-tail, send unit back to the group center
					//	}
					//}
					//else

					if(distBetweenTwoPoints(droid.orderx, droid.ordery, curEnEdgeX, curEnEdgeY) >= temp)		//If not going to the outpost
					{
						if(boolResult == TRUE)		//Condition checked before
						{
							setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);
							result = (7 * 128);
							//orderDroidLoc(droid, DORDER_MOVE, curEnEdgeX + random(result) - (result/2), curEnEdgeY + random(result) - (result/2));		//Send to the outpost
							orderDroidLoc(droid, DORDER_SCOUT, curEnEdgeX + random(result) - (result/2), curEnEdgeY + random(result) - (result/2));		//Send to the outpost
						}
					}
				}
				else	//Add to attackers if reached outpost
				{
					//droidLeaveGroup(droid);
					groupAddDroid(attackGroup,droid);
				}
				droid = iterateGroup(sendOutpostGr);		//Next droid
			}

			//-------------------------------------------
			//Add repaired units back to the attack group
			//-------------------------------------------
			initIterateGroup(repGr);
			droid = iterateGroup(repGr);
			while(droid != NULLOBJECT)
			{

				if((droid.health > 85) or (not haveOutpost))	//Don't have to or can't repair
				{
					groupAddDroid(repairedGroup, droid);	//Collect them, add to a temporary group to prevent ant-tail
				}
				else	//Re-send to repair
				{
					if((droid.health < 85)  and (haveOutpost) and  (droid.order != DORDER_RTR))	//Has to and can repair and not going to repair
					{
						orderDroid(droid, DORDER_RTR);		//Re-order to repair
					}
				}

			/*
				if((droid.health < 85) and (haveOutpost) and (droid.order != DORDER_RTR))
				{	
					//if(droid.order != DORDER_RTR)			//If not going to repair
					//{
						orderDroid(droid, DORDER_RTR);		//Order to repair
					//}
				}
				else		//If already repaired or can't repair
				{
					if(((droid.health > 85) or (not haveOutpost)) and (droid.order != DORDER_RTR))			//If not going to repair
					{
						//droidLeaveGroup(droid);
						//groupAddDroid(attackGroup, droid);	//Add to attackers
						groupAddDroid(repairedGroup, droid);	//Collect them, add to a temporary group to prevent ant-tail
					}
				}
			*/

				droid = iterateGroup(repGr);			//Next droid
			}

			//If units are far (already attacking enemy base) then wait for more peraired units
			if(attackPhase > 2)
			{
				result = 3;
				if(repGr.members > 7)
				{
					result = 6;		//Wait for more repaired units, if many of them are going to repair, before sending back to enemy
				}
				
				if(repairedGroup.members > result)	//Prevent ant-tail while attacking
				{
					groupAddGroup(sendOutpostGr, repairedGroup);	//Add back to action
				}
			}
			else
			{
				groupAddGroup(attackGroup, repairedGroup);	//Add back to attackers directly
			}

			//Remove unit from the attack group if it is goint to repair
			//----------------------------------------------------------
			initIterateGroup(attackGroup);
			droid = iterateGroup(attackGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_RTR)			//If going to repair
				{
					//droidLeaveGroup(droid);
					setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);		//Don't pursue, guard position
					groupAddDroid(repGr, droid);		//Add to repair group
			
				}
				droid = iterateGroup(attackGroup);		//Next droid
			}
		}


		//------------------------------------------------------------------
		//Start attacking enemy base if most of the units are in the outpost
		//------------------------------------------------------------------
		if(attackPhase == 1)		//If on our way to the outpost
		{
			//Check if we can start our invasion
			//----------------------------------
			//if(attackGroup.members > numRushers)			//If we have enough units
			//{
				boolResult = FALSE;
				//if(numRepairing == 0)
				//{
					if(haveOutpost == TRUE)
					{
						boolResult = TRUE;	//Repair units with light damage
					}
				//}

				//Find idle repair facility
				//-------------------------
				//structure2 = NULLOBJECT;
				//initEnumStruct(FALSE,factory,player,player);
				//structure = enumStruct();
				//while(structure != NULLOBJECT)
				//{
				//	if(structureIdle(structure) == TRUE)
				//	{
				//		structure2 = structure;
				//	}
				//	structure = enumStruct();
				//}

				//Count idle units
				//----------------
				result2 = repGr.members;
				result = 0;
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);
				while(droid != NULLOBJECT)
				{
					if((droid.order == DORDER_NONE) or ((droid.orderx == curEnEdgeX) and (droid.ordery == curEnEdgeY)))	//Not moving or retreating	//Was != DORDER_MOVE
					{
						result = result + 1;		//Num of idle units

						//Repair units with light damage
						//------------------------------
						//if((droid.health < 60) and (boolResult) and ((result2 + 2) < maxRepairing))	//If it's damaged a bit and can repair, don't sent to rpare too many units, keep number under maxRepairing
						if((droid.health < 70) and (boolResult))	//If it's damaged a bit and can repair
						{
							orderDroid(droid, DORDER_RTR);	//Repair unit
							result2 = result2 + 1;
						}
					}
					droid = iterateGroup(attackGroup);
				}

				//Send to the enemy base if everything's ok
				//-----------------------------------------
				if((attackGroup.members) > numRushers)		//If have enough units ready to attack
				{
					boolResult = FALSE;
					if(isHumanPlayer(curEnemy))		//Move instead of scout if attacking human
					{
						boolResult = TRUE;
					}

					//result2 = (result * 100 / attackGroup.members);

					//if((result2 > 60) or (result >= numRushers))				// > 60% of the entire group is ready for attack, or have enough, even if many repairing
					//{
						if(((haveOutpost) and (attackGroup.health >= maxAttackH)) or (haveOutpost == FALSE))
						{
							//if((numRepairing < (attackGroup.members / 2)) and (repGr.members < (numRushers / 4)))		//If not too many attackers repairing
							if(repGr.members < (maxRepairing / 2))	//Not too many repairing otherwise wait until repaired
							{
								//Send to the enemy base
								//----------------------
								attackPhase = 2;
								showConsoleText(DebugMsg[2], player);	//Starting attack
								setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);

								//if(boolResult == TRUE)		//If human
								//{
								//	orderGroupLoc(attackGroup, DORDER_MOVE, curEnemyX, curEnemyY);
								//}
								//else					//AI
								//{
									orderGroupLoc(attackGroup, DORDER_SCOUT, curEnemyX, curEnemyY);
								//}
							}
						}
					//}
				}
			//}
		}


		//-------------------------------
		//Sending to the enemy base rules
		//-------------------------------
		if(attackPhase > 1)	//If goint to the enemy base or already reached it
		{
			//If attack failed
			//----------------
			//if((attackGroup.members < (numRushers * 2 / 3)) or ((haveOutpost) and (attackGroup.health < minAttackH)) or (numRepairing >= (attackGroup.members / 2)) or (repGr.members > maxRepairing))	//If not enough units available

			boolResult = FALSE;

			if(attackGroup.members < 6)	//Not enough units left 
			{
				showConsoleText(DebugMsg[6], player);		//Not enough units left 
				boolResult = TRUE;
			}

			//else if((haveOutpost) and (attackGroup.health < minAttackH))	//Too many damaged units
			//{
			//	showConsoleText(DebugMsg[5], player);			//Too many damaged units
			//	boolResult = TRUE;
			//}
			//if(repGr.members >= maxRepairing)	//Too many repairing
			//{
			//	showConsoleText(DebugMsg[4], player);		//Too many repairing
			//	boolResult = TRUE;
			//}
			//else if(attackGroup.members < (numRushers * 2 / 5))	//If not enough units available
			//{
			//	showConsoleText(DebugMsg[6], player);		//Not enough units left 
			//	boolResult = TRUE;
			//}

			if(boolResult)		//Cancel attack, retreat
			{
				attackPhase = 1;
				setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);
				orderGroupLoc(attackGroup, DORDER_MOVE, curEnEdgeX, curEnEdgeY);	//Retreat
				numRushers = numRushers + 2;	//Increase number of attackers
				if(numRushers > 40)
				{
					numRushers = 40;
				}

				numRetreats = numRetreats + 1;		//Remember how many times our attacks failed
			}
			else		//If enough units available
			{
				boolResult = FALSE;
				if(isHumanPlayer(curEnemy))		//Move instead of scout if attacking human
				{
					boolResult = TRUE;
				}

				//--------------------------------------------------
				//Send newly-arrived units (outpost units) to attack
				//--------------------------------------------------
				//tempX = attackGroup.x;			//Find center of the group
				//tempY = attackGroup.y;
				//result = tempGroup.members;		//By accessing another group we make WZ clear the cached sendOutpostGr member variables, to reinitialize them next time we run this event (otherwise values won't change)
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);

				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y, curEnemyX, curEnemyY) > temp)		//If not in the enemy base
					{
						if((droid.order == DORDER_NONE) or ((droid.orderx != curEnemyX) and (droid.ordery != curEnemyY)))		//Idle, or going somewhere else, but not to the enemy base
						{
							setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);
							//if(boolResult == TRUE)		//Human
							//{
							//	orderDroidLoc(droid, DORDER_MOVE, curEnemyX, curEnemyY);
							//}
							//else			//AI
							//{
								orderDroidLoc(droid, DORDER_SCOUT, curEnemyX, curEnemyY);
							//}
						}
						//else	//If already on the way to the enemy base
						//{
						//	//Prevent the ant-tail, send units to the center of the group if too far away ahead
						//	if(distBetweenTwoPoints(droid.x, droid.y, tempX, tempY) > (9 * 128))		//If too far away from its buddies
						//	{
						//		orderDroidLoc(droid, DORDER_MOVE, tempX, tempY);		//Prevent ant-tail, send unit back to the group center
						//	}
						//}
					}
					else				//Already in the enemy base
					{
						if(attackPhase != 3)
						{
							showConsoleText(DebugMsg[7], player);		//Reached enemy base
						}

						attackPhase = 3;
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);	//Persue. For more efficient structure targeting.
					}
					droid = iterateGroup(attackGroup);		//Next droid
				}
			}
		}


		//------------
		//Attack rules
		//------------
		if(attackPhase == 3)			//If attacking
		{
			//If we were making an early rush then make sure we build more units before we attack again (otherwise will be slowly increased by 1)
			if(numRushers < 10)
			{
				numRushers = 10;
			}

			//They are repairing bunker we attack! Eliminate the truck
			//--------------------------------------------------------
			boolResult = FALSE;
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);
			tempDroid = droidTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
			if(tempDroid != NULLOBJECT)
			{
				if(tempDroid.droidType == DROID_CONSTRUCT)
				{
					//Order droid close to the truck to attack it
					//-------------------------------------------
					boolResult = TRUE;
					initIterateGroup(attackGroup);
					droid = iterateGroup(attackGroup);
					while(droid != NULLOBJECT)
					{
						if(distBetweenTwoPoints(droid.x, droid.y, tempDroid.x, tempDroid.y) < (10 * 128))
						//if(losTwoObjects(droid, tempDroid, TRUE))	//If can see truck
						{
							orderDroidObj(droid, DORDER_ATTACK,tempDroid);
							attackObject = tempDroid;
						}
						droid = iterateGroup(attackGroup);
					}
				}
			}

			//Hi-priority structures
			//----------------------
			count = numAttackStructs - 1;
			while(count >= 0)
			{
				result = (15 * 128);
				initEnumStruct(FALSE,attackStructs[count],curEnemy,player);			
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(curEnemyX, curEnemyY, structure.x, structure.y) < result)		//If in the enemy base
					{
						boolResult = TRUE;
						initIterateGroup(attackGroup);
						droid = iterateGroup(attackGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order != DORDER_ATTACK)	//Not already attacking
							{
								//if(distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < (12 * 128))
								if(losTwoObjects(droid, structure, FALSE))	//If can see this structure
								{
									orderDroidObj(droid, DORDER_ATTACK, structure);
									sVtolObject = structure;
								}
							}
							droid = iterateGroup(attackGroup);
						}
					}
					structure = enumStruct();
				}
				count = count - 1;
			}

			if(boolResult == FALSE)		//Factories
			{
				resetStructTargets();
				setStructTarPref(ST_FACTORY);
				structure = structTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
				if(structure != NULLOBJECT)
				{
					//Order droid close to the factory to attack it
					initIterateGroup(attackGroup);
					droid = iterateGroup(attackGroup);
					while(droid != NULLOBJECT)
					{
						if(distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < (10 * 128))
						{
							orderDroidObj(droid, DORDER_ATTACK,structure);
							attackObject = structure;
						}
						droid = iterateGroup(attackGroup);
					}
				}
			}
		}

		//--------------------------------------------------------
		//Allow repairing if we have repair facilities in outposts
		//--------------------------------------------------------
		if(haveOutpost)
		{
			setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_HIGH);
		}
		else
		{
			setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
		}
	}
}

//------------------------------------------------------
//Finish part-built structures
//------------------------------------------------------
event FinishStructures(inactive)
{
	//Find structure closest to the base
	//----------------------------------
	temp = tempGroup.members;		//Reset cached buildGroup values
	result = 99999;
	structure2 = NULLOBJECT;
	initEnumStruct(TRUE,derrick,player,player);		//TRUE: iterate through all structures
	structure= enumStruct();
	while(structure != NULLOBJECT)
	{
		if(not structureComplete(structure))		//If structure not finished
		{
			//Check if anybody is building it already
			//---------------------------------------
			boolResult = TRUE;
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult))
			{
				if((droid.orderx == structure.x) and (droid.ordery == structure.y)) 
				{
					boolResult = FALSE;			//Somebody is building it, try next structure
				}
				droid = iterateGroup(buildGroup);
			}

			//Make sure it is not an Outpost defense (since outpost builder is not in the buildGroup)
			//--------------------------------------
			if(boolResult)
			{
				if(outpostDroid != NULLOBJECT)
				{
					if((outpostDroid.orderx == structure.x) and (outpostDroid.ordery == structure.y))
					{
						boolResult = FALSE;		//Don't finish building this structure
					}
				}
			}

			//Remember this structure if it is the closest one so far
			//-------------------------------------------------------
			if(boolResult)						//If nobody is building it already
			{
				result2 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);		//How far away from the base
				if(result2 < result)				//If this structure is closer than the last one, then store it instead of the last one
				{
					result = result2;
					structure2 = structure;			//Remember this structure
				}
			}
		}
		structure = enumStruct();
	}

	//Finish building structure, if there are any
	//-------------------------------------------
	if((structure2 != NULLOBJECT) and (boolResult))			//If found an unbuilt structure and nobody is building it already
	{
		//Find closest truck
		//------------------
		result = 99999;
		tempDroid = NULLOBJECT;
		initIterateGroup(buildGroup);				// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)			//If idle
			{
				result2 = distBetweenTwoPoints(droid.x, droid.y, structure2.x, structure2.y);		//How far away this truck is from the unfinished structure
				if(result2 < result)
				{
					result = result2;
					tempDroid = droid;		//Remember this truck, it is the closest so far
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Send to build if found a truck
		//------------------------------
		if(tempDroid != NULLOBJECT)
		{
			orderDroidObj(tempDroid,DORDER_HELPBUILD,structure2);
		}
	}
}

//------------------------------------------------------
//Destroy enemy derricks
//------------------------------------------------------
event destroyOil(inactive)
{
	if(idleGroup(oilGr) > (oilGr.members / 2))
	{
		if(oilGr.members >= maxOilGr)
		{
			boolResult = FALSE;
			//if(attackDerrick != NULLOBJECT)		//If we have derrick to attack
			if(oilX > 0)
			{
				temp = (4 * 128);
				count = 0;
				while((count < numEnemies) and (boolResult == FALSE))
				{
					boolResult = structInArea(Enemies[count], oilX - temp, oilY - temp, oilX + temp, oilY + temp);
					count = count + 1;
				}
			}

			//Find new derrick
			if(boolResult == FALSE)		//No structures found in the area or first search
			{
				//Find closest enemy derrick
				//--------------------------
				oilX = 0;
				result = 99999;
				structure2 = NULLOBJECT;
				count = 0;
				while(count < numEnemies)
				{
					temp = 2432;	//19 * 128
					initEnumStruct(FALSE,derrick,Enemies[count],Enemies[count]);
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						if(EnemyX[count] > 0)
						{
							if(distBetweenTwoPoints(structure.x, structure.y, EnemyX[count], EnemyY[count]) > temp)		//Not in the enemy base
							{
								result2 = distBetweenTwoPoints(baseX, baseY, structure.x,structure.y);
								if(result2 < result)
								{
									result = result2;
									structure2 = structure;
								}
							}
						}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//Assign to the found object
				//--------------------------
				if(structure2 != NULLOBJECT)
				{
					//attackDerrick = structure2;
					oilX = structure2.x;
					oilY = structure2.y;
					boolResult = TRUE;
				}
			}

			if(boolResult == TRUE)
			{
				orderGroupLoc(oilGr, DORDER_MOVE, oilX, oilY);
			}
		}
	}

	//Manage oil attack when arrived, destroy derrick if we can get it
	//----------------------------------------------------------------
	//if(oilX > 0)		//If we have an enemy derrick to attack
	//{
	//	initIterateGroup(oilGr);
	//	droid = iterateGroup(oilGr);
	//	while(droid != NULLOBJECT)
	//	{
	//		//if(distBetweenTwoPoints(attackDerrick.x, attackDerrick.y, droid.x, droid.y) < (7 128))	//If close
	//		if(losTwoObjects(droid, attackDerrick, TRUE))	//If we can shoot at the derrick
	//		{
	//			orderDroidObj(droid, DORDER_ATTACK, attackDerrick);
	//		}
	//		droid = iterateGroup(oilGr);
	//	}
	//}
}

//------------------------------------------------------
//	Find most suitabe enemy
//------------------------------------------------------
event chooseEnemy(chooseEnemyTr)
{

	//if((curEnemy == -1) and (numEnemies > 0))
	if(numEnemies > 0)
	{
		if((sendOutpostGr.members + attackGroup.members + collectSendGr.members) > numRushers)
		{
			temp = -1;	//Temp enemy
			count = 0;
			result = 99999;
			while(count < numEnemies)
			{
				if((isHumanPlayer(Enemies[count])) and (EnemyX[count] > 0))
				{
					result2 = distBetweenTwoPoints(baseX, baseY, EnemyX[count], EnemyY[count]);
					if(result2 < result)
					{
						result = result2;	//Remember closest distance so far
						result3 = result2;	//Remember for later use
						temp = Enemies[count];
					}
				}
				count = count + 1;
			}

			//If no human players, find the closest AI
			if(temp == -1)
			{
				result = 99999;
				count = 0;
				while(count < numEnemies)
				{
					if(EnemyX[count] > 0)
					{
						result2 = distBetweenTwoPoints(baseX, baseY, EnemyX[count], EnemyY[count]);
						if(result2 < result)
						{
							result = result2;	//Remember closest distance so far
							result3 = result2;	//For later use
							temp = Enemies[count];
						}
					}
					count = count + 1;
				}
			}
			

			//Change enemy only if new enemy is *much* closer (20 tiles)
			//----------------------------------------------------------
			if(curEnemyX > 0)
			{
				result = distBetweenTwoPoints(baseX, baseY, curEnemyX, curEnemyY) + (20 * 128);
			}

			if(((curEnemyX > 0) and (result3 > result)) or (curEnemyX < 1))	//If already have enemy and new enemy is much closer or no enemy set yet
			{
				curEnemy = temp;	//Remember 'best' enemy
				numRetreats = 0;	//Reset, need to do it in a better place to make generic
			}
		}
	}

	
	//Find bases again even if (curEnemy != -1) so that attackers could find next factory if its far away
	//---------------------------------------------------------------------------------------------------
	count = 0;
	while(count < numEnemies)
	{

		//-----------------------
		//	Find enemy's base
		//-----------------------
		tempX = baseX;
		tempY = baseY;

		//Store enemy base coords, find closest structure
		//-----------------------------------------------
		EnemyX[count] = -1;
		EnemyY[count] = -1;
		result = 99999;
		count2 = 0;
		while(count2 < numBaseStructs)		//For all base structures
		{
			initEnumStruct(FALSE,baseStructs[count2],Enemies[count],Enemies[count]);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				//if(structureComplete(structure))
				//{
					result2 = distBetweenTwoPoints(tempX, tempY, structure.x, structure.y);
					if(result2 < result)
					{
						result = result2;
						EnemyX[count] = structure.x;
						EnemyY[count] = structure.y;
					}
				//}
				structure = enumStruct();
			}
			count2 = count2 + 1;
		}

		//Remember coordinates of the enemy
		//---------------------------------
		if(Enemies[count] == curEnemy)
		{
			
			if((EnemyX[count] != -1) and (EnemyY[count] != -1))
			{
				curEnemyX = EnemyX[count];
				curEnemyY = EnemyY[count];
			}

			result = distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, curEnemyX, curEnemyY);		//If base moved too much
			if((curEnEdgeX == -1) or ((result + (6 * 128)) < outpostDist) or ((result - (6 * 128)) > outpostDist) )	//If no outpost coord yet or enemy base moved too much
			{
				//Find 'edge' of the base
				//-----------------------
				curEnEdgeX = -1;
				curEnEdgeY = -1;
				result = 99999;
				count2 = 0;

				tempX = baseX;
				tempY = baseY;

				curEnEdgeX = curEnemyX;
				curEnEdgeY = curEnemyY;

				//Calculate destination point of the attack group for regrouping
				//--------------------------------------------------------------
				if(curEnEdgeX != -1)
				{
					result = 1;	//KeepDist;	//Assume enemy base to the left
					result2 = 1;	//KeepDist;	//Assume enemy base above the base

					if(curEnEdgeX > maxx)		//Enemy base to the right
					{
						result = result * (-1);	//Go to the left from the enemy base for oupost
					}
					else if(curEnEdgeX > minx)	//Almost on the same X level
					{
						result = 0;
					}

					if(curEnEdgeY > maxy)		//Enemy base lower to the base
					{
						result2 = result2 * (-1);	//Go up for the outpot y coord
					}
					else if(curEnEdgeY > miny)	//Almost on the same Y level
					{
						result2 = 0;
					}

					curEnEdgeX = curEnEdgeX + (result * KeepDist);
					curEnEdgeY = curEnEdgeY + (result2 * KeepDist);

					//Check limits
					if(curEnEdgeX < 0)
					{
						curEnEdgeX = (4 * 128);
					}
					if(curEnEdgeY < 0)
					{
						curEnEdgeY = (4 * 128);
					}
					if(curEnEdgeX > (128 * mapWidth))
					{
						curEnEdgeX = ((128 * mapWidth) - (4 * 128));
					}
					if(curEnEdgeY > (128 * mapHeight))
					{
						curEnEdgeY = ((128*mapHeight) - (4 * 128));
					}

					outpostDist = distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, curEnemyX, curEnemyY);
					boolResult = pickStructLocation(factory, ref curEnEdgeX, ref curEnEdgeY,player);
					if(boolResult == FALSE)
					{
						curEnEdgeX = -1;
						curEnEdgeY = -1;
					}
					
/*
					//--------------------------
					//Pathfinding
					//--------------------------
					//result and result2 are directions
					temp = 0;
					result3 = 0;			//Final lenght between enemy base and outpost in tiles
					result4 = 150;			//Max number of iterations (in tiles)

					tempX = curEnemyX + (result * 512);	//Skip 4 tiles in outpost's direction
					tempY = curEnemyY + (result2 * 512);	//Skip 4 tiles in outpost's direction

					//Round to 128 (+ 64)
					tempX  = tempX / 128;
					tempX  = tempX * 128 + 64;

					tempY = tempY / 128;
					tempY = tempY * 128 + 64;

					boolResult = TRUE;		//Horizontal direction not blocked
					boolResult2 = TRUE;		//Vertical direction not blocked
					while((result4 > 0) and (result3 < 85))		//while still tries left and dist less than 50 tiles
					{
						//---------------------------------------------
						//Choose new coordinates
						//---------------------------------------------
						if(temp == 0)	//Move Horizontally
						{
							buildX = tempX + (result * 128);		//Move 1 tile in outpost's direction horizontaly (x)
							buildY = tempY;
						}
						else		//Move vertically
						{
							buildX = tempX;
							buildY = tempY + (result2 * 128);	//Move 1 tile in outpost's direction vertically (y)
						}

						//---------------------------------------------
						//Check new location with a wall
						//---------------------------------------------
						count = buildX;	//Remember to compare later
						count2 = buildY;

						if(pickStructLocation(wall, ref buildX, ref buildY, player))	//Try this location
						{
							
							if((count != (buildX + 128)) or (count2 != (buildY + 128)))	//If this location is not accessible (building coords were modified)
							{
								//turnPowerOff();
								//setPowerLevel(buildX, player);
								//addStructure( vtolPad, player, tempX - (3 * 128) , tempY );	//DEBUG
			showConsoleText(DebugMsg[2], player);

								if(temp == 0)		//Moving horizontally
								{
									boolResult = FALSE;	//Can't move horizontally
								}
								else			//Moving vertically
								{
									boolResult2 = FALSE;	//Can't move vertically
								}
							}
							else	//This tile is ok
							{
			showConsoleText(DebugMsg[3], player);
			addStructure( wall, player, count  , count2 );	//DEBUG

								tempX = count;	//Remember new coords permanently
								tempY = count2;	//Remember new coords permanently

								if(temp == 0)		//Moving horizontally
								{
									boolResult = TRUE;	//Cancel direction blockage flag, if was blocked
								}
								else			//Moving vertically
								{
									boolResult2 = TRUE;	//Cancel direction blockage flag, if was blocked
								}

								result3 = result3 + 1;		//Moved 1 tile
							}
						}

						//------------------------------------------------
						//If can't move further in the outpost's direction
						//------------------------------------------------
						if((not boolResult) and (not boolResult2))	//If both directions blocked (hor and vert)
						{
			showConsoleText(DebugMsg[1], player);
							if(temp==0)	//Was moving horizontally this time (X)
							{
								buildY = tempY - (result2 * 128);
								buildX = tempX;
								count = buildX;		//Remember to compare later
								count2 = buildY;
								pickStructLocation(wall, ref buildX, ref buildY,player);	//Try this location
								if((count == (buildX + 128)) and (count2 == (buildY + 128)))	//If this location is accessible (building coords were same)
								{
									temp = 1;
									tempY = count2;
									tempX = count;
									boolResult2 = TRUE;	//Reset Vertical blockage
								}
							}
							else	//Was moving vertically this time (Y)
							{
								buildX = tempX - (result * 128);	//Move 1 tile back (reversed) into a horizontal direction
								buildY = tempY;
								count = buildX;		//Remember to compare later
								count2 = buildY;
								pickStructLocation(wall, ref buildX, ref buildY,player);	//Try this location
								if((count == (buildX + 128)) and (count2 == (buildY + 128)))	//If this location is accessible (building coords were same)
								{
									temp = 0;		//Move vertically again next time (temp will be set to 1 later)
									tempX = count;		//Remember new X position
									tempY = count2;
									boolResult = TRUE;	//Reset Horizontal blockage
								}
							}

							//boolResult = TRUE;	//Reset Horizontal blockage
							//boolResult2 = TRUE;	//Reset Vertical blockage
						}

						//--------------------------------
						//Cycle moving direction
						//--------------------------------
						if(temp == 0)
						{
							temp = 1;		//Vertically next time
						}
						else
						{
							temp = 0;		//Horizontally next time
						}
						

						result4 = result4 - 1;
					}

					if(tempX < 0)
					{
						tempX = (4 * 128);
					}
					if(tempY < 0)
					{
						tempY = (4 * 128);
					}
					if(tempX > (128 * mapWidth))
					{
						tempX = ((128 * mapWidth) - (4 * 128));
					}
					if(tempY > (128 * mapHeight))
					{
						tempY = ((128*mapHeight) - (4 * 128));
					}

					centreViewPos(tempX, tempY);
*/


				}
			}
			
		}
		count = count + 1;
	}
}

//==============================================================================================
//
//					[RUSH PREPARATION]
//
//==============================================================================================


//------------------------------------------------------
//	Initialize rush preparation phase.
//------------------------------------------------------
event initializeRushPrep(inactive)
{
	mainPhase = 1;			//Next phase became active
}

//------------------------------------------------------
//	Build attack units
//------------------------------------------------------
event BuildAttackForce(BuildAttackForceTr)
{
	//Enable more trucks after 15 mins, if got stuck in Lego phase somehow
	if(gameTime > 9000)
	{
		maxTrucks = 12;
	}

	//Manage truck production
	//-----------------------
	result2 = 0;	//Number of trucks we started building (don't build too many at one time since we can't count how many of them will get built)		
	temp = 2;	//How many trucks to build at a time

	//if(buildGroup.members == 0)
	//{
	//	temp = 5;	//Build more trucks at a time
	//}

	temp = maxTrucks - buildGroup.members;
	if(temp > 4)
	{
		temp = 5;	//How many trucks to build at a time
	}

	//Build units
	//-----------
	result = 0;	//Index of the current factory (count factories)
	initEnumStruct(FALSE,factory,player,player);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if((structureIdle(structure) == TRUE) and (structureComplete(structure)))
		{
			boolResult = TRUE;	//Didn't start building anything yet

			//We have not enough trucks
			//-------------------------
			if(boolResult)
			{
				if((buildGroup.members < maxTrucks) and (result2 < temp))	//Only <temp> trucks at a time
				{
					buildDroid(constructor, structure, player, 1);	//Normal one
					result2 = result2 + 1;		//Count trucks
					boolResult = FALSE;
				}
			}

			if(boolResult)		//Didn't start build anything yet
			{
				if((attackPhase > 0) and (result == 0) and (not defendingBase))	//If no repair unit and we already have enough attackers, use only 1 factory (result == 0)
				{
					if(repDefendDroid[0] == NULLOBJECT)
					{
						boolResult = FALSE;
					}
					else if(repDefendDroid[1] == NULLOBJECT)
					{
						boolResult = FALSE;
					}
				}

				if(not boolResult)	//If decided to build a repair unit
				{
					if(skCanBuildTemplate(player,structure, tmplRep[1]))
					{
						buildDroid(tmplRep[1], structure, player, 1);	//Heavy repair unit
					}
					else
					{
						buildDroid(tmplRep[0], structure, player, 1);	//Light repair unit
					}
				}
				
			}

			//Attack units
			//----------------------
			if(boolResult)		//Didn't start build anything yet
			{
				//Decide weather to use cheap or expensive templates
				//--------------------------------------------------
				result3 = 0;			//Cheap templates
				if(playerPower(player) > muchoPower)
				{
					result3 = 1;		//Use expensive templates if we have plenty of power
				}

				//Fill array with best templates
				//------------------------------
				count2 = 0;
				count = numTemplates - 1;
				while((count2 < TemplDepth) and (count >= 0))
				{
					if(skCanBuildTemplate(player,structure, tmpl[result3][count]))
					{
						//setFogColour(random(200) + 50, 1, 1);

						tmplChoice[count2] = tmpl[result3][count];
						count2 = count2 + 1;		//We have chosen one more template
					}
					count = count - 1;			//Check next template
				}

				if(count2 > 0)		//Any templates found
				{
					
					if(getDroidCount(player) < 85)	//Let it build VTOLs and trucks
					{
						boolResult = FALSE;
						buildDroid(tmplChoice[random(count2)],structure,player,1);
					}
				}
			}
		}
		result = result + 1;		//Remember factory index
		structure = enumStruct();
	}
}

//--------------------------------------------------------
//Build cyborgs
//--------------------------------------------------------
event buildCyborgs(buildCyborgsTr)
{
	if((transportGr.members < 10) and (dropGr.members < 6) and (dropPhase == 0))
	{
		if(getStructure(vtolFactory,player) != NULLOBJECT)	//Already have VTOL tech to build transporter soon?
		{
			if(dropEnabled and (not powerSaving))
			{
				initEnumStruct(FALSE,cybFactory,player,player);
				structure= enumStruct();					//Find factory
				while(structure != NULLOBJECT)
				{
					if(structureIdle(structure))
					{

				//count = 1;		//numTemplates - 1
				//count2 = 0;
				//while(count >= 0)
				//{
				//	if(skCanBuildTemplate(player,structure, cybTmpl[count]) )
				//	{
				//		tmplChoice[count2] = cybTmpl[count];
				//		count2 = count2 + 1;
				//	}
				//	count = count - 1;
				//}

						if(cybTemplate > -1)
						{
							buildDroid(cybTmpl[cybTemplate],structure,player,1);
						}		
					}
					structure= enumStruct();
				}
			}
		}
	}

}


//------------------------------------------------------
//	Research Stuff
//------------------------------------------------------
event doResearch(doResearchTr)
{
	//Count how many are already researching
	//--------------------------------------
	initEnumStruct(FALSE,resLab,player,player);
	structure = enumStruct();
	result = 0;
	while(structure != NULLOBJECT)
	{
		if(not structureIdle(structure))	//Max 2 res fac if low on power
		{
			result = result + 1;
		}
		structure = enumStruct();
	}

	temp = 2;		/*%!	ID="MaxResFacLowPower",
					MainDesc="When low on power limit research to x facilities",
					MoreInfo="<Help1>",
					type="asn",		//Assign
					val="2",
					ArgDesc="2 (Default)",
					val="0",
					ArgDesc="Pause researching",
					val="1",
					ArgDesc="1",
					val="3",
					ArgDesc="3",
					val="4",
					ArgDesc="4",
					val="5",
					ArgDesc="5",
					val="6",
					ArgDesc="6",
					val="7",
					ArgDesc="7",
					val="-1",
					ArgDesc="Don't limit"	*/


	//Research
	//--------
	initEnumStruct(FALSE,resLab,player,player);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureIdle(structure))	//Not researching already
		{
			if((not powerSaving) or (powerSaving and (result < temp)) or (temp == -1))		//Max 2 res fac if low on power (if enough power or low power, but still not enough res labs working)
			{
			
				if(not ((mainPhase >= 2) and (result >= 3) and (playerPower(player) < 600)))		//If we already have Trck Python HC template (and low on power) then don't use more then 3 res fac, since no new usefull tech
				{
					skDoResearch(structure,player,0);
					result = result + 1;
				}
			}
		}
		structure = enumStruct();
	}
}


//------------------------------------------------------
//	Build derricks with nearest truck
//------------------------------------------------------
event buildDerricks(inactive)
{
	//Find closest oil resource
	//-------------------------
	result = 99999;
	feature2 = NULLOBJECT;
	initGetFeature(oilRes,player,player);
	feature = getFeature(player);
	while(feature != NULLOBJECT)
	{
		//Make sure no other truck is  trying to build it
		//-----------------------------------------------
		boolResult = TRUE;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult))
		{
			if(droid.order == DORDER_BUILD)
			{
				if((droid.orderx == feature.x) and (droid.ordery == feature.y))
				{
					boolResult = FALSE;
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Make sure there are no enemy units and defenses nearby
		if(boolResult)
		{
			temp = (13 * 128);
			count = 0;
			while((count < numEnemies) and (boolResult))
			{
				resetStructTargets();
				setStructTarPref(ST_DEF_GROUND);

				//if(numStructsByTypeInArea(Enemies[count], REF_DEFENSE, feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp) > 0)

				structure = structTargetInArea(Enemies[count], Enemies[count], feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp);
				if(structure != NULLOBJECT)
				{
					boolResult = FALSE;		//Too dangerous
				}
				else
				{
					resetDroidTargets();
					setDroidTarPref(DT_WEAP_GROUND);
					droid = droidTargetInArea(Enemies[count], Enemies[count], feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp);
					if(droid != NULLOBJECT)
					{
						boolResult = FALSE;		//Too dangerous
					}
				}
				
				count = count + 1;
			}
		}

		//Remember closest structure
		//--------------------------
		if(boolResult)		//If not trying to build already and no enemy defenses
		{
			result2 = distBetweenTwoPoints(baseX, baseY, feature.x, feature.y);		//How close to the base
			if(result2 < result)			//If closer
			{
				result = result2;
				feature2 = feature;			//Remember this oil resource
			}
		}

		feature = getFeature(player);
	}

	//Build oil derrick
	//-----------------
	if(feature2 != NULLOBJECT)
	{
		//Find closest truck
		//------------------
		tempDroid = NULLOBJECT;
		result = 99999;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				result2 = distBetweenTwoPoints(droid.x, droid.y, feature2.x, feature2.y);
				if(result2 < result)
				{
					result = result2;
					tempDroid = droid;
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Build derrick
		//-------------
		if(tempDroid != NULLOBJECT)
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD,derrick, feature2.x, feature2.y);
		}
	}
}


//------------------------------------------------------
//	Send scouts to look for oil resources
//------------------------------------------------------
event sendScouts(sendScoutsTr)
{
	count = 0;
	temp = (43 * 128);		//Step

	while(count < maxScouts)
	{
		if(scoutGroup[count].members > 0)
		{
			if(idleGroup(scoutGroup[count]) > (scoutGroup[count].members /2))
			{
				if(count > 1)	//3rd scout vitits random places (only on big maps)
				{
					tempX = random(mapWidth) * 128;
					tempY = random(mapHeight) * 128;
					boolResult = pickStructLocation(vtolPad, ref tempX, ref tempY,player);
					if(boolResult == TRUE)
					{
						orderGroupLoc(scoutGroup[count], DORDER_MOVE, tempX, tempY);
					}
				}
				else		//Using a scouting algorithm for the first 2 scouts
				{
					//Send to scout before choosing new coords, so that
					//they would visit the initial (first) location
					//-------------------------------------------------
					tempX = scoutX[count];
					tempY = scoutY[count];
					boolResult = pickStructLocation(vtolPad, ref tempX, ref tempY,player);
					if(boolResult == TRUE)
					{
						orderGroupLoc(scoutGroup[count], DORDER_MOVE, tempX, tempY);
					}


					//Try 3 times to find a safe scouting location
					//--------------------------------------------
					boolResult = FALSE;
					result = 0;		//Number of times failed to find safe location
					while((result < 3) and (not boolResult))	//May fail max 3 times
					{
						if(count == 0)	//SCOUT1: From bottom left to the top
						{
							scoutY[count] = scoutY[count] - temp;	//Move up 1 step
							if(scoutY[count] < 512)			//If reached top
							{
								scoutY[count] = (128 * mapHeight) - (9 * 128);	//Back to bottom
								scoutX[count] = scoutX[count] + temp;		//Move right 1 step
							}

							if(scoutX[count] > (mapWidth * 128))	//If reached right border
							{
								scoutX[count] = (9 * 128);		//Start from the left
							}

						}
						else	//SCOUT2: From top right to the left
						{
							scoutX[count] = scoutX[count] - temp;	//Move left 1 step
							if(scoutX[count] < 512)			//If reached left border
							{
								scoutX[count] = (mapWidth * 128) - (9 * 128);		//Start from right
								scoutY[count] = scoutY[count] + temp;	//Move line down
							}

							if(scoutY[count] > (128 * mapHeight))		//If reached bottom
							{
								scoutY[count] = (9 * 128);		//Start from top
							}
						}


						//Check if new scouting location is safe
						//--------------------------------------
						count2 = 0;
						boolResult = TRUE;		//All ok right now (for max tries)
						while((count2 < numEnemies) and (boolResult))
						{
							if(objectInRange(Enemies[count2], scoutX[count],scoutY[count], 1280))	//10*128
							{
								boolResult = FALSE;		//This location failed this time
								result = result + 1;		//# of times safety check failed
							}
							count2 = count2 + 1;	//Next enemy
						}
					}
				}
			}
		}
		count = count + 1;
	}
}


//------------------------------------------------------
//	Build base
//------------------------------------------------------
event expandBase(inactive)
{
	//if(not powerSaving)
	//{
		if(extraStruct == numExtraStructs)	// loop round
		{
			extraStruct = 0;
		}

		//We have all vital structures, expand the base
		//---------------------------------------------
		boolResult = FALSE;
		if(isStructureAvailable(extraStructs[extraStruct],player))
		{
			buildX = baseX;
			buildY = baseY;

			//Don't try to build a second HQ
			//------------------------------
			boolResult2 = TRUE;
			if(extraStruct == 2)	//HQ
			{
				if(getStructure(extraStructs[2],player) != NULLOBJECT)
				{
					boolResult2 = FALSE;
				}
			}

			boolResult = FALSE;
			if(boolResult2)		//If not a second HQ
			{
				boolResult2 = pickStructLocation(extraStructs[extraStruct], ref buildX, ref buildY,player);
				if(boolResult2 == TRUE)
				{
					boolResult = TRUE;
				}
			}
		}

		if(boolResult)
		{
			result = 99999;
			tempDroid = NULLOBJECT;

			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			if(tempDroid != NULLOBJECT)
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD,extraStructs[extraStruct], buildX,buildY);
			}
		}
		extraStruct = extraStruct + 1;		//Next structure
	//}
}


//------------------------------------------------------
//	Build base defenses
//------------------------------------------------------
event buildDefenses(inactive)
{
	if(not powerSaving)
	{
		count = numDefenses - 1;
		count2 = 0;
		boolResult = TRUE;
		while((boolResult == TRUE) and (count >= 0))
		{
			if(isStructureAvailable(defenses[count],player))
			{
				structChoice[0] = defenses[count];
				boolResult = FALSE;
			}
			count = count - 1;
		}

		if(boolResult == FALSE)
		{
			buildX = baseX;
			buildY = baseY;
			boolResult2 = pickStructLocation(powGen, ref buildX, ref buildY,player);
			if(boolResult2 == TRUE)
			{
				result = 99999;
				tempDroid = NULLOBJECT;

				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)		//Find truck who is near the oil resource
				{
					if(droid.order == DORDER_NONE)
					{
						result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
						if(result2 < result)
						{
							result = result2;
							tempDroid = droid;
						}
					}
					droid = iterateGroup(buildGroup);
				}

				if(tempDroid != NULLOBJECT)
				{
					orderDroidStatsLoc(tempDroid, DORDER_BUILD,structChoice[0], buildX,buildY);
				}
			}
		}
	}
}


//------------------------------------------------------
//	Build oil defenses
//------------------------------------------------------
event oilDefenses(inactive)
{
	if(not powerSaving)
	{
		temp = (4 * 128);		//Defenses range
		result = 99999;
		boolResult = TRUE;
		structure2 = NULLOBJECT;

		initEnumStruct(FALSE,derrick,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			result2 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
			if(result2 < result)
			{
				boolResult = TRUE;

				//If not within a base
				//--------------------
				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
				{
					boolResult = FALSE;
				}

				//If not to many defenses already
				//-------------------------------
				if(boolResult == TRUE)
				{
					if(numStructsInArea(player, structure.x - temp, structure.y - temp, structure.x + temp, structure.y + temp) > 3)
					{
						boolResult = FALSE;
					}
				}

				//Choose best defense
				//-------------------
				if(boolResult == TRUE)
				{
					count = numDefenses - 1;
					boolResult = FALSE;
					while((count >= 0) and (boolResult == FALSE))
					{
						if(isStructureAvailable(defenses[count], player))
						{
							structChoice[0] = defenses[count];
							boolResult = TRUE;			//Stop
						}
						count = count - 1;
					}
				}

				if(boolResult == TRUE)
				{
					//If we have a derrick to defend
					//------------------------------
					boolResult = FALSE;
					result3 = 99999;
					tempDroid = NULLOBJECT;

					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						if(droid.order == DORDER_NONE)
						{
							result4 = distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y);
							if(result4 < result3)
							{
								boolResult = TRUE;
								result3 = result4;
								tempDroid = droid;
							}
						}
						droid = iterateGroup(buildGroup);
					}
				}

				//If we have a droid
				//------------------
				if(boolResult == TRUE)
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = pickStructLocation(structChoice[0], ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						boolResult = FALSE;
						if((buildX > structure.x - temp) and (buildY > structure.y - temp) and (buildX < structure.x + temp) and (buildY < structure.y + temp))		//If in the range
						{
							boolResult = TRUE;
						}
					}
				}

				if(boolResult == TRUE)
				{
					result = result2;
					structure2 = structure;
				}
			}
			structure = enumStruct();
		}

		//If we can build it now
		//----------------------
		if((structure2 != NULLOBJECT) and (tempDroid != NULLOBJECT))
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
		}
	}
}

//------------------------------------------------------
//	Keep details about the size and postion of the
//	ai players base
//------------------------------------------------------
event basedetails(basedetailsTr)
{
	// clear old extremities
	//----------------------
	maxy = 0;
	maxx = 0;
	miny = (mapHeight*128);
	minx = (mapWidth*128);

	//Now find the extremities of our vital structures
	//------------------------------------------------
	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],player,player);					
		structure = enumStruct();
		while(structure != NULLOBJECT)	
		{
			if(structure.x < minx)
			{
				minx = structure.x;	// - 896;
			}
			if(structure.x > maxx)
			{
				maxx = structure.x;	// + 896;	
			}
			if(structure.y < miny)
			{
				miny = structure.y;	// - 896;
			}
			if(structure.y > maxy)
			{
				maxy = structure.y;	// + 896;
			}
			structure = enumStruct();
		}
		count = count + 1;
	}

	//Must be done here, after all structures are checked, otherwise
	//even if structure2.x < structure.x, (structure.x - minx) might be less and minx won't be set to
	//structure2.x, even if (structure2.x < structure.x), base won't expand enough
	//--------------------------------

	temp = 7;
	if(bigMap)
	{
		temp = 11 * 128;
	}

	minx = minx - temp;
	maxx = maxx + temp;
	miny = miny - temp;
	maxy = maxy + temp;

	//minx = minx - 896;
	//maxx = maxx + 896;
	//miny = miny - 896;
	//maxy = maxy + 896;

	//Check everything's within limits
	//--------------------------------
	if(minx < 0)
	{
		minx = 128;
	}
	if(miny < 0)
	{
		miny = 128;
	}
	if(maxx > (mapWidth * 128))
	{
		maxx = (mapWidth * 128) - 128;
	}
	if(maxy > (mapHeight * 128))
	{
		maxy = (mapHeight * 128) - 128;
	}
}


//==============================================================================================
//
//				[Other stuff important for all phases]
//
//==============================================================================================

//------------------------------------------------------
//	Keep track on the other players
//------------------------------------------------------
event keepTrack(keepTrackTr)
{
	numEnemies = 0;
	count = 0;
	while(count < 8)
	{
		allyPlayer[count] = FALSE;
		actPlayer[count] = FALSE;

		if(count != player)	//Not me
		{

			//Check if player has any structures (still alive)
			//------------------------------------------------
			boolResult = FALSE;
			count2 = 0;
			while((count2 < numBaseStructs) and (not boolResult))		//For all base structures
			{
				if(getStructure(baseStructs[count2],count) != NULLOBJECT)
				{
					boolResult = TRUE;
				}
				count2 = count2 + 1;
			}

			if(boolResult)		//If alive
			{
				actPlayer[count] = TRUE;

				//Not enemy
				if(allianceExistsBetween(player,count))
				{
					allyPlayer[count] = TRUE;
				}
				else	//Enemy
				{
					//Find enemy's base by finding its base structures
					Enemies[numEnemies] = count;	//Remember all enemies
					numEnemies = numEnemies + 1;
				}
			}

		}
		count = count + 1;
	}
}

//------------------------------------------------------
//	Deal with a droid being destroyed
//------------------------------------------------------
event droidDestroyed(droidDestroyedTr)
{
	count = 0;	//Do nothing

	//if(droid.droidType == DROID_CONSTRUCT)
	//{
	//	if(droid != outpostDroid)		//If wasn't outpost builder (will outpostDroid be NULLOBJECT already?)
	//	{
	//		numTrucks = numTrucks - 1;
	//	}
	//}
}


//------------------------------------------------------
// 	Build a power gen for every 4 derricks
//------------------------------------------------------
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	count = 0;
	initEnumStruct(FALSE,derrick,player,player);	// count = numderricks
	structure = enumStruct();
	while(structure != NULLOBJECT)	
	{
		count = count + 1;
		structure = enumStruct();
	}

	count2 = 0;	
	initEnumStruct(FALSE,powGen,player,player);	// count2 = numpowgens
	structure= enumStruct();
	while(structure != NULLOBJECT)	
	{
		count2 = count2 + 1;
		structure= enumStruct();
	}
								
	if((count2 * 4) < count)			// if we need powergen
	{
		buildX = baseX;				// try build powergen
		buildY = baseY;
		boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
		if(boolResult == TRUE)
		{
			result = 999999;
			tempDroid = NULLOBJECT;

			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)	//Find truck who is near the oil resource
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			if(tempDroid != NULLOBJECT)
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD,powGen, buildX,buildY);
			}
		}
	}
}


//------------------------------------------------------
//	Build trucks if necessary
//------------------------------------------------------
event LegoTrucks(LegoTrucksTr)
{
	initEnumStruct(FALSE,factory,player,player);
	structure = enumStruct();
	if((structure != NULLOBJECT) and (buildGroup.members < maxTrucks))
	{
		if(structureIdle(structure))
		{
			buildDroid(constructor, structure, player, 1);
		}
	}
}


//------------------------------------------------------
//	Deal with a droid being built
//------------------------------------------------------
event droidBuilt(droidBuiltTr)
{

	if(droid.droidType == DROID_CONSTRUCT)		// if constructor droid 
	{	
		groupAddDroid(buildGroup, droid);
	}
	else if((droid.droidType == DROID_CYBORG) or (droid.propulsion == cyborgProp))	//Cyborg or heavy cyborg
	{
		groupAddDroid(transportGr, droid);
	}
	else if(droid.droidType == DROID_TRANSPORTER)
	{
		//if(transportDroid == NULLOBJECT)
		//{
			transportDroid = droid;
			orderDroidLoc(transportDroid, DORDER_MOVE, baseX, baseY);
			//setDroidSecondary(transportDroid, DSO_ATTACK_LEVEL, DSS_ALEV_NEVER);
		//}
		
	}
	else
	{
		setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);

		if(isVtol(droid))
		{
			orderDroid(droid, DORDER_RTB);	//Move away

			//Check weapon
			count = 0;
			boolResult = FALSE;
			while((count < numSVtolTemplates) and (not boolResult))
			{
				if(droid.weapon == sVtolWeapon[count])
				{
					//setFogColour(1, 1, random(200) + 50);
					boolResult = TRUE;
					groupAddDroid(sVtolGr, droid);	//Antistructure
					//setFogColour(random(200) + 50, 1, 1);
				}
				count = count + 1;
			}

			//Antitank
			if(not boolResult)
			{
				groupAddDroid(tVtolGr, droid);
			}
		}
		else
		{
			boolResult = TRUE;
			setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);	//Was short

			//Repair unit
			//---------------------------
			if(droid.droidType == DROID_REPAIR)
			{
				setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Perair units never repair

				if(repDefendDroid[0] == NULLOBJECT)
				{
					repDefendDroid[0] = droid;
					boolResult = FALSE;
				}
				else if(repDefendDroid[1] == NULLOBJECT)
				{
					repDefendDroid[1] = droid;
					boolResult = FALSE;
				}
			}

			//Scouts
			//---------------------------
			count = 0;
			while((count < maxScouts) and (boolResult))
			{
				if(scoutGroup[count].members == 0)
				{
					groupAddDroid(scoutGroup[count], droid);
					boolResult = FALSE;
				}
				count = count + 1;
			}

			//Random scout (#3)
			if(boolResult)
			{
				if(scoutGroup[2].members == 0)
				{
					if(((attackGroup.members + sendOutpostGr.members) > numRushers) and (defendGr.members >= maxDefenders))
					{
						groupAddDroid(scoutGroup[2], droid);
						boolResult = FALSE;
					}
				}
			}


			//Defenders
			//---------------------------
			if(boolResult)
			{
				//if((attackPhase > 0) or (alreadyAttacked))	//Send to attack for the first time or not attacking right now, but attacked before (attackState=0, but alreadyAttacked)
				if(alreadyAttacked)		//Already sent units to the outpost
				{
					if(((attackGroup.members > numRushers) and (defendGr.members < maxDefenders)) or (defendGr.members < 7) or (defendingBase))
					{
						if(defendGr.members < maxDefenders)
						{
							groupAddDroid(defendGr, droid);
							boolResult = FALSE;
						}
					}
				}
			}


			//Defenders
			//---------------------------
			//if(boolResult and ((attackGroup.members >= numRushers) or ((attackPhase > 0) and (defendGr.members < 5))))	//If already many rushers or (have already rushed and not enough defenders)
			//{
			//	if(defendGr.members < maxDefenders)
			//	{
			//		if(mainPhase > 0)
			//		{
			//			groupAddDroid(defendGr, droid);
			//			boolResult = FALSE;
			//		}
			//	}
			//}


			//Oil
			//---------------------------
			if(boolResult and (attackGroup.members > numRushers))
			{
				if(oilGr.members < maxOilGr)
				{
					groupAddDroid(oilGr, droid);
					boolResult = FALSE;
				}
			}

			//Attackers
			//---------------------------
			if(boolResult)
			{
				groupAddDroid(collectSendGr, droid);
				boolResult = FALSE;
				//groupAddDroid(sendOutpostGr, droid);
			}

			//Increase number of defenders
			//----------------------------
			if(attackGroup.members > numRushers)
			{
				if((defendGr.members >= maxDefenders) and (maxDefenders < 14) and (alreadyAttacked))	//(attackPhase > 0): if we have already enough attackers and started attacking
				{
					maxDefenders = maxDefenders + 1;
				}
			}
		}
	}
}


//------------------------------------------------------
//	Cheat a bit, like Pumpkin AI, not more
//------------------------------------------------------
event difficultyMod(difficultyModTr)
{
	skDifficultyModifier(player);
	randomiseSeed();		//Will not hurt if done once in a while
}


//------------------------------------------------------
//	Upgrade structures
//------------------------------------------------------
event upgradeStructures(upgradeStructuresTr)
{

	//Find closest truck
	//-------------------
	tempX = baseX;
	tempY = baseY;
	result = 999999;
	tempDroid = NULLOBJECT;
	boolResult = TRUE;

	initIterateGroup(buildGroup);
	droid = iterateGroup(buildGroup);
	while(droid != NULLOBJECT)
	{
		if(droid.order == DORDER_NONE)
		{
			result2 = distBetweenTwoPoints(tempX, tempY, droid.x, droid.y);
			if(result2 < result)
			{
				result = result2;
				tempDroid = droid;
			}
		}
		droid = iterateGroup(buildGroup);
	}

	//------------------
	//	Factory
	//-----------------
	initEnumStruct(FALSE,factory,player,player);
	structure= enumStruct();
	while(structure != NULLOBJECT)	
	{
		if(structureComplete(structure))
		{
			if(isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ))			
			{
				if((attackPhase > 0) or (skCanBuildTemplate(player,structure, tmpl[0][8])))	//Don't upgrade while preparing the first rush or upgrade if it's necessary to be able to build units in T3
				{
					if(tempDroid != NULLOBJECT)
					{
						boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,facModule, structure.x,structure.y);
					}
				}
			}
		}
		structure= enumStruct();
	}

	//------------------
	//	Powergen
	//------------------
	initEnumStruct(FALSE,powGen,player,player);
	structure= enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			if(isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)))			
			{
				if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
				{
					boolResult = FALSE;
					orderDroidStatsLoc(tempDroid,DORDER_BUILD,powModule, structure.x,structure.y);	//Upgrade it.
				}
			}
		}
		structure= enumStruct();
	}

	//-----------------
	//	Research
	//-----------------
	if(not powerSaving)
	{
		initEnumStruct(FALSE,resLab,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)	
		{
			if(structureComplete(structure))
			{
				if( isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)))			
				{
					if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
					{
						boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,resModule, structure.x,structure.y);
					}
				}
			}
			structure= enumStruct();
		}

		//-------------------
		//	VTOL Factory
		//-------------------
		if(not powerSaving)
		{
			initEnumStruct(FALSE,vtolFactory,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT)	
			{
				if(structureComplete(structure))
				{
					if(isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ))			
					{
						if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
						{
							boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,facModule, structure.x,structure.y);
						}	
					}
				}
				structure = enumStruct();
			}
		}
	}
}


//------------------------------------------------------
//	Run for a bit when attacked
//------------------------------------------------------
event moveIfAttacked(moveIfAttackedTr)
{
	//If unit is still alive and is still under attack
	if((droid != NULLOBJECT) and (baseobj != NULLOBJECT))
	{
		//If during the attack
		//if(attackPhase >= 2)
		//{
		//	if(groupMember(attackGroup, droid))
		//	{
		//		if(distBetweenTwoPoints(curEnemyX, curEnemyY, baseobj.x, baseobj.y) < (KeepDist / 2))
		//		{
		//			if(losTwoObjects(droid, baseobj, TRUE))		//Only if we can see the enemy (get out of his range)
		//			{
		//				orderDroidLoc(droid, DORDER_MOVE, curEnEdgeX, curEnEdgeY);	//Retreat
		//			}
		//		}
		//	}
		//}

		if(baseobj.player != player)	//Not attacking itself by an accident or with a mass-weapon
		{

			boolResult = TRUE;
			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					boolResult = FALSE;		//Attacked by a VTOL
				}
			}

			if(droid.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(droid)))
				{
					boolResult = FALSE;		//VTOL was attacked
				}
			}

			//If we have a weapon, then answer
			//--------------------------------
			if(boolResult)		//If a land unit or a defense
			{
				if(droid.droidType == DROID_WEAPON)		//Has a weapon
				{
					if(droid.order == DORDER_NONE)	//Not already attacking
					{
						if(losTwoObjects(droid, baseobj, TRUE))		//If we can see attacker
						{
							//orderDroidObj(droid, DORDER_ATTACK, baseobj);
							orderDroidLoc(droid, DORDER_SCOUT, baseobj.x, baseobj.y);
						}
					}
				}

				//Help a friend if we are near
				//----------------------------
				if(groupMember(attackGroup, droid))
				{
					temp = (7 * 128);
					initIterateGroup(attackGroup);
					tempDroid = iterateGroup(attackGroup);
					while(tempDroid != NULLOBJECT)
					{
						if(tempDroid.order == DORDER_NONE)
						{
							if(distBetweenTwoPoints(tempDroid.x, tempDroid.y, droid.x, droid.y) < temp)
							{
								//if(losTwoObjects(tempDroid, baseobj, TRUE))		//If we can see attacker
								//{
									//orderDroidObj(tempDroid, DORDER_ATTACK, baseobj);
									orderDroidLoc(tempDroid, DORDER_SCOUT, baseobj.x, baseobj.y);
								//}
							}
						}
						tempDroid = iterateGroup(attackGroup);
					}
				}
			}

			//Vtols and trucks run away
			//-------------------------
			if((droid.droidType == DROID_CONSTRUCT) or (isVtol(droid)))	//If a constructor or a VTOL
			{
				if(droid.order == DORDER_NONE)
				{
					temp = (3 * 128);
					temp = random(temp * 2) - temp;
					orderDroidLoc(droid, DORDER_MOVE, droid.x + temp, droid.y + temp);
				}
			}
		}
	}
}

//---------------------------------------------------------------
//	Build an outpost to retreat to and to repair damaged units
//---------------------------------------------------------------
event BuildOutpost(inactive)
{
	//Find trucks to build the outpost
	//--------------------------------
	count2 = (KeepDist / 2);
	
	//Reduce number of defenses temporary if low on power
	temp = 6;	/*%!	ID="NumOutpostDef",
						MainDesc="Num outpost defences",
						type="asn",		//Assign
						val="6",
						ArgDesc="6 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="9",
						ArgDesc="9",
						val="12",
						ArgDesc="12",
						val="15",
						ArgDesc="15"	*/

	if(powerSaving)
	{
		temp = 2;	/*%!	ID="NumOutpostDefLowPow",
						MainDesc="Num outpost defences on low power",
						type="asn",		//Assign
						val="2",
						ArgDesc="2 (Default)",
						val="0",
						ArgDesc="0",
						val="4",
						ArgDesc="4",
						val="6",
						ArgDesc="6",
						val="10",
						ArgDesc="10",
						val="12",
						ArgDesc="12",
						val="temp",
						ArgDesc="Same value as above"	*/
	}

	if(outpostDroid == NULLOBJECT)
	{
		if(not defendingBase)		//Need trucks for base rebuilding now
		{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (outpostDroid == NULLOBJECT))
			{
				if(droid.order == DORDER_NONE)
				{
					droidLeaveGroup(droid);
					outpostDroid = droid;
					orderDroidLoc(outpostDroid, DORDER_MOVE, curEnEdgeX, curEnEdgeY);
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}

	//--------------------------------------------------------
	//Check if we have all necessary structures in the outpost
	//--------------------------------------------------------
	if((outpostDroid != NULLOBJECT) and (curEnEdgeX > 0) and (not defendingBase))	//If we have trucks, have outpost coords and don't need money for the base
	{
		boolResult = TRUE;

		//-------------------------
		//Remove old rep facilities
		//-------------------------
		initEnumStruct(FALSE,repairFacility,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			//Demolish if outside of the new edge
			if(distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, structure.x, structure.y) > count2)
			{
				if((outpostDroid.order == DORDER_NONE) or (outpostDroid.order == DORDER_MOVE))	//Not busy
				{
					orderDroidObj(outpostDroid, DORDER_DEMOLISH, structure);
				}
			}
			structure = enumStruct();
		}

		//-----------------------
		//Check repair facilities
		//-----------------------
		result = numStructsByTypeInArea(player, REF_REPAIR_FACILITY, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2);
		if(result < 1)		//We need repair facilities
		{
			boolResult = FALSE;		//Not done building outpost yet

			buildX = curEnEdgeX;		//Outpost coords = build coords
			buildY = curEnEdgeY;
			boolResult2 = pickStructLocation(repairFacility, ref buildX, ref buildY, player);
			if(boolResult2 == TRUE)		//If we can build
			{
				//Not outside of the outpost
				//--------------------------
				if(distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, buildX, buildY) < count2)
				{
					if((outpostDroid.order == DORDER_NONE) or (outpostDroid.order == DORDER_MOVE))	//Not busy
					{
						orderDroidStatsLoc(outpostDroid, DORDER_BUILD, repairFacility, buildX,buildY);
					}
				}
			}
		}

		//---------------------------------------------------
		//Build some defenses in the outpost if we are idling
		//---------------------------------------------------
		if(outpostDroid.order == DORDER_NONE)	//Not busy
		{
			//Count defenses
			//--------------
			result = 0;
			count = 0;
			while(count < numDefenses)
			{
				initEnumStruct(FALSE,defenses[count],player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(structure.x, structure.y, curEnEdgeX, curEnEdgeY) < count2)		//In the outpost
					{
						result = result + 1;
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			//if(numStructsInArea(player, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) < count)
			if(result < temp)
			{
				//Choose best defense
				//-------------------
				count = numDefenses - 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(defenses[count], player))
					{
						structChoice[0] = defenses[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have a defense we can build
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}
		}

		//---------------
		//Build some arty
		//---------------
		result4 = 6;	/*%!	ID="NumOutpostArtyDef",
						MainDesc="Num outpost arty defences",
						type="asn",		//Assign
						val="6",
						ArgDesc="6 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="8",
						ArgDesc="8",
						val="10",
						ArgDesc="10",
						val="15",
						ArgDesc="15"	*/

		if(outpostDroid.order == DORDER_NONE)
		{
			//Arty
			if(numStructsByTypeInArea(player, REF_DEFENSE, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) < (temp + result4))	//Max 6 arty def
			{
				//Check if we have arty tech available
				count = 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(arty[count], player))
					{
						structChoice[0] = arty[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have arty tech
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}

			//-------
			//Sensors
			//-------

			//Count sensors
			//-------------
			result = 0;
			count = 0;
			while(count < 2)
			{
				initEnumStruct(FALSE,sens[count],player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(structure.x, structure.y, curEnEdgeX, curEnEdgeY) < count2)		//In the outpost
					{
						result = result + 1;
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			if(result == 0)
			{
				//Check if we have sensor tech available
				count = 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(sens[count], player))
					{
						structChoice[0] = sens[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have sensor tech available
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}
		}
	}
}

//-------------------------------------------------------------
//	Check for some important details we need for the script
//-------------------------------------------------------------
event updateDetails(updateDetailsTr)
{
	//Decide wheather to drop or not
	//----------------------------------------------------
	if(not dropEnabled)
	{
		if((alreadyAttacked and (playerPower(player) > 500)) or (playerPower(player) > muchoPower))		//Started attacking and enough power
		{
			dropEnabled = TRUE;
		}
	}

	//----------------------------------------------------
	//Count how many attackers are repairing at the moment
	//----------------------------------------------------
	//numRepairing = 0;
	//initIterateGroup(attackGroup);
	//droid = iterateGroup(attackGroup);
	//while(droid != NULLOBJECT)
	//{
	//	if(droid.order == DORDER_RTR)
	//	{
	//		numRepairing = numRepairing + 1;
	//	}
	//	droid = iterateGroup(attackGroup);
	//}

	//------------------------------------------
	//Check if we have an outpost and can repair
	//------------------------------------------
	haveOutpost = FALSE;
	if(curEnEdgeX > 0)
	{
		//Find rep facilities
		//-------------------
		count2 = (KeepDist / 2);
		if(numStructsByTypeInArea(player, REF_REPAIR_FACILITY, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) > 0)
		{
			haveOutpost = TRUE;
		}
	}

	//Decide how many templates tochoose from
	//---------------------------------------
	structure = getStructure(factory,player);
	if(structure != NULLOBJECT)
	{
		temp = 0;
		TemplDepth = 1;
		if(playerPower(player) > muchoPower)
		{
			temp = 1;
		}

		if(skCanBuildTemplate(player,structure, tmpl[0][8]))	//If we have Trck Python HC
		{
			if(mainPhase == 1)		//If set to 2 too early, then some stuff will not be activated at startup
			{
				mainPhase = 2;
			}
		}

		if(skCanBuildTemplate(player,structure, tmpl[temp][10]))		//If we have A-Mantis-Trk-Lancer then start using 3 templates
		{
			TemplDepth = 3;
		}
		else if(skCanBuildTemplate(player,structure, tmpl[temp][9]))	//If we have A-Python-Trk-Lancer then use A-Python-Trk-Lancer and A-Python-Trk-HC
		{
			TemplDepth = 2;
		}

	}

	//Remember the best cyborg template available
	//-------------------------------------------
	structure = getStructure(cybFactory, player);
	if(structure != NULLOBJECT)
	{
		count = 1;		//numTemplates - 1
		boolResult = TRUE;
		while((count >= 0) and (boolResult))
		{
			if(skCanBuildTemplate(player,structure, cybTmpl[count]) )
			{
				cybTemplate = count;
				boolResult = FALSE;
			}
			count = count - 1;
		}
	}
}

//----------------------------------------
//Power saving
//----------------------------------------
event savePower(inactive)
{
	//------------
	//Power saving
	//------------
	powerSaving = FALSE;
	if((playerPower(player) < 100) or (defendingBase))		//Low on power or need power for fast unit production
	{
		powerSaving = TRUE;
	}
}

//----------------------------------------
//Repair damaged droids using repair units
//----------------------------------------
event repairStuff(repairStuffTr)
{
	//------------------------
	//Defenders
	//------------------------
	result = 2;	//Total number of (repDefendDroid - 1)
	count = 0;	//Current repair unit index
	while(count < result)
	{
		if(repDefendDroid[count] != NULLOBJECT)		//If this repairer exists
		{
			boolResult = FALSE;				//Assume it's still busy right now
			if(toRepDefendDroid[count] == NULLOBJECT)		//Nothing to repair
			{
				boolResult = TRUE;				//Not busy, find a unit to repair
			}
			else					//Damaged unit still exists
			{
				if(toRepDefendDroid[count].health > 95)		//Already repaired
				{
					boolResult = TRUE;			//Find another unit
					toRepDefendDroid[count] = NULLOBJECT;	//'Forget' this unit
				}
			}

			//-------------------
			//Find a damaged unit
			//-------------------
			if(boolResult)					//Have nothing to repair
			{
				initIterateGroup(defendGr);
				droid = iterateGroup(defendGr);
				boolResult = TRUE;
				while((droid != NULLOBJECT) and (boolResult))
				{
					if(droid.health < 90)			//Needs repair
					{
						boolResult = FALSE;		//Busy now, found a unit to repair

						//Make sure this unit is not already get repaired by the second repairer
						//----------------------------------------------------------------------
						if(count == 0)	//For the first repairer
						{
							if(droid == toRepDefendDroid[1])	//If already get repaired
							{
								boolResult = TRUE;	//Don't take this unit
							}
						}
						else if(count == 1)
						{
							if(droid == toRepDefendDroid[0])	//If already get repaired
							{
								boolResult = TRUE;	//Don't take this unit
							}
						}

						if(not boolResult)	//If we did decide to choose this unit for repairing
						{
							toRepDefendDroid[count] = droid;	//Choose it
						}
					}
					droid = iterateGroup(defendGr);
				}

				//---------------------------------------------------------
				//If nothing to repair so far, repair the other repair unit
				//---------------------------------------------------------
				if(boolResult)		//Nothing to repair
				{
					if(count == 0)	//For the first rep unit
					{
						if(repDefendDroid[1] != NULLOBJECT)	//2nd repair unit exists
						{
							if(repDefendDroid[1].health < 90)	//Needs repair
							{
								boolResult = FALSE;			//Busy now
								toRepDefendDroid[count] = repDefendDroid[1];	//Repair it
							}
						}
					}
					else if(count == 1)
					{
						if(repDefendDroid[0] != NULLOBJECT)	//1st repair unit exists
						{
							if(repDefendDroid[0].health < 90)	//Needs repair
							{
								boolResult = FALSE;			//Busy now
								toRepDefendDroid[count] = repDefendDroid[0];	//Repair it
							}
						}
					}
					
				}

				//---------------------------------------------------------
				//If found something to repair, then get closer to the unit
				//---------------------------------------------------------
				if(not boolResult)		//Busy
				{
					if(distBetweenTwoPoints(toRepDefendDroid[count].x, toRepDefendDroid[count].y, repDefendDroid[count].x, repDefendDroid[count].y) > 256)	//If too far away from the damaged unit
					{
						tempX = 128;
						tempY = 128;
						if(repDefendDroid[count].x < toRepDefendDroid[count].x)		//Don't make the unit get out of the way, stop near it
						{
							tempX = -128;
						}

						if(repDefendDroid[count].y < toRepDefendDroid[count].y)
						{
							tempY = -128;
						}
					
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, toRepDefendDroid[count].x + tempX, toRepDefendDroid[count].y + tempY);
					}
				}
				else	//If still idle, then move closer to the defend group
				{
					tempX = defendGr.x;
					tempY = defendGr.y;

					if(distBetweenTwoPoints(tempX, tempY, repDefendDroid[count].x, repDefendDroid[count].y) > 1024)	//Too far away from defenders
					{
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, tempX, tempY);	//Move closer to the group
						boolResult = FALSE;
					}
				}
			}
			else if(toRepDefendDroid[count] != NULLOBJECT)		//Has something to repair and not going to repair it
			{
				if(repDefendDroid[count].order == DORDER_NONE)	//Idle
				{
					if(distBetweenTwoPoints(repDefendDroid[count].x, repDefendDroid[count].y, toRepDefendDroid[count].x, toRepDefendDroid[count].y) > (3 * 128))
					{
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, toRepDefendDroid[count].x, toRepDefendDroid[count].y);
					}
				}
			}
		}
		count = count + 1;
	}


/*
	//------------------------
	//Attackers
	//------------------------
	if(repAttackDroid != NULLOBJECT)
	{
		if(repAttackDroid.order == DORDER_NONE)			//Not busy
		{
			initIterateGroup(attackGroup);
			droid = iterateGroup(attackGroup);
			boolResult = TRUE;				//Send only 1 truck
			while((droid != NULLOBJECT) and (boolResult))
			{
				if(droid.health < 90)			//Needs repair
				{
					if(distBetweenTwoPoints(droid.x, droid.y, repAttackDroid.x, repAttackDroid.y) > 256)
					{
						boolResult = FALSE;
						tempX = 128;
						tempY = 128;
						if(repAttackDroid.x < droid.x)		//Don't make the unit get out of the way, stop near it
						{
							tempX = -128;
						}

						if(repAttackDroid.y < droid.y)
						{
							tempY = -128;
						}
					
						orderDroidLoc(repAttackDroid, DORDER_MOVE, droid.x + tempX, droid.y + tempY);
					}
				}
				droid = iterateGroup(attackGroup);
			}

			tempX = attackGroup.x;
			tempY = attackGroup.y;
			if(not boolResult)
			{
				if(distBetweenTwoPoints(tempX, tempY, repAttackDroid.x, repAttackDroid.y) > 512)	//(6 * 128)
				{
					orderDroidLoc(repDefendDroid, DORDER_MOVE, tempX, tempY);	//Move closer to the group
				}
			}
		}
	}
*/

	//-----------------------
	//Base structures
	//-----------------------
	structure2 = NULLOBJECT;
	initEnumStruct(TRUE,derrick,player,player);		//TRUE: iterate through all structures
	structure = enumStruct();
	while((structure != NULLOBJECT) and (structure2 == NULLOBJECT))
	{
		//if(not structureComplete(structure))		//If structure not finished
		//{
			if(structure.health < 90)
			{
				if((structure.x < maxx) and (structure.x > minx))	//Only base structures
				{
					if((structure.y < maxy) and (structure.y > miny))
					{
						structure2 = structure;
					}
				}
			}
		//}
		structure = enumStruct();
	}

	if(structure2 != NULLOBJECT)
	{
		boolResult = TRUE;
		result = 0;
		tempDroid = NULLOBJECT;

		temp = 45 * 128;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult))
		{
			if(droid.order == DORDER_NONE)	//Make sure there's only one droid repairing at a time
			{
				if(distBetweenTwoPoints(droid.x, droid.y, structure2.x, structure2.y) < temp)	//Not too far away
				{
					tempDroid = droid;
					boolResult = FALSE;		//We found our droid, make iteration stop here
				}
			}
			else		//Max 2 trucks repairing the same structure
			{
				if(droid.order == DORDER_REPAIR)	//If somebody is already repairing something
				{
					if((droid.orderx == structure2.x) and (droid.ordery == structure2.y))
					{
						tempDroid = NULLOBJECT;
						boolResult = FALSE;		//Stop iteration
					}
				}
			}
			droid = iterateGroup(buildGroup);
		}

		if(tempDroid != NULLOBJECT)		//Droid found and nobody already repairing
		{
			orderDroidObj(tempDroid, DORDER_REPAIR, structure2);		//Repair
		}
	}

}

//------------------------------------
//	Units stuck, do something!
//------------------------------------
event stuck(stuckTr)
{
	//Most of them have an order
	if((attackGroup.members > 0) and (idleGroup(attackGroup) < (attackGroup.members / 2)))
	{
		//If we moved
		temp = (7 * 128);

		if(repGr.members > 0)		//Have repGr
		{
			tempX = (attackGroup.x + repGr.x) / 2;		//Attack and rep group stuck often,
			tempY = (attackGroup.y + repGr.y) / 2;		//so use the middle value of the 2 groups
		}
		else
		{
			tempX = attackGroup.x;	
			tempY = attackGroup.y;
		}


		if(distBetweenTwoPoints(tempX, tempY, stuckX, stuckY) > temp)		//Moved
		{
			stuckTimes = 0;
			stuckX = tempX;		//Store new coordinates
			stuckY = tempY;	
		}			//Reset
		else
		{
			stuckTimes = stuckTimes + 1;
		}

		result = 35;
		result2 = result + 15;

		//If they are really stuck
		if((stuckTimes > result) and (stuckTimes < result2))
		{
			showConsoleText(DebugMsg[9], player);		//STUCK: Running a bit

			//count = 0;
			//while(count < 5)
			//{
				//Run a bit
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(attackGroup);
				}

				//Run a bit
				initIterateGroup(sendOutpostGr);
				droid = iterateGroup(sendOutpostGr);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(sendOutpostGr);
				}

				//Run a bit
				initIterateGroup(repGr);
				droid = iterateGroup(repGr);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(repGr);
				}
			//	count = count + 1;
			//}
		}
		else if(stuckTimes >= result2)
		{
			showConsoleText(DebugMsg[10], player);		//STUCK: Removing obstacles

			//Wipe out any structure near the group or some units if there are no structures
			resetStructTargets();
			result = (5 * 128);
			structure = structTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
			if(structure == NULLOBJECT)
			{
				setStructTarPref(ST_WALL);
				structure = structTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
			}

			if(structure != NULLOBJECT)
			{
				orderGroupObj(attackGroup, DORDER_ATTACK, structure);
			}
			else
			{
				resetDroidTargets();
				tempDroid = droidTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
				if(tempDroid != NULLOBJECT)
				{
					orderGroupObj(attackGroup, DORDER_ATTACK, tempDroid);
				}
			}
		}
		else if(stuckTimes > (result2 + 20))	//Destroy 20 objects, then reset
		{
			stuckTimes = 0;			//Try to get out now
		}
	}
}

//=============================================================================================
//							VTOLs
//=============================================================================================
//---------------------
//	Build rearm pads
//---------------------
event buildVtolPads(inactive)
{
	if(getStructure(vtolFactory,player) != NULLOBJECT)	//If we have VTOL factory
	{
		if(alreadyAttacked and (not powerSaving))	//If we already have built an attack force
		{
			//Count rearm pads
			//----------------
			initEnumStruct(FALSE,vtolPad,player,player);
			structure= enumStruct();
			count	 = 0;
			while(structure != NULLOBJECT)
			{
				count = count + 1;
				structure= enumStruct();
			}

			//Do we have enough rearm pads?
			//-----------------------------
			if(count < ((maxTVtols + maxSVtols) / 2))
			{
				//Find nearest truck
				//------------------
				buildX = baseX;
				buildY = baseY;
				result = 99999;
				tempDroid = NULLOBJECT;
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE)
					{
						result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
						if(result2 < result)
						{
							result = result2;
							tempDroid = droid;
						}
					}
					droid = iterateGroup(buildGroup);
				}

				//Build vtol rearm pads
				//---------------------
				boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,player);
				if((boolResult == TRUE) and (tempDroid != NULLOBJECT))
				{
					orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolPad, buildX, buildY);
				}
			}
		}
	}
	else if((not powerSaving) and (alreadyAttacked))	//Build VTOL Factory
	{
		if(isStructureAvailable(vtolFactory,player))
		{
			//Find nearest truck
			//------------------
			buildX = baseX;
			buildY = baseY;
			result = 99999;
			tempDroid = NULLOBJECT;
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			//Build VTOL Facrory
			//------------------
			boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,player);
			if((boolResult == TRUE) and (tempDroid != NULLOBJECT))
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolFactory, buildX, buildY);
			}
		}
	}
}

//----------------------
//	Build VTOLs
//----------------------
event buildVtols(buildVtolsTr)
{
	structure = getStructure(vtolPad,player);			//Got vtol pads?
	if((structure != NULLOBJECT) and (alreadyAttacked) and (not powerSaving))	//Got pads and already have an attack force					
	{
		structure = getStructure(vtolFactory,player);
		if(structure != NULLOBJECT)
		{
			//Check if we can afford heavy templates
			//--------------------------------------
			temp = 0;			//Light templates
			if(playerPower(player) > muchoPower)
			{
				temp = 1;		//Use heavy, expensive templates, if can afford it
			}

			//Check if we have any antitank template
			//--------------------------------------
			boolResult = FALSE;
			count = numTVtolTemplates - 1;
			count2 = 0;
			while((count >= 0) and (boolResult == FALSE))
			{
				if(skCanBuildTemplate(player,structure, tVtols[temp][count]))
				{
					boolResult = TRUE;
				}
				count = count - 1;
			}

			//Check if we have any antistructure template
			//-------------------------------------------
			boolResult2 = FALSE;
			count = numSVtolTemplates - 1;
			count2 = 0;
			while((count >= 0) and (not boolResult2))
			{
				if(skCanBuildTemplate(player,structure, sVtols[temp][count]) )
				{
					boolResult2 = TRUE;
				}
				count = count - 1;
			}

			//Build Cyborg Transport
			//-------------------------------------
			result = 0;
			if((transportDroid == NULLOBJECT) and (dropEnabled) and (transportGr.members > 7))
			{
				result = 3;
			}
			else
			{
				//Decide for which group to build VTOLs
				//-------------------------------------
				if((tVtolGr.members < maxTVtols) and ((tVtolGr.members <= sVtolGr.members) or (not boolResult2)))
				{
					result = 1;	//tVtolGr
				}
				//else if((sVtolGr.members < maxSVtols) and ((sVtolGr.members < tVtolGr.members) or (not boolResult)))
				else if(sVtolGr.members < maxSVtols)
				{
					result = 2;	//sVtolGr
				}
			}

			//Build Vtols
			//-------------------------------------
			if(result > 0)
			{
				if(structureIdle(structure))	// if factory idle
				{
					count2 = 0;
					if(result == 2)		//sVtolGr
					{
						count = numSVtolTemplates - 1;
						while((count2 < numSVtolTemplates) and (count >= 0))
						{
							if(skCanBuildTemplate(player,structure, sVtols[temp][count]) )
							{
								tmplChoice[count2] = sVtols[temp][count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
					}
					else if(result == 1)				//tVtolGr
					{
						count = numTVtolTemplates - 1;
						while((count2 < numTVtolTemplates) and (count >= 0))
						{
							if(skCanBuildTemplate(player,structure, tVtols[temp][count]) )
							{
								tmplChoice[count2] = tVtols[temp][count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
					}
					else	//Transport
					{
						count2 = 1;
						tmplChoice[0] = Transport;
					}

					//Build it
					//--------------------
					if(count2 > 0)
					{
						buildDroid(tmplChoice[random(count2)],structure,player,1);
					}
				}
				structure = enumStruct();
			}
		}
	}
}

//----------------------------
// Build VTOL defenses
//----------------------------
event vtolDefend(vtolDefendTr)
{
	if(baseobj != NULLOBJECT)
	{
		if(baseobj.player != player)	//Wasn't our own tank
		{
			//Break alliance if our ally has attacked us
			//------------------------------------------
			if(allianceExistsBetween(player, baseobj.player))	//If we allied
			{
				breakAlliance(player, baseobj.player);		//No backstabbing
			}

			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					if(structure != NULLOBJECT)		//Attacked structure still exists
					{
						buildX = structure.x;
						buildY = structure.y;

						result = 99999;
						tempDroid = NULLOBJECT;
	
						initIterateGroup(buildGroup);
						droid = iterateGroup(buildGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order == DORDER_NONE)
							{
								result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
								if(result2 < result)
								{
									result = result2;
									tempDroid = droid;
								}
							}
							droid = iterateGroup(buildGroup);
						}

						if(tempDroid != NULLOBJECT)		//If we have a truck
						{
							//Find best defense we can build
							//------------------------------
							count = 0;
							count2 = -1;
							while(count < numVtolDefStr)
							{
								if(isStructureAvailable(vtolDefStruct[count],player))
								{
									count2 = count;
								}
								count = count + 1;
							}

							if(count2 != (-1) )	//If we have a structure to build
							{
								boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,player);
								if(boolResult == TRUE)
								{
									orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolDefStruct[count2],buildX,buildY);
								}
							}
						}
					}
				}
				else		//Attacked by a tank
				{
					tVtolObject = baseobj;
				}	
			}
			else			//Attacked by a structure
			{
				sVtolObject = baseobj;
			}

			//Remember this attacker
			//if(defendObject == NULLOBJECT)		//Killed last attacker already, remember new one
			//{
				//Defend group
				if(structure != NULLOBJECT)		//Attacked structure still exists
				{
					//If structure is in the base
					if((structure.x > minx) and (structure.x < maxx) and (structure.y > miny) and (structure.y < maxy))
					{
						if(baseobj.type == OBJ_STRUCTURE)
						{
							defendObject = baseobj;
						}
						else if(baseobj.type == OBJ_DROID)
						{
							tempDroid = objToDroid(baseobj);
							//if(not isVtol(tempDroid))
							if(tempDroid.propulsion != vtolProp)
							{
								defendObject = baseobj;
							}
						}
					}
				}
			//}

			//Attack
			if(defendObject != NULLOBJECT)
			{
				if(defendGr.members > 0)
				{
					if(idleGroup(defendGr) >= (defendGr.members / 2))
					{
						showConsoleText(DebugMsg[13], player);		//Base attacked. Defending.

						orderGroupLoc(defendGr, DORDER_SCOUT, defendObject.x, defendObject.y);
					}
				}

				//Use collectSendGr group too, since they are just idling anyway
				if(collectSendGr.members > 0)
				{
					if(idleGroup(collectSendGr) >= (collectSendGr.members / 2))
					{
						orderGroupLoc(collectSendGr, DORDER_SCOUT, defendObject.x, defendObject.y);
					}
				}
				defendObject = NULLOBJECT;	//Reset
			}
		}

	}
}


//----------------------------------
//Build min number of VTOL defenses
//----------------------------------
event additVTOLDefenses(additVTOLDefensesTr)
{
	if((not defendingBase) and (alreadyAttacked))
	{
		//Count VTOL defenses
		//-------------------
		result = 0;
		count = 0;
		while(count < numVtolDefStr)
		{
			initEnumStruct(FALSE,vtolDefStruct[count],player,player);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y < maxy))	//If in the base
				{
					result = result + 1;
				}
				structure = enumStruct();
			}
			count = count + 1;
		}

		//Min number of VTOL defenses
		temp = 16;		/*%!	ID="MinVTOL_AdditDefences",
						MainDesc="Min number of VTOL defences",
						type="asn",		//Assign
						val="16",
						ArgDesc="16 (Default)",
						val="0",
						ArgDesc="No additional defences",
						val="5",
						ArgDesc="5",
						val="10",
						ArgDesc="10",
						val="20",
						ArgDesc="20",
						val="25",
						ArgDesc="25",
						val="30",
						ArgDesc="30"	*/
		if(powerSaving)
		{
			//Don't buld too many if not enough power
			temp = 7;	/*%!	ID="MinVTOL_AdditDefencesLowPow",
						MainDesc="Low power VTOL defences",
						type="asn",		//Assign
						val="7",
						ArgDesc="7 (Default)",
						val="0",
						ArgDesc="No additional defences",
						val="3",
						ArgDesc="3",
						val="5",
						ArgDesc="5",
						val="7",
						ArgDesc="7",
						val="10",
						ArgDesc="10",
						val="temp",
						ArgDesc="Same value as above"	*/
		}

		if(result < temp)
		{
			//Find the best VTOL defense available
			//------------------------------------
			count = 0;
			temp = -1;
			while(count < numVtolDefStr)
			{
				if(isStructureAvailable(vtolDefStruct[count],player))
				{
					temp = count;
				}
				count = count + 1;
			}

			if(temp != (-1) )	//If we have a structure to build
			{
				buildX = baseX;
				buildY = baseY;

				boolResult = pickStructLocation(vtolDefStruct[temp], ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					//Find closest droid
					//------------------------------------
					result = 99999;
					tempDroid = NULLOBJECT;

					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						if(droid.order == DORDER_NONE)
						{
							result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
							if(result2 < result)
							{
								result = result2;
								tempDroid = droid;
							}
						}
						droid = iterateGroup(buildGroup);
					}

					if(tempDroid != NULLOBJECT)		//If we have a truck
					{
						orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolDefStruct[temp],buildX,buildY);
					}
				}
			}

		}
	}
}

//------------------------------------------
//Attack enemy objects in the base
//------------------------------------------
event agressiveDefence(agressiveDefenceTr)
{
	//If defenders got carried away from the base, make them return
	if((defendGr.x < minx) or (defendGr.y < miny) or (defendGr.x > maxx) or (defendGr.y > maxy))
	{
		buildX = baseX;
		buildY = baseY;
		if(pickStructLocation(factory, ref buildX, ref buildY, player))		//Find an open spot
		{
			orderGroupLoc(defendGr, DORDER_SCOUT, buildX, buildY);		//Send back
			orderGroupLoc(collectSendGr, DORDER_SCOUT, buildX, buildY);	//Send back
		}
	}

	result = defendGr.members + collectSendGr.members;
	if(result > 3)		//Have defenders
	{
		if((idleGroup(defendGr) + idleGroup(collectSendGr)) > (result / 2))	//Not busy
		{
			//Find enemy droids in the base
			//-----------------------------
			resetDroidTargets();
			setDroidTarPref(DT_WEAP_GROUND);	//Ignore VTOLs, tanks only
			setDroidTarIgnore(DT_VTOL);

			tempDroid = NULLOBJECT;
			count = 0;
			while((count < numEnemies) and (tempDroid == NULLOBJECT))
			{
				tempDroid = droidTargetInArea(Enemies[count], player, minx, miny, maxx, maxy);	//Droid
				count = count + 1;
			}

			if(tempDroid != NULLOBJECT)
			{
				//Check if we are following our own tank
				//--------------------------------------
				if((tempDroid.player == player) or (isVtol(tempDroid)))
				{
					tempDroid = NULLOBJECT;
				}

			}

			//Still have an attacker
			if(tempDroid != NULLOBJECT)
			{
				showConsoleText(DebugMsg[14], player);		//Agressive defence
				orderGroupLoc(defendGr, DORDER_SCOUT, tempDroid.x, tempDroid.y);
				orderGroupLoc(collectSendGr, DORDER_SCOUT, tempDroid.x, tempDroid.y);

				if(idleGroup(sVtolGr) == sVtolGr.members)
				{
					orderGroupObj(sVtolGr, DORDER_ATTACK, tempDroid);
				}

				if(idleGroup(tVtolGr) == tVtolGr.members)
				{
					orderGroupObj(tVtolGr, DORDER_ATTACK, tempDroid);
				}

			}

		}
	}
}

//-------------------------
//	Attack with VTOLs
//-------------------------
event vtolAttack(vtolAttackTr)
{
	temp = (KeepDist / 2);			//Enemy base range
	//if(attackPhase > 1)
	if(curEnemy != -1)
	{
		//-------------------------
		//Attack with anitank VTOLs
		//-------------------------
		boolResult = FALSE;
		if(tVtolObject == NULLOBJECT)		//No target
		{
			boolResult = TRUE;
		}
		//else if(tVtolObject.player != curEnemy)		//Attacking another player
		//{
		//	boolResult = TRUE;
		//}

		//If we can attack
		if(boolResult)
		{
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);			//Find truck to attack
			//tempDroid = droidTargetInArea(curEnemy, -1, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);

			//if(tempDroid == NULLOBJECT)
			//{
				tempDroid = droidTargetOnMap(curEnemy, -1);
			//}

			if(tempDroid == NULLOBJECT)				//No truck, find another unit
			{
				resetDroidTargets();
				setDroidTarPref(DT_WEAP_GROUND);		//Ground,air,idf units
				setDroidTarIgnore(DT_LEGS);			//Ignore cyborgs
				setDroidTarIgnore(DT_LIGHT);			//Ignore light units
				tempDroid = droidTargetOnMap(curEnemy, curEnemy);
				//tempDroid = droidTargetInArea(curEnemy, curEnemy, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
			}


			if(tempDroid != NULLOBJECT)				//Attack
			{
				tVtolObject = tempDroid;			//Remember
			}
		}

		//-------------------------------
		//Attack with antistructure VTOLs
		//-------------------------------
		boolResult = FALSE;
		if(sVtolObject == NULLOBJECT)		//No target
		{
			boolResult = TRUE;
		}
		//else if(sVtolObject.player != curEnemy)		//Attacking another player
		//{
		//	boolResult = TRUE;
		//}

		//If we can attack
		if(boolResult)
		{
			count = 0;
			structure = NULLOBJECT;
			while((count < 6) and (structure == NULLOBJECT))
			{
				resetStructTargets();
				setStructTarPref(sPref[count]);			//Find structure to attack
				structure = structTargetInArea(curEnemy, -1, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
				count = count + 1;
			}

			if(structure == NULLOBJECT)				//No structure, find another structure
			{
				resetStructTargets();
				setStructTarPref(ST_DEF_ALL);			//Ground,air,idf
				structure = structTargetOnMap(curEnemy, -1);
			}

			if(structure != NULLOBJECT)				//Attack
			{
				sVtolObject = structure;			//Remember
			}
		}
	}
	else
	{
		//-------------------------
		//Attack with anitank VTOLs
		//-------------------------
		if(tVtolObject == NULLOBJECT)
		{
			//Find truck
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);

			count = 0;
			droid = NULLOBJECT;
			while((count < numEnemies) and (droid == NULLOBJECT))
			{
				droid = droidTargetOnMap(Enemies[count], Enemies[count]);
				count = count + 1;
			}

			//No truck, find another unit
			if(droid == NULLOBJECT)
			{
				resetDroidTargets();
				setDroidTarPref(DT_WEAP_ALL);		//Any weapon unit

				count = 0;
				droid = NULLOBJECT;
				while((count < numEnemies) and (droid == NULLOBJECT))
				{
					droid = droidTargetOnMap(Enemies[count], Enemies[count]);
					count = count + 1;
				}
			}

			if(droid != NULLOBJECT)
			{
				tVtolObject = droid;
			}
		}

		//-------------------------------
		//Attack with antistructure VTOLs
		//-------------------------------
		if(sVtolObject == NULLOBJECT)
		{
			//Find structure
			count = 0;
			structure = NULLOBJECT;
			while((count < numEnemies) and (structure == NULLOBJECT))
			{
				count2 = 0;
				while((count2 < 6) and (structure == NULLOBJECT))
				{
					resetStructTargets();
					setStructTarPref(sPref[count2]);			//Find structure to attack
					structure = structTargetOnMap(Enemies[count], Enemies[count]);
					count2 = count2 + 1;
				}
				count = count + 1;
			}

			if(structure != NULLOBJECT)
			{
				sVtolObject = structure;
			}
		}
	}


	//------
	//Attack
	//------

	//Antitank
	if(tVtolObject != NULLOBJECT)
	{
		if((idleGroup(tVtolGr) >= (tVtolGr.members - 1)) and (tVtolGr.members >= maxTVtols))		//Enough VTOLs?
		{
			orderGroupObj(tVtolGr, DORDER_ATTACK, tVtolObject);		//Attack
		}
		else if((idleGroup(tVtolGr) <= (tVtolGr.members / 2)) and (tVtolGr.members <= (maxTVtols / 2)))
		{
			orderGroup(tVtolGr, DORDER_RTB);
		}
	}

	//Antistructure
	if(sVtolObject != NULLOBJECT)
	{
		if((idleGroup(sVtolGr) >= (sVtolGr.members - 1)) and (sVtolGr.members >= maxSVtols))		//Enough VTOLs?
		{
			orderGroupObj(sVtolGr, DORDER_ATTACK, sVtolObject);		//Attack
		}
		else if((idleGroup(sVtolGr) <= (sVtolGr.members / 2)) and (sVtolGr.members <= (maxSVtols / 2)))		//Return home
		{
			orderGroup(sVtolGr, DORDER_RTB);
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Alliance Rules

// form alliances
event formAllianceEvent(every, 170)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(formAllianceEvent,	inactive);			
	}
	else
	{
		count = 0;
		while(count<8)
		{
			if( count != player )												// if not the only other player and rand2
			{
				if((getDroidCount(player) > 1) and (getDroidCount(count) > 1) )	// not dead
				{
						if(not isHumanPlayer(count))							// not human
						{
							createAlliance(player,count);
							allianceTime[count] = gameTime;
						}
				}
			}
			count = count + 1;	
		}
		setEventTrigger(formAllianceEvent,	inactive);
	}
}

//--------------------
//Human alliances
//--------------------
event formHumanAlliances(humanAllianceTr)
{
	if(count2 == player) //If offered to me
	{
		randomiseSeed();
		if(random(2) == 1)
		{
			showConsoleText(ai_ally_msg[random(4)],count);
		}
	}
}

//=====================================================================================================
//					CYBORG TRANSPORT
//=====================================================================================================
event cyborgDrop(cyborgDropTr)
{
	/********************************
		dropPhase:
		0 - idle
		1 - loading
		2 - on the way to lz
		3 - landing
		4 - landed and released cyborgs, transport returning home
	********************************/

	//Wait until all droids are loaded
	//--------------------------------
	if(dropPhase == 1)		//Loading
	{
		boolResult = TRUE;
		if(transportDroid == NULLOBJECT)		//Was destroyed
		{
			boolResult = FALSE;
			dropPhase = 0;			//Stop
		}

		if(boolResult)		//If transport is still there
		{
			

			//Check if all droids are idle (loaded into transport)
			//----------------------------------------------------
			boolResult = TRUE;
			initIterateGroup(transportGr);
			droid = iterateGroup(transportGr);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y, transportDroid.x, transportDroid.y) > 256)
				{
					boolResult = FALSE;
					if((droid.orderx != transportDroid.x) or (droid.ordery != transportDroid.y))		//Not going to the transport
					{
						orderDroidLoc(droid, DORDER_MOVE, transportDroid.x, transportDroid.y);		//Go to the transport
					}
				}
				else		//Load
				{
					vanishUnit(droid);
				}

				droid = iterateGroup(transportGr);
			}

			//Order transport to fly to the enemy to unload the units
			//-------------------------------------------------------
			if((boolResult) and (curEnemy >= 0) and (curEnemyX > 0))			//If all loaded
			{
				//Find an enemy base structure that is far away from the tank attack point
				//------------------------------------------------------------------------
				count = 0;
				boolResult = FALSE;
				temp = (30 * 128);		//Enemy base radius
				result = 0;
				while(count < numBaseStructs)
				{
					initEnumStruct(FALSE,baseStructs[count],curEnemy,player);		//Find visible in-base structure that is far away from the attack point (more efficient)
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						//if(losTwoObjects(transportDroid, structure, FALSE))	//If can see enemy base structure
						//{
							
							result2 = distBetweenTwoPoints(curEnemyX,curEnemyY, structure.x, structure.y);
							if(result2 < temp)		//In the enemy base
							{
								//setFogColour(1, random(200) + 50, 1);
								if(result2 > result)	//Further away
								{
									//setFogColour(1, 1, random(200) + 50);
									result = result2;
									LZ_X = structure.x;
									LZ_Y = structure.y;
								}
							}
						//}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//setFogColour(random(200) + 50, 1, 1);

				if(result == 0)
				{
					temp = (7 * 128);	//temp / 2;
					resetStructTargets();
					structure = structTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
					if(structure != NULLOBJECT)
					{
						//setFogColour(1, random(200) + 50, random(200) + 50);
						LZ_X = structure.x;
						LZ_Y = structure.y;
						result = 1;
					}
				}

				if(result > 0)	//Found a structure
				{
					temp = (7 * 128);
					//resetStructTargets();
					//setStructTarPref(ST_DEF_AIR);		//Make sure no AA
					//structure = structTargetInArea(curEnemy, curEnemy, LZ_X - temp, LZ_Y - temp, LZ_X + temp, LZ_Y + temp);
					//if(structure == NULLOBJECT)	//No AA
					//{
						boolResult = pickStructLocation(wall, ref LZ_X, ref LZ_Y,player);
						if(boolResult)
						{
							//centreViewPos(LZ_X, LZ_Y);
							//setFogColour(random(200) + 50, 1, random(200) + 50);
							orderDroidLoc(transportDroid, DORDER_MOVE, LZ_X, LZ_Y);

							if(transportDroid.order != DORDER_NONE)
							{
								dropPhase = 2;
							}
							else
							{
								resetPlayerVisibility(player);		//Reset structures which were discovered and *are not visible anymore*
							}
						}
					//}
				}

				//orderDroidLoc(transportDroid, DORDER_SCOUT, LZ_X, LZ_Y);		//Take off
			}
		}
	}
	else if(dropPhase == 2)		//On the way to LZ
	{
		

		if(transportDroid != NULLOBJECT)
		{
			if(transportDroid.order == DORDER_NONE)		//If reached LZ and is landing
			{
				dropPhase = 3;
				transportZ = -1;		//Remember current height of the transport
			}
		}
		else		//Transport destroyed
		{
			dropPhase = 0;
		}
	}
	else if(dropPhase == 3)		//Landing on LZ
	{
		

		//Release cyborgs if stopped landiong
		//-----------------------------------
		if(transportDroid != NULLOBJECT)
		{
			if(transportZ == transportDroid.z)	//If stopped landing
			{
				//setFogColour(random(200) + 50, 1, 1);

				//'Unload' best cyborgs with best templates available
				//---------------------------------------------------
				structure = getStructure(cybFactory,player);
				if(structure != NULLOBJECT)
				{
					if(cybTemplate > -1)
					{
						//setFogColour(random(200) + 50, random(200) + 50, 1);

						//Cyborgs with weapons
						//--------------------
						result = 0;
						while(result < 8)		//Unload 8 weapon cyborgs
						{
							
							droid = addDroid(cybTmpl[cybTemplate], transportDroid.x, transportDroid.y, player);
							if(droid != NULLOBJECT)
							{
								//orderDroid(droid, DORDER_RUN);		//Don't stay too compact
								//groupAddDroid(attackGroup, droid);
								groupAddDroid(dropGr, droid);
							}
							result = result + 1;
						}

						//Mechanics
						//--------------------
						result = 0;
						while(result < 2)		//Unload 2 mechanics
						{
							droid = addDroid(cybMechanic, transportDroid.x, transportDroid.y, player);	//Add mechanic
							//groupAddDroid(attackGroup,droid);
							groupAddDroid(dropGr, droid);
							result = result + 1;
						}
						
					}
				}


				orderDroid(transportDroid, DORDER_RTB);
				//orderDroidLoc(transportDroid, DORDER_MOVE, baseX, baseY);	//Send transport back to the base
				dropPhase = 4;
			}
		}
		else	//Transport destroyed
		{
			dropPhase = 0;
		}

		transportZ = transportDroid.z;
	}
	else if(dropPhase == 4)		//Transport returning to the base
	{

		if(transportDroid != NULLOBJECT)
		{
			if(transportDroid.order == DORDER_NONE)		//If reached LZ and is landing
			{
				dropPhase = 0;
			}
		}
		else
		{
			dropPhase = 0;
		}
	}

	if((attackPhase > 2) and (dropPhase == 0))	//Attacking enemy base and not already transporting
	//if(dropPhase == 0)	//Attacking enemy base and not already transporting
	{
		if((transportDroid != NULLOBJECT) and (curEnemyX > 0))
		{
			if((transportGr.members >= 10) and (transportDroid.order == DORDER_NONE))
			{
				showConsoleText(DebugMsg[8], player);		//Initializing drop

				//Load transport
				//----------------------------
				initIterateGroup(transportGr);
				droid = iterateGroup(transportGr);
				while(droid != NULLOBJECT)
				{
					orderDroidLoc(droid, DORDER_MOVE, transportDroid.x, transportDroid.y);
					//setDroidSecondary(droid, DSO_RETURN_TO_LOC, DSS_RTL_TRANSPORT);
					//orderDroidObj(droid, DORDER_EMBARK, transportDroid);
					droid = iterateGroup(transportGr);
				}

				//LZ_X = curEnemyX;
				//LZ_Y = curEnemyY;

				dropPhase = 1;		//Loading Transport
			}
		}
	}
}

//---------------------------------------------
//Attack with cyborgs
//---------------------------------------------
event manageDropAttacks(manageDropAttacksTr)
{
	if(dropGr.members > 0)
	{
		if(idleGroup(dropGr) >= (dropGr.members / 2))
		{
			if((curEnemyX > 0) and (curEnemy > -1))
			{
				//Find a target
				//-------------
				tempX = dropGr.x;
				tempY = dropGr.y;
				temp = (15 * 128);
				count = 0;		//Attack base structures
				while(count < numBaseStructs)
				{
					initEnumStruct(FALSE,baseStructs[count],curEnemy,player);			
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						if(distBetweenTwoPoints(tempX, tempY, structure.x, structure.y) < temp)		//If in the enemy base
						{
							boolResult = TRUE;
							initIterateGroup(dropGr);
							droid = iterateGroup(dropGr);
							while(droid != NULLOBJECT)
							{
								//if(droid.droidType != DROID_REPAIR)		//Mechanics stay near the group
								//{
									if(droid.order != DORDER_ATTACK)	//Not already attacking
									{
										if(losTwoObjects(droid, structure, FALSE))	//If can see this structure
										{
											orderDroidObj(droid, DORDER_ATTACK, structure);
											//sVtolObject = structure;
										}
									}
								//}
								droid = iterateGroup(dropGr);
							}
						}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//Still no target, attack the base
				//--------------------------------
				if(idleGroup(dropGr) >= (dropGr.members / 2))
				{
					orderGroupLoc(dropGr, DORDER_SCOUT, curEnemyX, curEnemyY);
				}
			}
		}
	}
}

//------------------------------------------------------
//Make attackers return to the base if base is in danger
//------------------------------------------------------
event WatchDefendBase(WatchDefendBaseTr)
{
	//temp = 20 * 128;	//Search radius

	//if(bigMap)
	//{
	//	temp = 12 * 128;
	//}
	//else
	//{
	//	temp = 0;
	//}

	//tempX = minx - temp;
	//tempY = miny - temp;
	//buildX = maxx + temp;
	//buildY = maxy + temp;

	tempX = minx;
	tempY = miny;
	buildX = maxx;
	buildY = maxy;

	//Check everything's within limits
	//--------------------------------
	if(tempX < 0)			{	tempX = 128;	}
	if(tempY < 0)			{	tempY = 128;	}
	if(buildX > (mapWidth * 128))	{	buildX = (mapWidth * 128) - 128;	}
	if(buildY > (mapHeight * 128))	{	buildY = (mapHeight * 128) - 128;	}

	//Count enemies
	//--------------------------
	resetDroidTargets();
	setDroidTarPref(DT_WEAP_GROUND);	//Tanks only, ignore VTOLs
	result = 0;
	count = 0;
	while(count < numEnemies)
	{
		result = numDroidsInArea(Enemies[count], tempX, tempY, buildX, buildY) + result;	//Count enemy units
		count = count + 1;
	}


	//---------------------------
	//If not defending right now
	//---------------------------
	if(not defendingBase)
	{
		//If too many enemies
		//---------------------------------
		if(result > (defendGr.members + collectSendGr.members + 5))	//collectSendGr is also in the base
		{
			defendingBase = TRUE;
			powerSaving = TRUE;		//Save some power
			attackPhase = 1;		//Re-initialize attack later

			showConsoleText(DebugMsg[0], player);	//Base defence active

			NumOldDefenders = defendGr.members;	//Revert to this number after threat is gone

			//Order back to the base (before addign to defeners, so that defenders wouldn't cancel defending, if they already are)
			orderGroupLoc(sendOutpostGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(collectSendGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(attackGroup, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(oilGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(repairedGroup, DORDER_MOVE, baseX, baseY);

			//Add to defenders now
			groupAddGroup(defendGr, sendOutpostGr);
			groupAddGroup(defendGr, repairedGroup);
			groupAddGroup(defendGr, collectSendGr);
			groupAddGroup(defendGr, attackGroup);
			groupAddGroup(defendGr, oilGr);

			setGroupSecondary(defendGr, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Don't return to the outpost for repair
		}
	}
	else		//If defending and no threat, then cancel defend state
	{
		boolResult = FALSE;
		if(result < 2)		//Almost all kiled
		{
			boolResult = TRUE;
		}
		//else			//Compare number of enemy and friendly units in the base
		//{
		//	result2 = numDroidsInArea(player, tempX, tempY, buildX, buildY);
		//	if(result2 > (result + 8))
		//	{
		//		boolResult = TRUE;
		//	}
		//}

		if(boolResult)		//Can stop defending
		{
			showConsoleText(DebugMsg[1], player);	//Base defence off
			defendingBase = FALSE;

			if(NumOldDefenders < 8)		//Leave enough defenders
			{
				NumOldDefenders = 8;
			}

			//Add defenders back to attackers
			//-------------------------------
			count = defendGr.members;
			initIterateGroup(defendGr);
			droid = iterateGroup(defendGr);
			while((droid != NULLOBJECT) and (count > NumOldDefenders))		//While there are now more defenders that there were
			{
				if(droid.droidType != DROID_REPAIR)		//Leave repair unit for the defenders
				{
					orderDroid(droid, DORDER_STOP);		//Make idle
					groupAddDroid(sendOutpostGr, droid);	//Add back to attackers
					count = count - 1;	
				}
				droid = iterateGroup(defendGr);
			}

			toRepDefendDroid[0] = NULLOBJECT;		//Make repairer stop following this unit if it became an attacker
			toRepDefendDroid[1] = NULLOBJECT;

			NumOldDefenders = 0;

		}
	}
}

//-------------------------------------
//Help an ally if he's in trouble
//-------------------------------------
event WatchHelpAlly(WatchHelpAllyTr)
{
	temp = (12 * 128);	//Base radius around the found structure

	if((not defendingBase) and (helpAllyPlayer < 0))	//Not busy
	{
		if(attackGroup.members > 5)
		{
			count = 0;
			while((count < 8) and (helpAllyPlayer < 0))	//For all 8 players and while haven't started helping to defend yet
			{
				if(allyPlayer[count])
				{
					//Find ally base
					//--------------------------------------
					boolResult2 = FALSE;
					count2 = 0;
					while((count2 < numBaseStructs) and (not boolResult2))	//For all base structures
					{
						structure = getStructure(baseStructs[count2], count);	//Find Ally's base structure
						if(structure != NULLOBJECT)
						{
							tempX = structure.x;
							tempY = structure.y;
							boolResult2 = TRUE;		//Found base
						}
						count2 = count2 + 1;
					}

					if(boolResult2)	//If base found
					{
						temp = 12 * 128;	//Search radius

						result = numDroidsInArea(count, tempX - temp, tempY - temp, tempX + temp, tempY + temp);	//Count Ally's units

						//Count number of enemies in ally's base
						//--------------------------------------
						result2 = 0;
						count2 = 0;
						while(count2 < numEnemies)
						{
							result2 = numDroidsInArea(Enemies[count2], tempX - temp, tempY - temp, tempX + temp, tempY + temp) + result2;	//Count enemy units
							count2 = count2 + 1;
						}

						if(result2 > (result + 7))	//If many more enemy than ally units in ally's base
						{
							showConsoleText(DebugMsg[12], player);		//Helping ally's base

							//Collect attackers
							groupAddGroup(attackGroup, sendOutpostGr);
							groupAddGroup(attackGroup, repairedGroup);
							groupAddGroup(attackGroup, oilGr);
							//groupAddGroup(attackGroup, collectSendGr);

							setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Don't return to the outpost for repair
							attackPhase = 1;		//Re-initialize attack later
							helpAllyPlayer = count;
						}
					}
				}
				count = count + 1;
			}
		}
	}
	else if(helpAllyPlayer > (-1))	//Helping an ally already
	{
		if((helpAllyPlayerX > (-1)) and (helpAllyPlayerY > (-1)))	//Help coords exist
		{
			//Check if threat is gone now
			//---------------------------
			result = numDroidsInArea(helpAllyPlayer, helpAllyPlayerX - temp, helpAllyPlayerY - temp, helpAllyPlayerX + temp, helpAllyPlayerY + temp);	//Count Ally's units

			//Count number of enemies in ally's base
			//--------------------------------------
			result2 = 0;
			count2 = 0;
			while(count2 < numEnemies)
			{
				result2 = numDroidsInArea(Enemies[count2], helpAllyPlayerX - temp, helpAllyPlayerY - temp, helpAllyPlayerX + temp, helpAllyPlayerY + temp) + result2;	//Count enemy units
				count2 = count2 + 1;
			}

			if((result > (result2 + 6)) or (result2 == 0))	//If ally has more units than enemy or no enemy units at all
			{
				showConsoleText(DebugMsg[13], player);		//Ally's base is safe. Returning.

				helpAllyPlayer = -1;		//Cancel 'help AI base' state
				helpAllyPlayerX = -1;
				helpAllyPlayerY = -1;
			}

		}
	}
}

event PowerBoost(PowerBoostTr)
{
	//Customizable power cheat
	temp = 25;
	addPower(temp, player);		/*%!	ID="GKPowerBoost",
					MainDesc="Power boost amount",
					type="asn",		//Assign
					val="0",
					ArgDesc="No power boost (Default)",
					val="25",		//5*5
					ArgDesc="Small power boost",
					val="60",		//12*5
					ArgDesc="Medium power boost",
					val="200",		//40*5
					ArgDesc="Big power boost",
					val="450",		//90*5
					ArgDesc="Huge power boost"	*/
}

event deactivate(CALL_GAMEINIT)
{
	debugMode = FALSE;	/*%!	ID="GK_Debug",
						MainDesc="Enable GK debug (observe) mode",
						MoreInfo="<Help2>",
						type="asn",		//Assign
						tmpl="YesNo"	*/

	if( (not debugMode) and ((player == selectedPlayer) or (not myResponsibility(player))) )
	{
		setEventTrigger(StartGame,inactive);
		setEventTrigger(LegoBuild,inactive);
		setEventTrigger(Rush,inactive);
		setEventTrigger(chooseEnemy,inactive);
		setEventTrigger(BuildAttackForce,inactive);
		setEventTrigger(doResearch,inactive);
		setEventTrigger(basedetails,inactive);
		setEventTrigger(keepTrack,inactive);
		setEventTrigger(droidDestroyed,inactive);
		setEventTrigger(buildPowerGenerators,inactive);
		setEventTrigger(LegoTrucks,inactive);
		setEventTrigger(droidBuilt,inactive);
		setEventTrigger(difficultyMod,inactive);
		setEventTrigger(upgradeStructures,inactive);
		setEventTrigger(moveIfAttacked,inactive);
		setEventTrigger(stuck,inactive);
		setEventTrigger(buildVtols,inactive);
		setEventTrigger(vtolDefend,inactive);
		setEventTrigger(vtolAttack,inactive);
		setEventTrigger(formAllianceEvent,inactive);
		setEventTrigger(formHumanAlliances,inactive);
		setEventTrigger(updateDetails,inactive);
		setEventTrigger(repairStuff,inactive);
		setEventTrigger(FinishStructures,inactive);
		setEventTrigger(buildCyborgs,inactive);
		setEventTrigger(cyborgDrop,inactive);
		setEventTrigger(manageDropAttacks,inactive);
		setEventTrigger(WatchDefendBase,inactive);
		setEventTrigger(WatchHelpAlly,inactive);
		setEventTrigger(sendScouts,inactive);
		setEventTrigger(agressiveDefence,inactive);
		setEventTrigger(additVTOLDefenses,inactive);
		setEventTrigger(PowerBoost,inactive);
	}
}
