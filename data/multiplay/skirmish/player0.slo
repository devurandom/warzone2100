/////////////////////////////////////////////////////////////////////
// general ai for skirmish game
/////////////////////////////////////////////////////////////////////
// Warzone2100, Pumpkin Studios,
// alex lee.98/99.
//
/////////////////////////////////////////////////////////////////////

//Tile in world units
#define	TILE					128

// These are final rules of the lexical parser
#define	R_REQUEST_HELP			"help me"
#define	R_REQUEST_BEACON		"drop a beacon"
#define	R_REPORT_SAFETY			"i'm ok"

// These are our own messages - lexical parser should be able to handle them
#define M_REQUEST_HELP			"help me!!"
#define M_REQUEST_BEACON		"drop a beacon"
#define M_AFFIRMATIVE_OK		"ok"
#define M_AFFIRMATIVE_ROGER		"roger"
#define M_ANNOYED				"bug off"
#define M_HELPERS_KILLED		"that was all I had.."
#define M_HELP_NO_UNITS			"I don't have anything"

// Base threat range in world units
#define	W_BASE_THREAT_RANGE		((17 + (mapWidth + mapHeight) / 2 / 35) * TILE)
#define ALL_ALLIES				-1
#define	MAX_PLAYERS				8

#define	BASE_DEFEND_DURATION		(3 * 60)
#define	BASE_DEFEND_RADIUS		(15 * TILE)

// Delay before we repeat our request, in seconds
#define HELP_REQUEST_INTERVAL	(3 * 60)

//in secs
#define BEACON_TIMEOUT			30

#define	MAX_DROIDS				150

//range for trucks to look for more oil
#define MORE_OIL_RANGE			(10 * TILE)
//don't try to build on oil if there's threat within this range
#define	OIL_THREAT_RANGE		(9 * TILE)

#define	MAX_TRUCKS				12
#define	MIN_TRUCKS				4

//Enter power saving mode when lower than this
#define	LOW_POWER				250

//Target type values
#define	NO_TARGET_VALUE			0
#define	DROID_TARGET_VALUE		1
#define	OTHER_TARGET_VALUE		2
#define	DEFENSE_TARGET_VALUE	3
#define	RESEARCH_TARGET_VALUE	4
#define	HQ_TARGET_VALUE			5
#define	OIL_TARGET_VALUE		6
#define	FACTORY_TARGET_VALUE	7

public	int				me;			// player for this instance.
public	int				tileExpand;			// rate of exploration

public	int				numScouts;			// aim for...
public	int				numDefenders;
public	int				numAttackers;

// structures
private int				baseX,baseY,minx,miny,maxx,maxy;
public	int				numStructs,numIncendrys,numDefStructs,numExtraStructs,numWallWeaps,numBaseStruct;
public	STRUCTURESTAT	incendrys[8],structs[13],defStructs[26],extraStructs[6],structChoice[5],wallWeaps[11];
public	STRUCTURESTAT	sensorTower,wallStruct,resLab,powGen,playerHQ,lassat,factory,derrick,cybFactory,
						vtolDefStruct[5],vtolPad,vtolFactory,repairFacility,uplink,baseStruct[8];
public	STRUCTURESTAT	powModule,facModule,resModule,vtolModule;
public	int				extraStruct;

// unit templates
public	int				numTemplates;
public	TEMPLATE		tmpl[80];
private	TEMPLATE		tmplChoice[5];

public	TEMPLATE		cybTempl[4],superCyb[4];

public	TEMPLATE		vtols[18];
public	int				numVtolTemplates;

public	TEMPLATE		sense[11];
public	int				numSenseTemplates;

public	TEMPLATE		constructor,repairUnit;
public	int				numCyborgs,numRepairUnits;
private int				currentCyborgs,currentCyborgTemplate;

//defend
private GROUP			defendGroup;
private bool			defendbusy;
private BASEOBJ			defendObj;

public  RESEARCHSTAT	nexusDefence;

//build
private GROUP			buildGroup;
private int				buildX,buildY,buildX2,buildY2;
public	FEATURESTAT		oilRes;

// scout
private GROUP			scoutGroup;
private int				scoutX,scoutY;
private int				scoutTLX,scoutTLY,scoutW,scoutH;

// attack
private GROUP			attackGroup;
private BASEOBJ			attackObj,allOutAttack;

// vtols
private GROUP			vtolGroup;

// generic
private STRUCTURE		structure,structure2;
private DROID			droid;
private FEATURE			feature;
private BASEOBJ			baseobj,baseobj2;
private int				count,count2,result,result2,tempx,tempy;
private bool			boolResult,boolResult2;

private bool			powerSave,_DEBUG;
private	int				allianceTime[8];
private int				sender,x,y,beaconX[8],beaconY[8],tBeacon[8],
						tLastHelpRequest,lastHelpPlayer,tHelp,tHelpTimeout,helpX,helpY;
private string			message;

private	int				defendX,defendY,defendRadius,tDefendStart,tDefendTimeout,
						defendMoveType,baseRange;

/////////////////////////////////////////////////////////////////////
// triggers.

#region triggers
trigger buildExpandTr				(every, 600);
trigger fortifyTr					(every,	1000);
trigger upgradeStructuresTr			(every, 400 );
trigger conDroidsTr					(every, 1400);	// was 3600
trigger repairDroidsTr				(every, 2600);
trigger	managePowerTr				(every, 1500);
trigger basedetailsTr				(every, 600	);
trigger buildDerrickTr				(every, 80	);
trigger buildOilDefenseOrRetreatTr	(every, 120	);
trigger incendryTr					(every, 250 );
trigger buildPowerGeneratorsTr		(every, 80	);
trigger buildBaseTr					(every, 150	);
trigger finishStructsTr				(every, 500 );
trigger droidBuiltTr				(CALL_NEWDROID,me, ref droid,ref structure);
trigger	structBuiltTr				(CALL_STRUCTBUILT, me, ref droid, ref structure);
trigger droidDestroyedTr			(CALL_DROID_DESTROYED,  me, ref droid);
trigger consolidateEventTr			(every,	3100);
trigger factoryEventTr				(every, 170	);
trigger cyborgFactoryEventTr		(every, 170	);
trigger chooseScoutAreaTr			(every,	200	);
trigger expandScoutAreaTr			(every,	600	);
trigger scoutMainTr					(every,	150	);
trigger newObjectReportTr			(CALL_OBJ_SEEN, me, ref baseobj, ref baseobj2);
trigger attackStuffTr				(every, 300	);
trigger allOutAttackTr				(every, 2000);
trigger defendWatchTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
trigger defendReturnTr				(every,	500	);
trigger doResearchTr				(every, 450 );
trigger vtolDefendTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
trigger vtolStructsTr				(every, 360);
trigger buildVtolsTr				(every, 360);
trigger vtolAttackTr				(every, 460);
trigger vtolEnablerTr				(every, 2100);
trigger takeoverTr					(CALL_UNITTAKEOVER, ref droid);
trigger useLassatTr					(every, 3000);
trigger reassignTr					(CALL_PLAYERLEFT,count);
trigger formAllianceEventTr			(every,170);
trigger breakAllianceEventTr		(every,3000);
trigger difficultyModifierTr		(every,600);
trigger humanAllianceTr				(CALL_ALLIANCEOFFER,ref count, ref count2);
trigger multiMsgTr					(CALL_AI_MSG, me, ref sender, ref message);
trigger	beaconTr					(CALL_BEACON, me, ref sender, ref x, ref y, ref message);
trigger watchBaseThreatTr			(every, 120);
trigger manageAllyHelpTr			(every, 80);
trigger everySecTr					(every, 10);
trigger manageDefendLocationTr		(every, 70);

/* Events */
event	multiMsgEv;
event	beaconEv;
event	watchBaseThreat;
event	manageAllyHelp;
event	everySecEv;
event	manageDefendLocationEv;

/* Function prototypes */
function bool haveBeacon(int _player);
function bool beaconTimeout(int _player);
function void processCommand(string _message, int _sender, bool _bBlipMessage);
function bool haveHelpers();
function bool attemptToHelp(int _playerToHelp, int _x, int _y);
function void helpPlayer(int _playerToHelp, int _helpX, int _helpY);
function bool canStopHelpingAlly();
function void stopHelpingAlly();
function bool helpingAlly();
function bool helpAllyTimeout();
function void requestHelp(int _helpX, int _helpY);
function void doRequestHelp(int _helpX, int _helpY);
function bool allyBaseAtLoc(int _ally, int _x, int _y);
function void messagePlayer(int _playerToMessage, string _message);
function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message);
function bool canSeeAllies();
function bool baseInTrouble();
function string m_affirmative();
function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, int _defendRadius, bool _bMove);
function void stopDefendingLocation();
function bool defendingLocation();
function bool defendLocationTimeout();
function bool friendlyPlayer(int _playerToCheck);
function void factoryBuildDroid(STRUCTURE _factory);
function bool insideBase(int _x, int _y);
function FEATURE closestOil(int _x, int _y, bool _bAvoidThreat);
function int numAlliesInBase(bool _bVtols);
function int numEnemiesInBase(bool _bVtols);
function bool defendingOwnBase();
function int targetTypeValue(BASEOBJ _target);
function int numBitsSet(int _integer);
#endregion triggers

/////////////////////////////////////////////////////////////////////
// HouseKeeping
event initialisedEvent(CALL_GAMEINIT)
{
	// initialise
	_DEBUG = FALSE;
	dbgMsgOn(me, _DEBUG);

	extraStruct = 0;
	numRepairUnits = 0;
	allOutAttack = NULLOBJECT;
	currentCyborgTemplate = 0;
	powerSave = FALSE;

	tLastHelpRequest = -1;	//when we requested help for the last time

	lastHelpPlayer = -1;		//we are not currently helping anyone
	tHelp = -1;					//when we started helping last time
	tHelpTimeout = -1;			//time when help times out
	helpX = -1;
	helpY = -1;

	defendX = -1;
	defendY = -1;
	defendRadius = -1;
	tDefendStart = -1;
	tDefendTimeout = -1;
	defendMoveType = -1;		//move or scout

	baseRange = 4 * TILE;

	// setup build group
	//all initial droids are in buildgroup!
	groupAddArea(buildGroup, me, 0, 0, (mapWidth*128), (mapHeight*128));
	initGetFeature(oilRes,me,me);		// use bucket = player

	// note where our base is.
	initIterateGroup(buildGroup);		// find idle droids in build group.
	droid = iterateGroup(buildGroup);
	if(droid != NULLOBJECT)
	{
		baseX = droid.x;
		baseY = droid.y;
	}
	else
	{
		baseX = (128*mapWidth)/2;
		baseY = (128*mapHeight)/2;
	}

	// defence.
	defendbusy = FALSE;

	// setup scouts
	structure = getStructure(factory, me);
	if(structure != NULLOBJECT)
	{
		scoutTLX		= structure.x;
		scoutTLY		= structure.y;
	}
	else
	{
		scoutTLX		= baseX;
		scoutTLY		= baseY;
	}
	scoutW			= 256;
	scoutH			= 256;
	scoutX			= scoutTLX;
	scoutY			= scoutTLY;



	// clear the alliance array...
	allianceTime[0] = 0;
	allianceTime[1] = 0;
	allianceTime[2] = 0;
	allianceTime[3] = 0;
	allianceTime[4] = 0;
	allianceTime[5] = 0;
	allianceTime[6] = 0;
	allianceTime[7] = 0;
}

/////////////////////////////////////////////////////////////////////
// initial force setup thing. plonk down a force.
event givehelp(every, 100)
{
 	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(givehelp,	inactive);
	}
	else
	{
		if(multiPlayerBaseType == CAMP_WALLS)
		{
			// free power
			addPower(1500, me);

			// free droids.
			/* structure = getStructure(factory, me);
			if(structure != NULLOBJECT)
			{
				count = 0;
				while(count<10)
				{
					tempx = baseX;
					tempy = baseY;


					boolResult = pickStructLocation(defStructs[0], ref tempx, ref tempy,me);
					if(boolResult == TRUE)
					{
						droid = addDroid(tmpl[ random(6) ]  , tempx, tempy, me);
					}

					count = count + 1;
				}
			} */
		}
		setEventTrigger(givehelp,	inactive);

	}
}

/////////////////////////////////////////////////////////////////////
// keep details about the size and postion of the ai players base
event basedetails(basedetailsTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(basedetails,	inactive);
	}
	else
	{
		// clear old extremities.
		maxy = 0;
		maxx = 0;
		miny = (mapHeight*128);
		minx = (mapWidth*128);
		
		baseRange = 4 * TILE;

		// now find the extremities of our vital structures.
		count = 0;
		while(count < numBaseStruct)
		{
			initEnumStruct(FALSE,baseStruct[count],me,me);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				if(structure.x < minx)
				{
					minx = structure.x;
				}
				if(structure.x > maxx)
				{
					maxx = structure.x;
				}
				if(structure.y < miny)
				{
					miny = structure.y;
				}
				if(structure.y > maxy)
				{
					maxy = structure.y;
				}

				result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);

				if(result > baseRange){
					baseRange = result;
				}

				structure= enumStruct();
			}

			count = count + 1;
		}
		
		result = 3 * 128;
		minx = minx - result;
		maxx = maxx + result;
		miny = miny - result;
		maxy = maxy + result;
		
		baseRange = baseRange + (4 * 128);
	}
}

/////////////////////////////////////////////////////////////////////
// structure building rules

// build derricks on oil.
event buildDerrick(buildDerrickTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildDerrick,	inactive);
	}
	else
	{
		feature = getFeature(me);					// find unoccupied oil resource.
		if(feature != NULLOBJECT)
		{
			buildX = feature.x;
			buildY = feature.y;

			// if no more than 2 units already trying to build
			initIterateGroup(buildGroup);				// find all units in build group.
			droid = iterateGroup(buildGroup);
			count = 0;
			while(droid != NULLOBJECT)
			{
				if((droid.orderx == buildX) and (droid.ordery == buildY))
				{
					count = count + 1;
				}
				droid = iterateGroup(buildGroup);
			}

			if(count < 3)
			{
				initIterateGroup(buildGroup);				// find all units in build group.
				droid = iterateGroup(buildGroup);
				boolResult = FALSE;							// only send 1 droid to each derrick
				while( (boolResult == FALSE) and (droid != NULLOBJECT) )
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);	//build a derick
						boolResult = TRUE;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
		else											// feature is null
		{
			initGetFeature(oilRes,me,me);		// start again next time.
		}
	}
}

/////////////////////////////////////////////////////////////////////
// if idle and derrick in range and no defense then build defense, else ret to base .
event buildOilDefenseOrRetreat(buildOilDefenseOrRetreatTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildOilDefenseOrRetreat,	inactive);
	}
	else
	{
		// check idle.
		initIterateGroup(buildGroup);					// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				// if in range of a derrick
				structure = structureBuiltInRange(derrick, droid.x, droid.y, (5*128), me);

				// if inside base limits then presume ok..
				if( structure != NULLOBJECT)
				{
					if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
					{
						structure = NULLOBJECT;
					}
				}

				if(structure != NULLOBJECT)
				{
					buildX = structure.x;
					buildY = structure.y;

					count = 0;							// if derrick has no defense near it.
					result = 0;
					while(count < numDefStructs)
					{
						structure = structureBuiltInRange(defStructs[count], buildX, buildX,(3*128), me);
						if(structure != NULLOBJECT)
						{
							result = result + 1;							// found a defense.
						}
						count = count + 1;
					}

					// not many defenses nearby
					if(result < 2)
					{
						count = numDefStructs - 1;							//pick a struct to build..
						count2 = 0;
						while( (count2 < 5) and (count >= 0) )
						{
							if( isStructureAvailable(defStructs[count],me))
							{

								// don't build multiple sensors together.
								if(count == 5)
								{
									structure = structureBuiltInRange(defStructs[count], buildX, buildY,(6*128), me);
									if(structure != NULLOBJECT)
									{
										count = 8;
									}
								}

								structChoice[count2] = defStructs[count];
								count2 = count2 + 1;

							}
							count = count - 1;
						}
						count =0;
						if(count2 > 0)
						{
							count = random(count2);						 //count = choice!
							// pick a location
							boolResult = pickStructLocation(structChoice[count], ref buildX, ref buildY,me);
							if(boolResult == TRUE)
							{
								// build it.
								orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
							}
						}
					}
					else
					{
						structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
						if(structure == NULLOBJECT)
						{
							if(!insideBase(droid.x, droid.y))
							{
								orderDroid(droid,DORDER_RTB);				// return to base;
							}
						}
					}
				}
				else
				{
					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
					if(structure == NULLOBJECT)
					{
						if(!insideBase(droid.x, droid.y))
						{
							orderDroid(droid,DORDER_RTB);					// return to base;
						}
					}
				}
			}
			droid = iterateGroup(buildGroup);
		}
	}
}

/////////////////////////////////////////////////////////////////////
//mortar etc.. rules. build sensor towers and emplacements.
event incendry(incendryTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(incendry,	inactive);
	}
	else
	{
		initEnumStruct(FALSE,sensorTower,me,me);

		count = 0;
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			count = count + 1;
			structure = enumStruct();
		}

		if(count < (gameTime/4200) )		// every 7 mins
		{
			// if not found build a sensor tower.
			// find a place to build.
			buildX = 0;
			buildY = 0;
			initEnumStruct(FALSE,derrick,me,me);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				count = 0;
				result = 0;
				while(count < numDefStructs)
				{
					structure2 = structureBuiltInRange(defStructs[count], structure.x, structure.y,(4*128), me);
					if(structure2 != NULLOBJECT)
					{
						result = result + 1;
					}
					count = count + 1;
				}

				// check for sensor nearby,
				structure2 = structureBuiltInRange(sensorTower, structure.x, structure.y,(5*128), me);
				if(structure2 != NULLOBJECT)
				{
					result = 4;
				}

				if(result < 3)
				{
					buildX = structure.x;
					buildY = structure.y;
					structure = NULLOBJECT;
				}
				else
				{
					structure = enumStruct();
				}
			}

			if(buildX != 0)
			{
				boolResult = pickStructLocation(sensorTower, ref buildX, ref buildY,me);	// pick spot.
				if(boolResult == TRUE)
				{
					// find unit
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,sensorTower, buildX,buildY);
							droid = NULLOBJECT;
						}
						else
						{
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
		else
		{
			// find a sensor tower with least incencdry structs around it..
			buildX = 0;
			buildY = 0;

			initEnumStruct(FALSE,sensorTower,me,me);
			structure= enumStruct();
			count = 999;
			while(structure != NULLOBJECT)
			{
				// count incendrys near this tower.
				result = 0;
				count2 = 0;
				while(count2 < numIncendrys)
				{
					structure2 = structureBuiltInRange(incendrys[count2], structure.x, structure.y,(4*128), me);
					if(structure2 != NULLOBJECT)
					{
						result = result + 1;
					}
					count2 = count2 + 1;
				}

				if((result < 6) and (result < count))		// lowest found yet. only sites with <6 too.
				{
					buildX = structure.x;
					buildY = structure.y;
					count  = result;
				}
				structure = enumStruct();
			}

			if(buildX != 0)
			{

				// choose a device
				count = numIncendrys - 1;
				result = 99;
				while(count >= 0 )
				{
					if(isStructureAvailable(incendrys[count],me))
					{
						result = count;
						count = -1;
					}
					else
					{
						count = count - 1;
					}
				}


				// find a unit and build an incendry device.
				if(result != 99)
				{
					boolResult = pickStructLocation(incendrys[result], ref buildX, ref buildY,me);	// pick spot.
					if(boolResult == TRUE)
					{

						initIterateGroup(buildGroup);
						droid = iterateGroup(buildGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,incendrys[result], buildX,buildY);
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}

	}
}






/////////////////////////////////////////////////////////////////////
// build a power gen for every 4 derricks. VITAL!
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildPowerGenerators,	inactive);
	}
	else
	{
		initEnumStruct(FALSE,derrick,me,me);					// count = numderricks
		structure= enumStruct();
		count	 = 0;
		while(structure != NULLOBJECT)
		{
			count = count + 1;
			structure= enumStruct();
		}

		initEnumStruct(FALSE,powGen,me,me);					// count2 = numpowgens
		structure= enumStruct();
		count2	 = 0;
		while(structure != NULLOBJECT)
		{
			count2 = count2 + 1;
			structure= enumStruct();
		}

		if( (count2 * 4) < count )								// if we need powergen
		{
			buildX = baseX;										// try build powergen.
			buildY = baseY;
			boolResult = pickStructLocation(powGen, ref buildX, ref buildY,me);
			if(boolResult == TRUE)
			{
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
					}
					droid = iterateGroup(buildGroup);
				}

			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
// ensure we have everything in the vital structs list.
event buildBase(buildBaseTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildBase,	inactive);
	}
	else
	{
		if( idleGroup(buildGroup) >= (buildGroup.members/2) )
		{
			count = 0;
			while(count < numStructs)
			{
				// check that struct.
				structure = getStructure(structs[count],me);
				if(structure == NULLOBJECT)				// if missing build it.
				{
					if(isStructureAvailable(structs[count],me))
					{
						buildX = baseX;						// pick a location
						buildY = baseY;
						boolResult = pickStructLocation(structs[count], ref buildX, ref buildY,me);
						if(boolResult == TRUE)
						{
							initIterateGroup(buildGroup);				// find idle droids in build group.
							droid = iterateGroup(buildGroup);
							while(droid != NULLOBJECT)
							{
								if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,structs[count], buildX,buildY);	// build it
								}
								droid = iterateGroup(buildGroup);
							}
						}
					}
				}
				count = count + 1;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
//  build other stuff, grow the base slowly...
event buildExpand( buildExpandTr )
{

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildExpand,inactive);
	}
	else
	{

		if(extraStruct == numExtraStructs)	// loop round
		{
			extraStruct = 0;
		}

		buildX = baseX;						// pick a location
		buildY = baseY;
		boolResult = pickStructLocation(extraStructs[extraStruct], ref buildX, ref buildY,me);

		if(boolResult == TRUE)
		{
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,extraStructs[extraStruct], buildX,buildY);// build it.
				}
				droid = iterateGroup(buildGroup);
			}
			extraStruct = extraStruct + 1;
		}
	}
}


/////////////////////////////////////////////////////////////////////
//	Structure (fac/res/pow) upgrades
event upgradeStructures(upgradeStructuresTr )
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(upgradeStructures,inactive);
	}
	else
	{
		initIterateGroup(buildGroup);				// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
			{
				// got an idle constructor vehicle.
				//powergen
				initEnumStruct(FALSE,powGen,me,me);
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(powModule,me) and (not testStructureModule(me, structure, 0)))
					{
						orderDroidStatsLoc(droid,DORDER_BUILD,powModule, structure.x,structure.y);// upgrade it.
					}
					structure= enumStruct();
				}

				//factory
				if(droid.order != DORDER_BUILD)
				{
					initEnumStruct(FALSE,factory,me,me);
					structure= enumStruct();
					while(structure != NULLOBJECT)
					{
						// if upgrade is available && struct is not upgraded
						if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(structure) < 2 ))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
						}
						structure= enumStruct();
					}
				}

				//research
				if(droid.order != DORDER_BUILD)
				{
					initEnumStruct(FALSE,resLab,me,me);
					structure= enumStruct();
					while(structure != NULLOBJECT)
					{
						// if upgrade is available && struct is not upgraded
						if( isStructureAvailable(resModule,me) and (not testStructureModule(me, structure, 0)))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,resModule, structure.x,structure.y);	// upgrade it.
						}
						structure= enumStruct();
					}
				}

				//vtol Factory
				if(droid.order != DORDER_BUILD)
				{
					initEnumStruct(FALSE,vtolFactory,me,me);
					structure= enumStruct();
					while(structure != NULLOBJECT)
					{
						// if upgrade is available && struct is not upgraded
						if( isStructureAvailable(facModule,me) and (not testStructureModule(me, structure, 0)))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
						}
						structure= enumStruct();
					}
				}
			}
			droid = iterateGroup(buildGroup);
		}
	}
}


/////////////////////////////////////////////////////////////////////
//	Finish Building Part Built Structures
event finishStructs(finishStructsTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(finishStructs,	inactive);
	}
	else
	{
		initEnumStruct(TRUE,factory,me,me);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);				// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
					{
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
					}
					droid = iterateGroup(buildGroup);
				}
			}
			structure= enumStruct();
		}
	}
}


/////////////////////////////////////////////////////////////////////
//  fortify base by builiding defensive structs on the edge of the base.
// rewrote fortify to use scrSkDefenseLocation(baseX,baseY,me);

event newfortify(fortifyTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(newfortify,	inactive);
	}
	else
	{
		boolResult = FALSE;
		initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
		droid = iterateGroup(buildGroup);
		while((boolResult == FALSE) and (droid != NULLOBJECT))
		{
			if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
			{
				boolResult = TRUE;					// dont do this again!

				tempx = baseX;
				tempy = baseY;

				// choose a suitable turret.
				count = numWallWeaps - 1;
				count2 = 0;
				while( (count2 < 3) and (count >= 0) )
				{
					if( isStructureAvailable(wallWeaps[count],me))
					{
						structChoice[count2] = wallWeaps[count];
						count2 = count2 + 1;
					}
					count = count - 1;
				}
				count =0;
				if(count2 > 0)
				{
					count = random(count2);
					skDefenseLocation(ref tempx,ref tempy,wallStruct,structChoice[count],droid,me);
				}

			}
			droid = iterateGroup(buildGroup);

		}
	}
}


/////////////////////////////////////////////////////////////////////
// droid building rules
/////////////////////////////////////////////////////////////////////
// deal with a droid being built
event droidBuilt(droidBuiltTr)
{
	local STRUCTURE _repairFacility;

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(droidBuilt,	inactive);
	}
	else
	{
		if(isVtol(droid))
		{
			groupAddDroid(vtolGroup, droid);
		}
		else
		{
			if(droid.droidType == DROID_REPAIR)
			{
				numRepairUnits = numRepairUnits + 1;
			}
			if(droid.droidType == DROID_CONSTRUCT)				// if not constructor droid
			{
				groupAddDroid(buildGroup, droid);
			}
			else
			{
				if(droid.droidType == DROID_CYBORG)
				{
					groupAddDroid(defendGroup, droid);
				}
				else
				{
					if(scoutGroup.members < numScouts)
					{
						groupAddDroid(scoutGroup, droid);
					}
					else if( attackGroup.members < numAttackers)
					{
						groupAddDroid(attackGroup, droid);
					}
					else if( defendGroup.members < numDefenders)
					{
						groupAddDroid(defendGroup, droid);
					}

					else		// just make them scouts.
					{
						if(attackGroup.members > scoutGroup.members)
						{
							groupAddDroid(scoutGroup, droid);
						}
						else
						{
							groupAddDroid(attackGroup, droid);
						}
					}
				}
			}

			_repairFacility = getStructure(repairFacility,me);
			if(_repairFacility == NULLOBJECT)
			{
				setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
			}
			else
			{
				setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_LOW);
			}
		}
		
		/* Start building next droid */
		if(structure != NULLOBJECT)
		{
			if(structure.stattype == REF_FACTORY)
			{
				factoryBuildDroid(structure);
			}
		}
	}
}

/* Gets triggered when structure was built */
event structBuilt(structBuiltTr)
{
	local FEATURE	_oilResource;

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(structBuilt,inactive);
		exit;
	}

	if(structure == NULLOBJECT || droid == NULLOBJECT){
		exit;
	}

	/* factory or factory module */
	if(structure.stattype == REF_FACTORY)
	{
		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(structure) < 2 ))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
		}
	}
	else if(structure.stattype == REF_RESOURCE_EXTRACTOR)
	{
		/* get next oil resource nearby */
		_oilResource = closestOil(structure.x, structure.y, TRUE);
		
		if(_oilResource != NULLOBJECT)
		{
			if(distBetweenTwoPoints(_oilResource.x, _oilResource.y, structure.x, structure.y) < MORE_OIL_RANGE)	//not too far away
			{
				dbg("structBuilt: more oil", me);
				orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _oilResource.x, _oilResource.y);	//build a derick
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// deal with attacks.
event droidDestroyed(droidDestroyedTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(droidDestroyed,inactive);
	}
	else
	{
		if(droid.droidType == DROID_REPAIR)
		{
			numRepairUnits = numRepairUnits - 1;
		}

		if(droid.droidType == DROID_CONSTRUCT)					// if constructor droid
		{
			initEnumStruct(FALSE,factory,me,me);
			structure= enumStruct();							// find factory.

			if( (structure != NULLOBJECT) and (getDroidCount(me) < MAX_DROIDS) )
			{
				buildDroid(constructor, structure, me, 1);	// build constructor
			}

		}
	}
}


/////////////////////////////////////////////////////////////////////
// build more con droids.
event conDroids(conDroidsTr)
{
	local int	_maxTrucks;

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(conDroids,inactive);
	}
	else
	{
		_maxTrucks = MAX_TRUCKS;
		if(powerSave){
			_maxTrucks = MIN_TRUCKS;
		}
		
		initEnumStruct(FALSE,factory,me,me);
		structure= enumStruct();							// find factory.

		if((structure != NULLOBJECT)  and (getDroidCount(me) < MAX_DROIDS) and (buildGroup.members < _maxTrucks) )
		{
			buildDroid(constructor, structure, me, 1);// build constructor
		}

	}
}

/////////////////////////////////////////////////////////////////////
// build repair droids.
event repairDroids(repairDroidsTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(repairDroids,inactive);
	}
	else
	{
		// if we're running low on repair droids, build some..
		if(numRepairUnits <3)
		{
			initEnumStruct(FALSE,factory,me,me);
			structure= enumStruct();							// find factory.
			if( (structure != NULLOBJECT) and (getDroidCount(me) < MAX_DROIDS) )
			{
				buildDroid(repairUnit, structure, me, 1);	// build repairunit.
			}
		}

	}
}


/////////////////////////////////////////////////////////////////////
event factoryEvent(factoryEventTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(factoryEvent,	inactive);
	}
	else
	{
		// for each factory....
		initEnumStruct(FALSE,factory,me,me);
		structure= enumStruct();								// find factory.
		if(getDroidCount(me) < MAX_DROIDS)
		{
			while(structure != NULLOBJECT)
			{
				if( structureIdle(structure) )
				{
					factoryBuildDroid(structure);
				}

				structure= enumStruct();
			}
		}
	}
}

function void factoryBuildDroid(STRUCTURE _factory)
{
	local int _count,_count2;

	if(_factory == NULLOBJECT){
		dbg("factoryBuildDroid: factory is NULLOBJECT", me);
		return;
	}
	
	if( structureIdle(_factory) )
	{
		_count = numTemplates - 1;
		_count2 = 0;
		while( (_count2 < 4) and (_count >= 0) )
		{
			if( skCanBuildTemplate(me,_factory, tmpl[_count]) )
			{
				tmplChoice[_count2] = tmpl[_count];
				_count2 = _count2 + 1;
			}
			_count = _count - 1;
		}

		if(_count2 > 0)
		{
			buildDroid(tmplChoice[random(_count2)],_factory,me,1);
		}
	}
	else
	{
		dbg("factoryBuildDroid: factory is busy", me);
	}
}

/////////////////////////////////////////////////////////////////////
// put cyborg factories to work
event cyborgFactoryEvent(cyborgFactoryEventTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(cyborgFactoryEvent,	inactive);
	}
	else
	{
		initEnumStruct(FALSE,cybFactory,me,me);
		structure= enumStruct();								// find factory.

		while(structure != NULLOBJECT)
		{
			if( structureIdle(structure) == TRUE)
			{
				if( (defendGroup.members < numCyborgs) and (getDroidCount(me) < MAX_DROIDS) )
				{
					count = 3;
					count2 = 0;
					while( count >= 0 )
					{
						if( skCanBuildTemplate(me,structure, superCyb[count]) )
						{
							tmplChoice[count2] = superCyb[count];
							count2 = count2 + 1;
						}
						count = count - 1;
					}

					if(count2 > 0)
					{
						buildDroid(superCyb[random(count2)],structure,me,1);
					}
					else
					{
						buildDroid(cybTempl[currentCyborgTemplate], structure, me, 1);
					}
				}
			}
			structure= enumStruct();							// find factory.
		}

		// increment cyborg template counter, wrapping if required.
		currentCyborgTemplate = currentCyborgTemplate + 1;
		if( currentCyborgTemplate > 3)
		{
			currentCyborgTemplate = 0;
		}

	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// scouting rules

// scout an area
event chooseScoutArea(chooseScoutAreaTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(chooseScoutArea,	inactive);
	}
	else
	{
		scoutX = scoutTLX + random(scoutW);
		scoutY = scoutTLY + random(scoutH);
	}
}

/////////////////////////////////////////////////////////////////////
// visit new places

event expandScoutArea(expandScoutAreaTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(expandScoutArea,	inactive);
	}
	else
	{
		//expand the scouting area slightly
		scoutTLX	= scoutTLX - ((mapWidth*128)/ tileExpand);
		scoutTLY	= scoutTLY - ((mapHeight*128)/ tileExpand);
		scoutW		= scoutW + (2*((mapWidth*128)/ tileExpand));
		scoutH		= scoutH + (2*((mapHeight*128)/ tileExpand));

		// check & restrain.
		if(scoutTLX <1)
		{
			scoutTLX = 1;
		}
		if(scoutTLY <1)
		{
			scoutTLY = 1;
		}

		if(scoutTLX >(mapWidth*128))
		{
			scoutTLX = (mapWidth*128) - 128;
		}
		if(scoutTLY >(mapHeight*128))
		{
			scoutTLY = (128*mapHeight) - 128;
		}

		if( (scoutTLX + scoutW) > (128 * mapWidth) )
		{
			scoutW = ( (128 * mapWidth) - scoutTLX) - 128;
		}
		if( (scoutTLY + scoutH) > (128 *mapHeight) )
		{
			scoutH = ( (128*mapHeight) - scoutTLY) - 128;
		}
	}
}

/////////////////////////////////////////////////////////////////////
// order scouts

event scoutMain(scoutMainTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(scoutMain,	inactive);
	}
	else
	{
		// find any new scouts
		// if scouts aren't busy, send them to a new spot.
		if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
		{
			orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
		}
	}
}

/////////////////////////////////////////////////////////////////////
// process new visibility reports
event newObjectReport(newObjectReportTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(newObjectReport,	inactive);
	}
	else
	{
		if( baseobj2 != NULLOBJECT )
		{
			if((baseobj2.type == OBJ_DROID) and !friendlyPlayer(baseobj.player))
			{
				if(targetTypeValue(baseobj) > targetTypeValue(attackObj))
				{
					attackObj = baseobj;// got a new unseen  target from a scout.

					if(	attackObj.type == OBJ_STRUCTURE)
					{
						if(not allianceExistsBetween(attackObj.player,me))	// an enemy
						{
							structure = objToStructure(attackObj);
							if(structure.stat == factory)
							{
								allOutAttack = attackObj;
							}
						}
					}
				}
			}
		}
	}
}

function int targetTypeValue(BASEOBJ _target)
{
	local STRUCTURE _strTarget;

	if(_target == NULLOBJECT){
		return NO_TARGET_VALUE;
	}
	
	if(_target.type == OBJ_DROID)
	{
		return DROID_TARGET_VALUE;
	}
	else if(_target.type == OBJ_STRUCTURE)
	{
		_strTarget = objToStructure(_target);
		
		if(_strTarget.stattype == REF_DEFENSE)
		{
			return DEFENSE_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_RESEARCH or
				_strTarget.stattype == REF_POWER_GEN)
		{
			return RESEARCH_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_HQ or
				_strTarget.stattype == REF_COMMAND_CONTROL)
		{
			return HQ_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_RESOURCE_EXTRACTOR)
		{
			return OIL_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_FACTORY or
				_strTarget.stattype == REF_CYBORG_FACTORY or
				_strTarget.stattype == REF_VTOL_FACTORY)
		{
			return FACTORY_TARGET_VALUE;
		}
		else	//walls, rearm pads etc
		{
			return OTHER_TARGET_VALUE;
		}
	}
	
	return NO_TARGET_VALUE;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// spy technologies
//event takeover( CALL_UNITTAKEOVER , ref droid  )

event takeover(takeoverTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(takeover,	inactive);
	}
	else
	{
		if( droid.player == me )
		{
			groupAddDroid( attackGroup, droid );
		}
	}
}

event takeoverDefend(takeoverTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(takeoverDefend,	inactive);
	}
	else
	{
		if( droid.player != me )
		{
			completeResearch(nexusDefence,me);
			setEventTrigger(takeoverDefend,	inactive);
		}
	}
}


event useLassat(useLassatTr)
{

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(useLassat,	inactive);
	}
	else
	{
		// find my lassat
		// fire it at my attack objective.
		if(allOutAttack != NULLOBJECT)
		{
			initEnumStruct(FALSE,lassat,me,me);
			structure= enumStruct();
			while(structure != NULLOBJECT)
			{
				if(structureComplete(structure) == TRUE)
				{
					skFireLassat(me,allOutAttack);
				}
				structure= enumStruct();
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// attack rules

event findEnemy(attackStuffTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(findEnemy,	inactive);
	}
	else
	{
		if(attackObj == NULLOBJECT)
		{
			count = random(8);
			count2 = 100;
			while( friendlyPlayer(count) && (count2 > 0) )
			{
				count = random(8);
				count2--;
			}
			
			if(!friendlyPlayer(count))
			{
				baseobj = skLocateEnemy(count);
				if(baseobj != NULLOBJECT)
				{
					attackObj =	baseobj;
					allOutAttack = attackObj;
				}
			}
		}
	}

}

/////////////////////////////////////////////////////////////////////
// send attack team out to cause trouble near things scout found.
event attackStuff(attackStuffTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(attackStuff,	inactive);
	}
	else
	{
		if( idleGroup(attackGroup) >= (attackGroup.members /2))
		{
			if( (attackObj != NULLOBJECT) and (not helpingAlly()) )
			{
				if (not allianceExistsBetween(me, attackObj.player))
				{
					if(attackGroup.members > (6+random(6)) )
					{
						orderGroupLoc(attackGroup, DORDER_SCOUT,attackObj.x,attackObj.y);
					}
					if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
					{
						orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
					}
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
event doAllOutAttack(allOutAttackTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(attackStuff,	inactive);
	}
	else
	{
		if( (allOutAttack != NULLOBJECT) and (not helpingAlly()) )
		{
			if( !friendlyPlayer(allOutAttack.player) )
			{
				if( getDroidCount(me) > 40)	// plenty of units.
				{
					orderGroupObj(attackGroup, DORDER_ATTACK,allOutAttack);
					orderGroupLoc(defendGroup, DORDER_SCOUT,allOutAttack.x,allOutAttack.y);
					orderGroupLoc(scoutGroup,  DORDER_SCOUT,allOutAttack.x,allOutAttack.y);
				}
			}
			else
			{
				allOutAttack = NULLOBJECT;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// defending rules

// defend attacked objects.
event defendWatch(defendWatchTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(defendWatch,	inactive);
	}
	else
	{
		if(baseobj != NULLOBJECT)
		{
			if(!friendlyPlayer(baseobj.player))
			{
				if(not isHumanPlayer(baseobj.player) )	// new in wdg1 dont allout attack a pc player	//TODO:is this check needed?
				{
					defendObj = baseobj;
					defendbusy = TRUE;
					// if not too busy, attack.
					if( idleGroup(defendGroup) >= (defendGroup.members /2) )
					{
						orderGroupObj(defendGroup, DORDER_ATTACK, defendObj);
					}

					if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
					{
						orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
					}

				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// defenders  return after they are finished.
event defendReturn(defendReturnTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(defendReturn,	inactive);
	}
	else
	{
		if( defendbusy and (idleGroup(defendGroup) == defendGroup.members))
		{
			orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
			defendbusy = FALSE;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Research Rules Now does true research.
// do research

event doResearch(doResearchTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(doResearch,	inactive);
	}
	else
	{
		// for every research lab do this..
		initEnumStruct(FALSE,resLab,me,me);
		structure= enumStruct();
		count = 0;
		while(structure != NULLOBJECT)
		{
			skDoResearch(structure,me,0);
			structure= enumStruct();
		}


	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Alliance Rules

// form alliances
event formAllianceEvent(formAllianceEventTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(formAllianceEvent,	inactive);
	}
	else
	{
		count = 0;
		while(count<8)
		{
			if( count != me )												// if not the only other player and rand2
			{
				if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
				{
					if(random(28) == 1)											// bit random
					{
						if(not isHumanPlayer(count))							// not human
						{
							createAlliance(me,count);
							allianceTime[count] = gameTime;
						}
					}
				}
			}
			count = count + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
// break the alliance too.
event breakAllianceEvent(breakAllianceEventTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(breakAllianceEvent,	inactive);
	}
	else
	{
		count = 0;
		while(count<multiPlayerMaxPlayers)
		{
			if( count != me)
			{
				if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
				{
					if(allianceExistsBetween(me,count) )
					{
						// check if we're in alliance with any other players.
						if( (random(30) == 1) and ( (gameTime - allianceTime[count]) > 6000) )	// rand and more than 10 minutes.
						{
							allianceTime[count] = gameTime;
							breakAlliance(me,count);
						}

						// rules for breaking alliances with humans.
						// built within my base
						if(numStructsInArea(count,minx,miny,maxx,maxy) > 1)
						{
							allianceTime[count] = gameTime;
							breakAlliance(me,count);
						}

						// you've got lots of units in my area.
						if(numDroidsInArea(count,minx,miny,maxx,maxy) > 3)
						{
							allianceTime[count] = gameTime;
							breakAlliance(me,count);
						}

						// you've wiped out one of my allies ??.
					}
				}
			}
			count = count + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
event formHumanAlliances(humanAllianceTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(formHumanAlliances,	inactive);
	}
	else
	{
		if(count2 == me) // offered to me.
		{
			result = 0;
			result2 = 0;
			while(result < multiPlayerMaxPlayers)
			{
				if(allianceExistsBetween(count,result))
				{
					result2 = result2 + 1;
				}
				result = result + 1;
			}
			if( result2 < ((multiPlayerMaxPlayers / 2) - 1) )	// not too many already
			{
				//not too soon.
				if((allianceTime[count] == 0) or (gameTime - allianceTime[count] > 1200))
				{
					result = 0;								// check forming wont end the game
					result2 = 0;
					while(result < multiPlayerMaxPlayers)
					{
						while(result2 < multiPlayerMaxPlayers)
						{
							if((not allianceExistsBetween(result,result2)) and (getDroidCount(result) > 0) and (getDroidCount(result2) > 0) and (result != result2) )
							{
								if( ((result == count and result2 == count2) or (result2 == count2 and result == count)) )	// ignore the outcome of this alliance
								{
									createAlliance(me,count);
									allianceTime[count] = gameTime;
								}
							}
							result2 = result2 + 1;
						}
						result = result + 1;
					}
				}

			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Consolidate Rules

// bring forces back together to consolidate attacks
event consolidateEvent(consolidateEventTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(consolidateEvent,	inactive);
	}
	else
	{
		if(not helpingAlly())
		{
			if(random(3 ) == 1)				// order all droids home to rejoin forces.!
			{
				orderGroupLoc(scoutGroup, DORDER_MOVE,baseX,baseY);
				orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
			}

			if(attackObj != NULLOBJECT)	// consolidate any ongoing attack.
			{
				if(!friendlyPlayer(attackObj.player))
				{
					orderGroupObj(attackGroup, DORDER_ATTACK,attackObj);
				}
				else
				{
					attackObj = NULLOBJECT;
				}
			}
			else
			{
				orderGroupLoc(attackGroup, DORDER_MOVE,baseX,baseY);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// power management.

// if running low on power put some power eating stuff on hold for a while.
event managePower(managePowerTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(managePower,	inactive);
	}
	else
	{
		if( playerPower(me) < LOW_POWER )	// turn off some events.
		{
			powerSave = TRUE;

//			setEventTrigger(fortify,			inactive);	// stop building defenses.
			setEventTrigger(upgradeStructures,	inactive);	// stop building oil defenses.
		//	setEventTrigger(buildExpand,		inactive);	// stop building extra buildings.
		//	setEventTrigger(conDroids,			inactive);	// stop building more construct droids.
		}
		else
		{
			if(powerSave == TRUE)		// turn events back on.
			{
				powerSave = FALSE;

//				setEventTrigger(fortify,			fortifyTr);			 //  building defenses.
				setEventTrigger(upgradeStructures,	upgradeStructuresTr);//  building oil defenses.
		//		setEventTrigger(buildExpand,		buildExpandTr);		 //  building extra buildings.
		//		setEventTrigger(conDroids,			conDroidsTr);	  	 //  building more construct droids.
			}
		}
	}
}
/////////////////////////////////////////////////////////////////////

event difficultyModifier(difficultyModifierTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(difficultyModifier,	inactive);
	}
	else
	{
		skDifficultyModifier(me);
	}
}

/////////////////////////////////////////////////////////////////////
// vtols.
/////////////////////////////////////////////////////////////////////
// build vtol strucutures.
event vtolStructs(inactive)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(vtolStructs,inactive);
	}
	else
	{
		structure = getStructure(vtolFactory,me);	// if we dont have vtol factory
		if(structure == NULLOBJECT)						// if missing build it.
		{
			// build factory
			buildX = baseX;								// pick a location
			buildY = baseY;
			boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,me);
			if(boolResult == TRUE)
			{
				initIterateGroup(buildGroup);			// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				boolResult = FALSE;						// only send 1 droid to do the job
				while( (boolResult == FALSE) and (droid != NULLOBJECT))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,vtolFactory, buildX,buildY);
						boolResult = TRUE;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
		else	// we have a factory..
		{
			// count rearm pads
			initEnumStruct(FALSE,vtolPad,me,me);
			structure= enumStruct();
			count	 = 0;
			while(structure != NULLOBJECT)
			{
				count = count + 1;
				structure= enumStruct();
			}

			// do we have 2 or more rearm pads?
			if(count < 3)
			{
				// build vtol rearm pads.
				buildX = baseX;								// pick a location
				buildY = baseY;
				boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,me);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);			// find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while( droid != NULLOBJECT)
					{
						if((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,vtolPad, buildX,buildY);
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}


		}
	}
}


/////////////////////////////////////////////////////////////////////
// build vtols.

event buildVtols(inactive)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(buildVtols,inactive);
	}
	else
	{
		structure = getStructure(vtolPad,me);			// got vtol pads?
		if(structure != NULLOBJECT)
		{
			structure = getStructure(vtolFactory,me);	// got a vtolfac?
			if(structure != NULLOBJECT)
			{
				if(vtolGroup.members < 5)					// got enough vtols?
				{


					if( (structureIdle(structure) == TRUE) and (getDroidCount(me) < MAX_DROIDS))	// if factory idle
					{
						count = numVtolTemplates - 1;
						count2 = 0;
						while( (count2 < 3) and (count >= 0) )
						{
							if( skCanBuildTemplate(me,structure, vtols[count]) )
							{
								tmplChoice[count2] = vtols[count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
						if(count2 > 0)
						{
							buildDroid(tmplChoice[random(count2)],structure,me,1);
						}
					}
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// attack with vtols.

event vtolAttack(inactive)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(vtolAttack,inactive);
	}
	else
	{
		// if vtol group is not busy..
		if(  (idleGroup(vtolGroup) >= (vtolGroup.members /2)) and (vtolGroup.members > 2) )
		{
			if(attackObj != NULLOBJECT)
			{
				if(!friendlyPlayer(attackObj.player))
				{
					orderGroupObj(vtolGroup, DORDER_ATTACK, attackObj);	// get the attack target.
				}
				else
				{
					attackObj = NULLOBJECT;
				}
			}
			else
			{
				if(defendObj != NULLOBJECT)
				{
					if(not isHumanPlayer(defendObj.player) )	// new in wdg1 	//TODO:is this check needed?
					{
						orderGroupObj(vtolGroup, DORDER_ATTACK,defendObj);		// get the defend target
					}
				}
			}
		}
	}
}



/////////////////////////////////////////////////////////////////////
// watch for incoming vtols
event vtolDefend(vtolDefendTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(vtolDefend,inactive);
	}
	else
	{
//		boolResult2 = FALSE;					// if attacked by a vtol.
		if(baseobj != NULLOBJECT)
		{
			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					// activate other vtol functions..
					setEventTrigger(vtolStructs,vtolStructsTr);
					setEventTrigger(buildVtols,	buildVtolsTr);
					setEventTrigger(vtolAttack,	vtolAttackTr);

					// build defenses.
					initIterateGroup(buildGroup);		// find idle droids in build group.
					droid = iterateGroup(buildGroup);
//					while( (boolResult2 != TRUE) and (droid != NULLOBJECT))
					while( droid != NULLOBJECT)
					{
						if( (structure != NULLOBJECT) and (droid.order != DORDER_BUILD) )
						{
							buildX = structure.x;
							buildY = structure.y;
							//	if ! vtol defense already built...

							//find best defense we can build.
							count = 0;
							count2 = -1;
							while( count < 5)
							{
								if(isStructureAvailable(vtolDefStruct[count],me))
								{
									count2 = count;
								}
								count = count + 1;
							}
							if(count2 != (-1) )
							{
								boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,me);
								if(boolResult == TRUE)	// build a vtol defense near the attacked struct...
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
//									boolResult2 = TRUE;
								}
							}

						}
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
event vtolEnabler(vtolEnablerTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(vtolEnabler,inactive);
	}
	else
	{
		if( skVtolEnableCheck(me) )					// check to see if we have vtol technologies.
		{
			setEventTrigger(vtolEnabler,inactive);		// turn off this event.
			setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol functions..
			setEventTrigger(buildVtols,	buildVtolsTr);
			setEventTrigger(vtolAttack,	vtolAttackTr);
		}
	}
}

/////////////////////////////////////////////////////////////////////
// HouseKeeping

event reassignPlayers(reassignTr)
{
	setEventTrigger(basedetails,basedetailsTr);
	setEventTrigger(buildDerrick,buildDerrickTr);
	setEventTrigger(buildOilDefenseOrRetreat,buildOilDefenseOrRetreatTr);
	setEventTrigger(incendry,incendryTr);
	setEventTrigger(buildPowerGenerators,buildPowerGeneratorsTr);
	setEventTrigger(buildBase,buildBaseTr );
	setEventTrigger(buildExpand,buildExpandTr );
	setEventTrigger(upgradeStructures,upgradeStructuresTr );
	setEventTrigger(finishStructs,finishStructsTr );
	setEventTrigger(newfortify,fortifyTr );
	setEventTrigger(droidBuilt,droidBuiltTr);
	setEventTrigger(droidDestroyed,droidDestroyedTr);
	setEventTrigger(conDroids,conDroidsTr);
	setEventTrigger(repairDroids,repairDroidsTr);
	setEventTrigger(factoryEvent,factoryEventTr);
	setEventTrigger(cyborgFactoryEvent,cyborgFactoryEventTr);
	setEventTrigger(chooseScoutArea,chooseScoutAreaTr);
	setEventTrigger(expandScoutArea,expandScoutAreaTr);
	setEventTrigger(scoutMain,scoutMainTr);
	setEventTrigger(newObjectReport,newObjectReportTr);
	setEventTrigger(takeover,takeoverTr);
	setEventTrigger(useLassat,useLassatTr);
	setEventTrigger(findEnemy,attackStuffTr);
	setEventTrigger(attackStuff,attackStuffTr);
	setEventTrigger(doAllOutAttack,allOutAttackTr);
	setEventTrigger(defendWatch,defendWatchTr);
	setEventTrigger(defendReturn,defendReturnTr);
	setEventTrigger(doResearch,doResearchTr);
	setEventTrigger(formAllianceEvent,formAllianceEventTr);
	setEventTrigger(breakAllianceEvent,breakAllianceEventTr);
	setEventTrigger(consolidateEvent,consolidateEventTr);
	setEventTrigger(managePower,managePowerTr);
	setEventTrigger(difficultyModifier,difficultyModifierTr);
	setEventTrigger(vtolStructs,inactive);
	setEventTrigger(buildVtols,inactive);
	setEventTrigger(vtolAttack,inactive);
	setEventTrigger(vtolDefend,vtolDefendTr);
	setEventTrigger(vtolEnabler,vtolEnablerTr);
	setEventTrigger(formHumanAlliances,humanAllianceTr);
	setEventTrigger(multiMsgEv, multiMsgTr);
	setEventTrigger(beaconEv, beaconTr);
	setEventTrigger(watchBaseThreat, watchBaseThreatTr);
	setEventTrigger(manageAllyHelp, manageAllyHelpTr);
	setEventTrigger(everySecEv, everySecTr);
	setEventTrigger(manageDefendLocationEv, manageDefendLocationTr);
	setEventTrigger(structBuilt, structBuiltTr);
}

/* Returns true if we just received a beacon from a certain player */
function bool haveBeacon(int _player)
{
		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
		{
			return TRUE;	//have beacon for this player
		}

		return FALSE;
}

/* See if last beacon was placed long ago */
function bool beaconTimeout(int _player)
{
	if((tBeacon[_player] > 0) and
		((tBeacon[_player] + BEACON_TIMEOUT) < (gameTime / 10)))	//not too long ago
	{
		return TRUE;	//this beacon is still 'fresh'
	}

	return FALSE;
}

/* Deal with beacons */
event beaconEv(beaconTr)
{
	local	int			_players;
	local	string		_processedString;

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(beaconEv,	inactive);
		exit;
	}

	if(_DEBUG)
		debug(me & ") beaconEv: from " & sender);

	ASSERT(sender >= 0 and sender < 8,
		"beaconEv: sender out of bounds: " & sender , me);

	beaconX[sender] = x;
	beaconY[sender] = y;
	tBeacon[sender] = gameTime / 10;

	processCommand(message, sender, TRUE);
}

/* Deal with a chat message */
event multiMsgEv(multiMsgTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(multiMsgEv,	inactive);
		exit;
	}

	if(_DEBUG)
		debug(me & ") multiMsgEv: from " & sender);

	if(not allianceExistsBetween(me, sender)){
		exit;
	}

	if(sender == me){
		exit;
	}

	processCommand(message, sender, FALSE);
}

/* Process multiplayer messages */
function void processCommand(string _message, int _sender, bool _bBlipMessage)
{
	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y;
	local	string		_msg,_processedString;

	/* Extract semantic information */
	_curMsg = 0;
	_numMsgs = processChatMsg(_message);

	debug(me & ") processCommand: '" & _message & "' from " & _sender);
	dbg("processCommand: '" & _message & "' from " & _sender, me);
	dbg("got " & _numMsgs & " commands", me);

	/* Process all messages */
	while(_curMsg < _numMsgs)
	{
		if(chatCmdIsPlayerAddressed(_curMsg, me))
		{
			dbg("i'm addressed", me);
			_msg = getChatCmdDescription(_curMsg);

			/* Someone requested help */
			if(_msg == R_REQUEST_HELP)
			{
				dbg("'help' command", me);

				if(haveBeacon(_sender))
				{
					dbg("got beacon", me);

					_x = beaconX[_sender];
					_y = beaconY[_sender];

					if(attemptToHelp(_sender, _x, _y))
					{
						messagePlayer(ALL_ALLIES, m_affirmative());
					}
				}
				else
				{
					/* Ask player to drop a beacon so we would know where to help */
					_addressedPlayers = setBit(0, _sender, TRUE);
					messagePlayerAddressed(ALL_ALLIES, _addressedPlayers, R_REQUEST_BEACON);
				}
			}
			/* Someone requested a beacon from us -
			 * did we request help and our beacon timed out??
			 */
			else if(_msg == M_REQUEST_BEACON)
			{
				/* If our base is really in trouble drop a beacon for the requester again */
				if(baseInTrouble()){
					dropBeacon(getPlayerName(me), _sender, me, baseX, baseY, 0);
				}
			}
			else if(_msg == R_REPORT_SAFETY)
			{
				dbg("helping " & lastHelpPlayer, me);

				/* Make sure we were helping him */
				if(helpingAlly() and (lastHelpPlayer == _sender))
				{
					stopHelpingAlly();
					messagePlayer(ALL_ALLIES, m_affirmative());
				}
				else if(defendingOwnBase())	//if we are in trouble re-request help
				{
					requestHelp(baseX, baseY);
				}
			}
			else
			{
				dbg("unknown message", me);
			}

		}
		else
		{
			dbg("i'm not addressed", me);
		}

		_curMsg++;
	}
}

function bool attemptToHelp(int _playerToHelp, int _x, int _y)
{
	local bool _bHelpingMyself;

	if(_playerToHelp < 0 or _playerToHelp >= MAX_PLAYERS){
		return FALSE;
	}

	if(_x <= 0 or _y <= 0){
		return FALSE;
	}

	dbg("attemptToHelp - checking", me);

	_bHelpingMyself = (_playerToHelp == me);

	/* Can only help allies and myself */
	if(not friendlyPlayer(_playerToHelp)){
		return FALSE;
	}

	if(_bHelpingMyself or !helpingAlly() or (lastHelpPlayer == _playerToHelp) )	//if not helping any other ally or it's me who needs help
	{
		dbg("not busy helping", me);

		if(haveHelpers() or _DEBUG)
		{
			dbg("got attackers", me);
			if(allyBaseAtLoc(_playerToHelp, _x, _y))	//is he just trying to misuse us?
			{
				helpPlayer(_playerToHelp, _x, _y);
				return TRUE;
			}
			else if( random(10) < 5)
			{
				dbg("ally needs no help", me);
				messagePlayer(ALL_ALLIES, M_ANNOYED);
			}
		}
		else
		{
			messagePlayer(ALL_ALLIES, M_HELP_NO_UNITS);
		}
	}
	else if((lastHelpPlayer >= 0) and (lastHelpPlayer < MAX_PLAYERS))
	{
		if(!_bHelpingMyself){
			messagePlayer(ALL_ALLIES, "helping " & getPlayerName(lastHelpPlayer) & " already");
		}
	}

	return FALSE;
}

/* Start helping player */
function void helpPlayer(int _playerToHelp, int _helpX, int _helpY)
{
	local int _tTravelTime;
	
	dbg("helping " & _playerToHelp, me);

	if(_DEBUG)
		debug(me & ") helpPlayer: '" & _playerToHelp);
		
	/* Move scoutes to attackers */
	groupAddGroup(attackGroup, scoutGroup);

	//Calculate travel time, assume ~ 150 tiles in 4 minutes
	if(attackGroup.members == 0){
		_tTravelTime = (int)((float)(distBetweenTwoPoints(baseX, baseY, _helpX, _helpY) / 128 ) * 1.7); 
	}else{
		_tTravelTime = (int)((float)(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _helpX, _helpY) / 128 ) * 1.7); 
	}

	tHelp = gameTime / 10;
	tHelpTimeout = (gameTime / 10) + BASE_DEFEND_DURATION + _tTravelTime;
	lastHelpPlayer = _playerToHelp;
	helpX = _helpX;
	helpY = _helpY;

	/* Scouts and attackers go to help */
	defendLocation(_helpX, _helpY, tHelpTimeout, BASE_DEFEND_RADIUS, (_playerToHelp == me));
}

/* Returns a random affirmative responce */
function string m_affirmative()
{
	local int _rnd;

	_rnd = random(4);
	if(_rnd == 3)
	{
		return M_AFFIRMATIVE_ROGER;
	}

	return M_AFFIRMATIVE_OK;
}

/* See if there are any base structures belonging to ally at a certain location */
function bool allyBaseAtLoc(int _ally, int _x, int _y)
{
	local int _structIndex;

	if(_x <= 0 or _y <= 0){
		return FALSE;
	}

	if(_ally < 0 or _ally >= MAX_PLAYERS){
		return FALSE;
	}

	_structIndex = 0;
	while(_structIndex < numBaseStruct)
	{
		if(numStructsByStatInRange(baseStruct[_structIndex], _x, _y, (7 * 128), me, _ally) > 0 )
		{
			return TRUE;
		}

		_structIndex++;
	}

	return FALSE;
}

event manageAllyHelp(manageAllyHelpTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(manageAllyHelp,	inactive);
		exit;
	}

	if(helpingAlly())
	{
		if(canStopHelpingAlly())
		{
			stopHelpingAlly();
		}
		//else
		//{
		//	/* See if all units we sent were killed */
		//	if(not haveHelpers())
		//	{
		//		if(random(4) == 0)
		//		{
		//			messagePlayer(lastHelpPlayer, M_HELPERS_KILLED);
		//		}

		//		if(not attemptToHelp(lastHelpPlayer, helpX, helpY))
		//		{
		//			dbg("NO UNITS, STOPPED HELPING", me);
		//			stopHelpingAlly();		//don't make sense to try again
		//		}
		//		else
		//		{
		//			dbg("SENDING REINFORCEMENTS", me);
		//		}
		//	}
		//}
	}
}

event everySecEv(everySecTr)
{
	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(everySecEv,	inactive);
		exit;
	}

	/* Check if we were helping long enough */
	if(helpingAlly())
	{
		if(helpAllyTimeout())
		{
			stopHelpingAlly();
		}
	}

	if(defendingLocation())
	{
		if(defendLocationTimeout())
		{
			stopDefendingLocation();
		}
	}
}

/* Do we have any units we can send to help ally ? */
function bool haveHelpers()
{
	if(attackGroup.members == 0){
		return FALSE;
	}

	return TRUE;
}

function bool helpingAlly()
{
	if(lastHelpPlayer >= 0){
		return TRUE;
	}

	return FALSE;
}

/* Returns true if we were helping long enough */
function bool helpAllyTimeout()
{
	if(tHelpTimeout < (gameTime / 10) ){
		return TRUE;
	}

	return FALSE;
}

function bool canStopHelpingAlly()
{
	if(lastHelpPlayer < 0)
	{
		ASSERT(FALSE, "canStopHelpingAlly: lastHelpPlayer < 0", me);
		return TRUE;
	}

	/* Were helping long enough or someone's backstabbing */
	if(!friendlyPlayer(lastHelpPlayer)){
		return TRUE;
	}

	/* Nothing to defend anymore */
	if(!allyBaseAtLoc(lastHelpPlayer, helpX, helpY)){
		return TRUE;
	}

	return FALSE;
}

function void stopHelpingAlly()
{
	dbg("stopped helping", me);

	tHelp = -1;
	tHelpTimeout = -1;
	lastHelpPlayer = -1;
	helpX = -1;
	helpY = -1;

	stopDefendingLocation();
}

/* Send a multiplayer message to an ally */
function void messagePlayer(int _playerToMessage, string _message)
{
	local int	_player;

	ASSERT(_playerToMessage >= -1 && _playerToMessage < MAX_PLAYERS,
		"messagePlayer: player out of bounds: " & _playerToMessage, me);

	_player = 0;
	if(_playerToMessage == ALL_ALLIES)	//everyone
	{
		while(_player < MAX_PLAYERS)
		{
			/* Send message (allies only)) */
			if(allianceExistsBetween(me, _player)){
				msg(_message, me, _player);
			}

			_player++;
		}
	}
	else	//a certain player
	{
		/* Send message (allies only)) */
		if(allianceExistsBetween(me, _playerToMessage)){
			msg(_message, me, _playerToMessage);
		}
	}
}

function int numBitsSet(int _integer)
{
	local	int		_position,_result;
	
	_position = 0;
	_result = 0;
	while(_position < 8)
	{
		if(getBit(_integer, _position))
		{
			_result++;
		}
		_position++;
	}
	
	return _result;
}

/* Send a multiplayer message, addressing some player(s) */
function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message)
{
	local	int		_player,_totalAddressed,_curAddressed;
	local	string	_adrMessage;
	
	_totalAddressed = numBitsSet(_playersToAddress);
	
	ASSERT(_totalAddressed > 0, "messagePlayerAddressed: no players addressed", me);

	_adrMessage = " ";
	
	_player = 0;
	_curAddressed = 0;
	while(_player < MAX_PLAYERS)
	{
		if(getBit(_playersToAddress, _player))
		{
			_curAddressed++;
			
			_adrMessage = _adrMessage & getPlayerName(_player);

			//if(_totalAddressed == 1){	//one only
			//	_adrMessage = getPlayerName(_player);
			//}else 
			
			if(_totalAddressed > 1)
			{
				if(_curAddressed == _totalAddressed){		//end
					_adrMessage = _adrMessage & " and " & getPlayerName(_player);
				}else{
					_adrMessage = _adrMessage & ", " & getPlayerName(_player); 
				}
			}

		}
		_player++;
	}
	
	_message = _adrMessage &  " " & _message;
	
	//Now send the message to all players addressed
	messagePlayer(_playerToMessage, _message);
}

/* Returns true if we can see our allies on the map */
function bool canSeeAllies()
{
	local STRUCTURE _uplink;

	/* Can see allies when team mode is on */
	if(multiPlayerAlliancesType == ALLIANCES_TEAMS)
	{
		return TRUE;
	}

	/* Can see whole map if we have uplink */
	_uplink = getStructure(uplink, me);
	if(_uplink != NULLOBJECT)
	{
		/* Make sure finished building */
		if(structureComplete(_uplink))
		{
			return TRUE;
		}
	}

	return FALSE;
}

function bool defendingOwnBase()
{
	if(helpingAlly() && lastHelpPlayer == me){
		return TRUE;
	}
	
	return FALSE;
}

/* Call for help when our base is in danger */
event watchBaseThreat(watchBaseThreatTr)
{
 	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(watchBaseThreat, inactive);
		exit;
	}

	/* See if we can stop defending */
	if(defendingOwnBase())
	{
		if(numEnemiesInBase(FALSE) == 0)
		{
			stopHelpingAlly();	//stop defending our own base
			
			/* Let allies know we don't need their help anymore */
			messagePlayer(ALL_ALLIES, R_REPORT_SAFETY);
			exit;
		}
	}
	
	/* See if our base is in trouble and we need help */
	if(baseInTrouble())
	{
		if(!defendingOwnBase())	//make sure not already defending the base
		{
			if(_DEBUG)
				debug(me & ") watchBaseThreat: base in trouble");
				
			dbg("watchBaseThreat: base in trouble", me);

			/* Bring our forces back if needed */
			if(helpingAlly())
			{
				stopHelpingAlly();
			}

			/* Defend my own base */
			helpPlayer(me, baseX, baseY);
		}

		/* Request help once in a while */
		requestHelp(baseX, baseY);
		exit;
	}
}

function int numAlliesInBase(bool _bVtols)
{
	local int _numAllies;
	
	_numAllies = numFriendlyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
	_numAllies = _numAllies + 
					numFriendlyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE) / 2;
				
	return _numAllies;
}

function int numEnemiesInBase(bool _bVtols)
{
	local int _numEnemies;
	
	_numEnemies = numEnemyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
	_numEnemies = _numEnemies + 
				numEnemyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE) / 4;
				
	return _numEnemies;
}

/* Returns true if our base is in trouble */
function bool baseInTrouble()
{
	local int _enemyForce,_friendlyForce;

	_friendlyForce = numAlliesInBase(FALSE);
	_enemyForce = numEnemiesInBase(FALSE);

	/* See if we are in trouble */
	if(_enemyForce > 0 && _enemyForce >= _friendlyForce){
		dbg("baseInTrouble: " & _enemyForce & " >= " & _friendlyForce, me);
		return TRUE;
	}

	return FALSE;
}

/* Request help from allies */
function void requestHelp(int _helpX, int _helpY)
{
	/* Don't do this too frequently */
	if(tLastHelpRequest + HELP_REQUEST_INTERVAL > (gameTime / 10) ){
		return;
	}

	doRequestHelp(_helpX, _helpY);
}

function void doRequestHelp(int _helpX, int _helpY)
{
	local int _ally;

	/* Remember when we requested help last time */
	tLastHelpRequest = gameTime / 10;

	/* Drop beacon for all allies so they would know where to help */
	_ally = 0;
	while(_ally < MAX_PLAYERS)
	{
		if(allianceExistsBetween(me, _ally)){
			if(_DEBUG)
				debug(me & ") requestHelp: " & _ally);

			dropBeacon(getPlayerName(me), _ally, me, _helpX, _helpY, 0);
		}
		_ally++;
	}

	/* Now send message with help request */
	messagePlayer(ALL_ALLIES, M_REQUEST_HELP);
}

function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, int _defendRadius, bool _bMove)
{
	dbg("starting defending for " & _tDefendTimeout - (gameTime / 10) & " secs, with defend radius " & _defendRadius, me);

	defendX = _defendX;
	defendY = _defendY;

	defendRadius = _defendRadius;
	tDefendStart = gameTime / 10;
	
	/* Should already include travel time */
	tDefendTimeout = _tDefendTimeout;

	/* See if we have to move or scout */
	defendMoveType = DORDER_SCOUT;
	if(_bMove){
		defendMoveType = DORDER_MOVE;
	}

	/* Send attackers */
	if(attackGroup.members > 0)
	{
		if(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _defendX, _defendY) > _defendRadius)
		{
			orderGroupLoc(attackGroup, defendMoveType, _defendX, _defendY);
		}
	}

	setEventTrigger(manageDefendLocationEv,	manageDefendLocationTr);
}

function void stopDefendingLocation()
{
	dbg("stopped defending location", me);

	defendX = -1;
	defendY = -1;

	defendRadius = -1;

	tDefendStart = -1;
	tDefendTimeout = -1;

	defendMoveType = -1;

	setEventTrigger(manageDefendLocationEv,	inactive);

	orderGroupLoc(attackGroup, DORDER_SCOUT,baseX,baseY);
}

function bool defendingLocation()
{
	if(defendX > 0 and defendY > 0){
		return TRUE;
	}

	return FALSE;
}

event manageDefendLocationEv(inactive)
{
	local DROID _droid;
	
	dbg("manageDefendLocationEv", me);

	if(not _DEBUG and ((me == selectedPlayer) or not myResponsibility(me)) )
	{
		setEventTrigger(manageDefendLocationEv,	inactive);
		exit;
	}

	ASSERT(defendRadius >= TILE,
		"manageDefendLocationEv: defendRadius too low:" & defendRadius, me);

	ASSERT(defendMoveType == DORDER_MOVE || defendMoveType == DORDER_SCOUT,
		"manageDefendLocationEv: wrong move order:" & defendMoveType, me);

	ASSERT(defendX > 0 && defendY > 0,
		"manageDefendLocationEv: x/y coordinates:" & defendX & "/" & defendY, me);

	if(!(defendX > 0 && defendY > 0)){
		dbg("not defending???????", me);
		exit;		//not defending?
	}

	/* Collect attackers */
	initIterateGroup(attackGroup);
	_droid = iterateGroup(attackGroup);
	while(_droid != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_droid.x,_droid.y,defendX,defendY) > defendRadius)	//too far from defend location
		{
			if(distBetweenTwoPoints(_droid.orderx,_droid.ordery,defendX,defendY) > defendRadius)	//not already on its way to the defend location
			{
				orderDroidLoc(_droid, defendMoveType, defendX, defendY);
			}
		}
		_droid = iterateGroup(attackGroup);
	}
}

function bool defendLocationTimeout()
{
	if(tDefendTimeout < (gameTime / 10) ){
		return TRUE;
	}

	return FALSE;
}

/* Returns true if player in question is my ally or if it's me */
function bool friendlyPlayer(int _playerToCheck)
{
	if(allianceExistsBetween(_playerToCheck, me) or (_playerToCheck == me)){
		return TRUE;
	}

	return FALSE;
}

function bool insideBase(int _x, int _y)
{
	if(_x < minx){
		return FALSE;
	}

	if(_x > maxx){
		return FALSE;
	}

	if(_y < miny){
		return FALSE;
	}

	if(_y > maxy){
		return FALSE;
	}

	return TRUE;
}

function FEATURE closestOil(int _x, int _y, bool _bAvoidThreat)
{
	local FEATURE	_oil,_closestOil;
	local int		_bestDist,_newDist;
	
	_bestDist = 99999;
	_closestOil = NULLOBJECT;

	initGetFeature(oilRes,me,me);
	_oil = getFeatureB(me);
	while(_oil != NULLOBJECT)
	{
		_newDist = distBetweenTwoPoints(_x, _y, _oil.x, _oil.y);
		
		if(_newDist < _bestDist)	//this one is closer
		{
			if( !(_bAvoidThreat && threatInRange(me, _oil.x, _oil.y, OIL_THREAT_RANGE, FALSE)) )
			{
				_bestDist = _newDist;
				_closestOil = _oil;
			}
		}
		_oil = getFeatureB(me);
	}

	return _closestOil;
}
