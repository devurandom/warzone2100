{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f16\fnil\fcharset2\fprq2{\*\panose 00000000000000000000}Marlett;}
{\f17\fmodern\fcharset0\fprq1{\*\panose 020b0609040504020204}Lucida Console;}{\f18\fswiss\fcharset0\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f19\fscript\fcharset0\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}
{\f20\fswiss\fcharset0\fprq2{\*\panose 020b0806030902050204}Impact;}{\f21\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f22\froman\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}
{\f23\fmodern\fcharset128\fprq1{\*\panose 020b0609070205080204}MS Gothic;}{\f24\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}LinePrinter;}{\f25\froman\fcharset238\fprq2 Times New Roman CE;}{\f26\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f28\froman\fcharset161\fprq2 Times New Roman Greek;}{\f29\froman\fcharset162\fprq2 Times New Roman Tur;}{\f30\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f31\fswiss\fcharset238\fprq2 Arial CE;}{\f32\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f34\fswiss\fcharset161\fprq2 Arial Greek;}{\f35\fswiss\fcharset162\fprq2 Arial Tur;}{\f36\fswiss\fcharset186\fprq2 Arial Baltic;}{\f37\fmodern\fcharset238\fprq1 Courier New CE;}{\f38\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f40\fmodern\fcharset161\fprq1 Courier New Greek;}{\f41\fmodern\fcharset162\fprq1 Courier New Tur;}{\f42\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f115\fswiss\fcharset238\fprq2 Tahoma CE;}{\f116\fswiss\fcharset204\fprq2 Tahoma Cyr;}
{\f118\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f119\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f120\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f127\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f128\fmodern\fcharset204\fprq1 Lucida Console Cyr;}
{\f130\fmodern\fcharset161\fprq1 Lucida Console Greek;}{\f131\fmodern\fcharset162\fprq1 Lucida Console Tur;}{\f133\fswiss\fcharset238\fprq2 Arial Black CE;}{\f134\fswiss\fcharset204\fprq2 Arial Black Cyr;}
{\f136\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f137\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f138\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f139\fscript\fcharset238\fprq2 Comic Sans MS CE;}{\f140\fscript\fcharset204\fprq2 Comic Sans MS Cyr;}
{\f142\fscript\fcharset161\fprq2 Comic Sans MS Greek;}{\f143\fscript\fcharset162\fprq2 Comic Sans MS Tur;}{\f144\fscript\fcharset186\fprq2 Comic Sans MS Baltic;}{\f145\fswiss\fcharset238\fprq2 Impact CE;}{\f146\fswiss\fcharset204\fprq2 Impact Cyr;}
{\f148\fswiss\fcharset161\fprq2 Impact Greek;}{\f149\fswiss\fcharset162\fprq2 Impact Tur;}{\f150\fswiss\fcharset186\fprq2 Impact Baltic;}{\f151\fswiss\fcharset238\fprq2 Verdana CE;}{\f152\fswiss\fcharset204\fprq2 Verdana Cyr;}
{\f154\fswiss\fcharset161\fprq2 Verdana Greek;}{\f155\fswiss\fcharset162\fprq2 Verdana Tur;}{\f156\fswiss\fcharset186\fprq2 Verdana Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\lang2057\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid \sbasedon0 \snext15 Plain Text;}}
{\info{\title Comments}{\author Alex Lee}{\operator Alex Lee}{\creatim\yr1999\mo9\dy16\hr11\min27}{\revtim\yr1999\mo9\dy16\hr12\min19}{\version7}{\edmins37}{\nofpages28}{\nofwords7736}{\nofchars44098}{\*\company Pumpkin Studios}{\nofcharsws54155}
{\vern71}}\paperw11906\paperh16838 \widowctrl\ftnbj\aenddoc\formshade\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}
{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9
\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid {\b Warzone2100. Script language notes.
\par Pumpkin Studios. 1999
\par 
\par Note: making any modifications to Warzone 2100 will void any technical support open to you. We will not answer questions or help you in any way if you have modified Warzone 2100. Pumpkin Studios an
d Eidos will not take responsibility for any damage resulting from modifcation of Warzone 2100.
\par 
\par 
\par Specific skirmish notes:
\par }{Much of the file below doesn\rquote t apply to skirmish scripts!
\par Make your changes to player0.slo and vlo -> player7.slo and vlo.
\par This file may not be complete or contain out of date information.
\par }{\b 
\par 
\par 
\par Comments
\par 
\par }{There are two type of comment for the script language.  A multi-line comment is started by 
\par the characters /* and finishes with */.  A single line comment is started by //.
\par 
\par }{\b Declaring Variables
\par }{
\par A variable declaration is structured :
\par 
\par \tab <storage> <type> <name> [ , <name> , \'85 ] ;
\par 
\par <storage> is one of public or private.  public means that the variable can have a 
\par value assigned in the world editor.  private means the value is only used within the script 
\par and cannot be set in the editor.
\par 
\par <type> is the data type of the variable.  There are four default types of variable: int bool 
\par trigger event.  int is a numeric value.  bool stores only a true or false value.  
\par trigger stores a reference to a script trigger.  event stores a reference to a script event.  
\par There are also a number of extra user defined types specific to the game.
\par 
\par <name> is the identifier by which the variable is referred to.  If more than one variable of a 
\par type is required, additional names separated by commas can be added.
\par 
\par 
\par }{\b Declaring Triggers
\par }{
\par Triggers are used to schedule when an event should occur.  The format of a declaration is:
\par 
\par \tab trigger <name> ( <trigger type> );
\par 
\par <trigger type> can be any of:
\par 
\par \tab init\tab Run the event when the script starts.
\par \tab inactive\tab Do not run the event until a trigger is assigned to it.
\par \tab wait , <time>\tab Run the event after delay <time>.
\par \tab every , <time>\tab Run the event at every <time> interval.
\par \tab <bool exp>, <time>\tab Run the event if <bool exp> is true, checking every
\par \tab \tab <time> interval.
\par 
\par <bool exp> is a boolean expression (described below) which may include game function 
\par calls and script variables.
\par 
\par }{\b Declaring Events
\par }{
\par Events contain the actual code to execute when a trigger is activated.  They are declared :
\par 
\par \tab event <name> ( <trigger> ) \{ <code> \}
\par 
\par <name> is the identifier for the event.
\par 
\par <trigger> is either the identifier of a previously declared trigger, or a new <trigger type> 
\par declaration.
\par 
\par <code> is the actual script code to execute when the event is activated.
\par 
\par }{\b Number Expressions
\par }{
\par Numeric expressions are made up of int variables, numeric constants and functions that 
\par return int values, e.g.:
\par 
\par \tab power * 32 - basePower
\par \tab numDroids(player) + 5
\par 
\par The possible operators are :
\par 
\par \tab +  -  *  /
\par 
\par There are also a number of operators that compare numeric expressions to give a boolean 
\par expression :
\par 
\par \tab <  >\tab Less than / Greater than
\par \tab <= >=\tab Less or Equal / Greater or Equal
\par \tab == !=\tab Equal / Not Equal
\par 
\par 
\par }{\b Boolean Expressions
\par }{
\par Boolean expressions are made up of bool variables, the boolean constants true and 
\par false and game functions that return a boolean value e.g.
\par 
\par \tab not droidSeen and attackDroid
\par 
\par The possible operators are :
\par 
\par \tab and or not == !=
\par 
\par The operators == and != can also be used with user defined type variables.
\par 
\par }{\b Assignment
\par }{
\par The value of a variable or an expression can be assigned to another using the = character, 
\par e.g.:
\par 
\par \tab currentDroid = foundDroid;
\par \tab index = base + found * 4;
\par 
\par }{\b if statements
\par }{
\par if statements are used to control which bits of code are executed.  The simplest form is :
\par 
\par \tab if ( <bool exp> )
\par \tab \{
\par \tab \tab <code>
\par \tab \}
\par 
\par In this form if <bool exp> evaluates to true then the script code <code> is executed, 
\par otherwise the code is ignored.
\par 
\par \tab if ( <bool exp> )
\par \tab \{
\par \tab \tab <code>
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab <code>
\par \}
\par 
\par \tab if ( <bool exp> )
\par \tab \{
\par \tab \tab <code>
\par \tab \}
\par \tab else if ( <bool exp> )
\par \tab \{
\par \tab \tab <code>
\par \}
\par \tab else
\par \tab \{
\par \tab \tab <code>
\par \}
\par 
\par 
\par }{\b while statements
\par }{
\par 
\par \tab while ( <bool exp> )
\par \tab \{
\par \tab \tab <code>
\par \tab \}
\par 
\par 
\par 
\par }{\b SCRIPT FUNCTION TYPES
\par }{
\par With a complex object it i
s possible to access information specific to the instance of this object. For example a DROID is a complex object - its x,y,z can be queried whereas a DROIDID (a simple object) is just a placeholder for the numeric value of the ID.
\par 
\par INTMESSAGE - (simple) Name of a message as defined in Messages.txt
\par 
\par BASEOBJ\tab - (complex) any of a DROID,FEATURE or STRUCTURE
\par \tab You have access to :
\par  \tab baseobj.x
\par \tab baseobj.y
\par \tab baseobj.z
\par \tab baseobj.id\tab \tab \tab - unique id number
\par \tab baseobj.player\tab \tab - player id
\par \tab baseobj.type\tab \tab - one of OBJ_DROID, OBJ_STRUCTURE, OBJ_FEATURE
\par  \tab baseobj.health\tab \tab - %age number of body points
\par \tab baseobj.clusterID\tab - the cluster the object is a member of
\par 
\par NOTE: the functions objToDroid, objToStructure and objToFeature exist to convert a BASEOBJ
\par \tab   to a droid, structure or feature if the base obj is of the right type.
\par 
\par DROID\tab - (complex) defined by the ID got from the world editor
\par \tab You have access to :
\par \tab \tab all BASEOBJ variables
\par \tab \tab droid.order    -  current order of the droid
\par \tab \tab droid.body\tab    - the BODY of the droid
\par \tab \tab droid.propulsion - the PROPULSION of the droid
\par \tab \tab droid.weapon   - the WEAPON of the droid
\par 
\par DROIDID - (simple) literally just an ID of a droid
\par 
\par FEATURE - (complex) defined by the ID got from the world editor
\par \tab You have access to :
\par \tab \tab all BASEOBJ variables
\par 
\par FEATURESTAT - (simple) name of a feature as defined in features.txt
\par 
\par TEMPLATE - (simple) name of a template as defined in templ.bjo - loaded in as part of the save game
\par 
\par STRUCTURE - (complex) defined by the ID got from the world editor
\par \tab You have access to :
\par \tab \tab all BASEOBJ variables
\par \tab \tab structure.stat\tab - the STRUCTURESTAT of the structure
\par 
\par STRUCTUREID - (simple) literally just an ID of a struct
\par STRUCTURESTAT - (simple) name of a structure as defined in structures.txt
\par 
\par BODY - (simple) name of a body as defined in body.txt 
\par PROPULSION - (simple) name of a propulsion as defined in propulsion.txt 
\par ECM - (simple) name of a ECM as defined in ecm.txt
\par SENSOR - (simple) name of a sensor as defined in sensor.txt
\par CONSTRUCT - (simple) name of a construct as defined in construct.txt
\par WEAPON - (simple) name of a weapon as defined in weapons.txt
\par REPAIR - (simple) name of a repair type as defined in Repair.txt
\par BRAIN - (simple) name of a brain type as defined in Brain.txt
\par 
\par SOUND - (simple) ID of sound used in playSound()
\par 
\par LEVEL - ID of a level as defined in GameDesc.lev
\par 
\par GROUP - (complex) a group of droids
\par \tab You have access to :
\par \tab group.x\tab \tab \tab - average x coord
\par \tab group.y\tab \tab \tab - average y coord
\par \tab group.members\tab - number of units in the group
\par \tab group.health\tab - average %age health of the units
\par 
\par NOTE: these are calculated the first time you access them for a group
\par and then cached for repeated access for this group.  It is therefore
\par much quicker if you do all actions on one group before accessing another
\par 
\par RESEARCHSTAT - (simple) name of a research topic as defined in research.txt (and the database)
\par 
\par }{\b SCRIPT FUNCTIONS
\par }{
\par setSnow(BOOL)
\par This function switchs snow on or off. TRUE will turn snow on, FALSE will turn snow off. If rain is on when snow is started the rain 
\par will be turned off.
\par  
\par setRain(BOOL)
\par This function switchs rain on or off. TRUE will turn rain on, FALSE will turn rain off. If snow is on when rain is started the snow 
\par will be turned off.
\par 
\par setBackgroundFog(BOOL)
\par This function switchs background fog on or off. This sets the backdrop to the current fogcolour and fogs the edge of the visible world.
\par TRUE will turn background fog on, FALSE will turn background fog off.
\par 
\par setDepthFog(BOOL)
\par This function switchs depth fog on or off. This sets the sets fog ramping up from zero in the middle of the view to full fog at the edge
\par of the visible world. TRUE will turn depth fog on, FALSE will turn depth fog off.
\par 
\par setFogColour(RED, GREEN, BLUE)
\par This function sets the fog colour, to be used when fog is enabled. This colour is also used in the background clear when fog is enabled.
\par The colour is specified as RED, GREEN and BLUE components each in the range 0 to 255. This yields a 24 bit colour value.
\par Colour values outside the range 0 to 255 will have an indeterminate effect.
\par WARNING setting the fog colour to BLACK(0, 0, 0) does not turn fog off and should be avoided.
\par Arizona: NEW\tab 204, 149, 70\tab Nick approved 24/09/98\tab \tab (Old 176, 143, 95\tab B08F5F)
\par Urban:\tab \tab 201, 146, 15\tab C9920F
\par Rockies:\tab 182, 225, 236\tab B6E1EC
\par 
\par enableComponent(COMPONENT, PLAYER)
\par This function makes a component found to a player - so that they can research a topic that requires the component
\par COMPONENT is any type of Body, Propulsion, Weapon, ECM, Sensor, Construct etc
\par PLAYER is the id of the player who gets the component
\par 
\par makeComponentAvailable(COMPONENT, PLAYER)
\par This function makes a component available to a player - so that they can build Units using this component
\par COMPONENT is any type of Body, Propulsion, Weapon, ECM, Sensor, Construct etc
\par PLAYER is the id of the player who gets the component
\par 
\par enableStructure(STRUCTURESTAT, PLAYER)
\par This function makes a structure available to a player - so that they can research a topic that requires the structure or build the structure
\par STRUCTURESTAT is defined by the name from Access
\par PLAYER is the id of the player who gets the structure
\par 
\par enableResearch(RESEARCHSTAT, PLAYER)
\par This function makes a research topic available to a player regardless of its pre-requisites
\par RESEARCHSTAT is defined by the name from Access
\par PLAYER is the id of the player who gets the research
\par 
\par completeResearch(RESEARCHSTAT, PLAYER)
\par This function acts as if the research was performed by the player giving them the results
\par RESEARCHSTAT is defined by the name from Access
\par PLAYER is the id of the player who gets the research
\par 
\par BOOL objectInRange(PLAYER, X,Y, RANGE)
\par BOOL droidInRange(PLAYER, X,Y, RANGE)
\par BOOL structInRange(PLAYER, X,Y, RANGE)
\par 
\par These functions check for when an object/droid/structure belonging to a player is within range of a position
\par PLAYER is the id of the player whose unit is checked for in range
\par X,Y is the position to check from in world coords
\par RANGE is in world coords - 128 units = 1 tile
\par 
\par BOOL objectInArea(PLAYER, X1,Y1, X2,Y2)
\par BOOL droidInArea(PLAYER, X1,Y1, X2,Y2)
\par BOOL structInArea(PLAYER, X1,Y1, X2,Y2)
\par 
\par These functions check for when an object/droid/structure belonging to a player is in a square area
\par PLAYER is the id of the player whose droid is checked for in area
\par X1,Y1,  X2,Y2 is the area to check in world coords
\par X1,Y1 should be smaller than X2,Y2
\par 
\par BOOL droidHasSeen(OBJECT, PLAYER)
\par This functions checks for when a player has seen a given object - either by unit or structure
\par OBJECT is any type of DROID, FEATURE, STRUCTURE
\par PLAYER is the id of the player to check for having seen
\par 
\par addDroid(TEMPLATE, X, Y, PLAYER)
\par This function adds a unit for the player based on the template passed in. 
\par The unit is placed at x,y
\par TEMPLATE is a valid template (doesn't have to belong to the player!)
\par X, Y are in world coords
\par PLAYER is the id of the player whose the unit belongs to
\par 
\par buildDroid(TEMPLATE, STRUCTURE, PLAYER, QUANTITY)
\par This function sets a factory defined by STRUCTURE to build units based on the TEMPLATE for the PLAYER. 
\par TEMPLATE is a valid template (doesn't have to belong to the player!)
\par STRUCTURE is a structure defined by ID and MUST BE A FACTORY
\par PLAYER is the id of the player whose the unit belongs to
\par QUANTITY is the number of units that will be built
\par 
\par BOOL buildingDestroyed(STRUCTUREID, PLAYER)
\par This function checks that a structure (given by the id) no longer exists for the player
\par STRUCTUREID is the id of the structure - NB this is different to an object of type STRUCTURE
\par PLAYER is the id of the player whose list is checked for the building
\par 
\par BOOL structureIdle(STRUCTURE)
\par This function checks whether the structure is doing anything. Returns TRUE if idle
\par STRUCTURE is a valid structure defined by ID
\par 
\par BOOL structureBeingBuilt(STRUCTURESTAT, PLAYER)
\par This function checks that a structure of type STRUCTURESTAT is currently being built for the specified PLAYER
\par STRUCTURESTAT is defined by the name from Access
\par PLAYER is the id of the player who gets the structure
\par 
\par BOOL structureBuilt(STRUCTURESTAT, PLAYER)
\par This function checks that a structure of type STRUCTURESTAT is currently built for the specified PLAYER
\par STRUCTURESTAT is defined by the name from Access
\par PLAYER is the id of the player who gets the structure
\par 
\par addReticuleButton(BUTTONID)
\par This function adds a reticule button to the interface
\par BUTTONID is the id of a button - see ScriptConstants.txt
\par 
\par removeReticuleButton(BUTTONID)
\par This function removes a reticule button from the interface
\par BUTTONID is the id of a button - see ScriptConstants.txt 
\par 
\par addMessage(INTMESSAGE, MESSAGETYPE, PLAYER, PLAY_IMMEDIATE)
\par This adds a message to the interface for the PLAYER
\par INTMESSAGE is a variable defined in the values file 
\par MESSAGETYPE is a predefined type - see ScriptConstants.txt
\par PLAYER is the player who gets the message
\par PLAY_IMMEDIATE is a bool for whether to bring the Intelligence Screen up with the message immediately or just store it
\par 
\par removeMessage(INTMESSAGE, MESSAGETYPE, PLAYER)
\par This removes a message from the interface for the PLAYER
\par INTMESSAGE is a variable defined in the values file 
\par MESSAGETYPE is a predefined type - see ScriptConstants.txt
\par PLAYER is the player who loses the message
\par 
\par !!!!!!!!!!!NO LONGER AVAILABLE!!!!!!!!!!
\par //addTutorialMessage(INTMESSAGE, PLAYER)
\par //This adds a tutorial message to the display for the PLAYER - its is played immediately //without the intelligence screen coming up. The message is not stored and therefore cannot //be re-displayed. It can be added over and over again though!
\par //INTMESSAGE is a variable defined in the values file 
\par //PLAYER is the player who gets the message
\par 
\par BOOL selectDroidByID(DROIDID, PLAYER)
\par This selects a unit defined by the ID since we can't guarantee the name! Only the list of units belonging to PLAYER will be checked. This returns TRUE if the unit could be found - it will be worth checking it exists!
\par DROIDID is a valid unit defined by ID
\par 
\par setAssemblyPoint(X, Y, STRUCTURE)
\par This sets the location of where new units assemble at for a specific factory
\par X, Y are the x and y in world coordinates
\par STRUCTURE is a valid structure defined by ID
\par 
\par FEATURE addFeature( FEATURESTAT, X, Y )
\par Builds a feature at position (x,y).
\par FEATURESTAT is the name of a feature stat defined in features.txt.
\par The feature identifier is returned - this can be used in e.g. destroyFeature.
\par 
\par destroyFeature(FEATURE)
\par This removes the feature from the world
\par FEATURE is a feature defined by ID
\par 
\par centreView(OBJECT)
\par This function centres the view on the object supplied
\par OBJECT is any type of DROID, FEATURE, STRUCTURE
\par 
\par STRUCTURE addStructure( STRUCTURESTAT, PLAYER, X, Y )
\par Builds a structure belonging to PLAYER centred at (X, Y).
\par The structure must be previously enabled via enableStructure().
\par The structure identifier is returned - this can be used in e.g. destroyStructure.
\par 
\par destroyStructure(STRUCTURE)
\par This removes the structure from the world
\par STRUCTURE is a structure defined by ID
\par 
\par STRUCTURE getStructure(STRUCTURESTAT, PLAYER)
\par This function returns the first STRUCTURE based on the stat for the player it can find.
\par To use it create a STRUCTURE variable and assign it to the result of the function call.
\par For example:
\par 
\par STRUCTURE \tab \tab \tab myNewStructure;
\par STRUCTURESTAT \tab \tab Factory;
\par 
\par myNewStructure = getStructure(Factory, 0);
\par 
\par This will look through the player 0 list of structures to fin
d a Factory and return a variable of type STRUCTURE. You will then be able to access the x, y, and z. If a structure cannot be found than NULL is returned . It will be worth checking that the STRUCTURE does not equal NULL before using it. For example:

\par if (myNewStructure == NULLOBJECT)
\par \{
\par \tab do something
\par \}
\par 
\par 
\par initEnumStruct(STRUCTURESTAT,player,player2)
\par STRUCTURE enumStruct()
\par Enumerate through visible structures of given type, enum struct returns NULLOBJECT when no more exist.
\par player  = player who is looking (eg selectedPlayer)
\par player2 = player whose structures are to be enumerated.
\par 
\par 
\par TEMPLATE getTemplate(COMPONENT, PLAYER)
\par This function returns the first TEMPLATE based on the stat for the player it can find. It can be any type of component. To use it create a TEMPLATE variable and assign it to the result of the function call. For example:
\par 
\par TEMPLATE\tab \tab \tab myNewTemplate;
\par WEAPON\tab \tab \tab Rocket;
\par 
\par myNewTemplate = getStructure(Rocket, 0);
\par 
\par This will look through the player 0 list of template to find one whi
ch contains a rocket and then return a variable of type TEMPLATE. You will then be able to access its attributes. If a template cannot be found than NULL is returned . It will be worth checking that the TEMPLATE does not equal NULL before using it. For ex
ample:
\par 
\par if (myNewTemplate == NULLTEMPLATE)
\par \{
\par \tab do something
\par \}
\par \tab 
\par setScrollParams(minX, minY, maxX, maxY)
\par This literally sets the scroll settings for the current map - be careful not to set the maxX/maxY greater than that possible for the map!
\par minX, minY, maxX, maxY are all numbers. These are in TILE COORDINATES!!!!!!
\par 
\par setScrollMinX(minX)
\par This just sets the one variable. These are in TILE COORDINATES!!!!!!
\par minX is a number
\par 
\par setScrollMinY(minY)
\par This just sets the one variable. These are in TILE COORDINATES!!!!!!
\par minY is a number
\par 
\par setScrollMaxX(maxX)
\par This just sets the one variable. These are in TILE COORDINATES!!!!!!
\par maxX is a number
\par 
\par setScrollMaxY(maxY)
\par This just sets the one variable. These are in TILE COORDINATES!!!!!!
\par maxY is a number
\par 
\par setDefaultSensor(SENSOR, PLAYER)
\par This sets which sensor will be used as the default when designing units in game for the specified player. The SENSOR must be a valid DEFAULT sensor.
\par 
\par setDefaultECM(ECM, PLAYER)
\par Like the above functionm, this sets which ECM will be used as the default when designing units. Again the ECM must be a valid DEFAULT ECM.
\par 
\par setStructureLimits(STRUCTURESTAT, LIMIT, PLAYER)
\par This sets a limit for a specific structure on how many can be built on a map. 
\par STRUCTURESTAT is defined by the name from Access
\par LIMIT is a number between 0 and 255
\par PLAYER is the id of the player 
\par 
\par setAllStructureLimits(LIMIT, PLAYER)
\par This sets a limit for all structures on how many can be built on a map. 
\par LIMIT is a number between 0 and 255
\par PLAYER is the id of the player 
\par 
\par playSound( SOUND, PLAYER)
\par Plays a '2D' sound ie speech and is audible for the player identified
\par SOUND is a defined type.
\par PLAYER is the id of the player 
\par 
\par playSoundPos( SOUND, PLAYER, x, y, z)
\par Plays a '2D' sound ie speech and is audible for the player identified
\par Position of sound is saved so camera can move to object playing sound if required.
\par SOUND is a defined type.
\par PLAYER is the id of the player
\par x, y, z is the position of the object in game units.
\par 
\par addConsoleText( TEXTSTRING, PLAYER)
\par Adds console text to the top of the screen (centre justified) for the player concerned
\par TEXTSTRING is a string ID obtained from strings.txt
\par PLAYER is the id of the player 
\par 
\par turnPowerOn()
\par Literally makes the power calculations be used
\par 
\par turnPowerOff()
\par Literally stops the power calculations being used
\par 
\par setPowerlevel(POWER, PLAYER)
\par sets the power level for a player - this overrides any current setting there is
\par POWER is the value to set the player's power to
\par PLAYER is the id of the player 
\par 
\par addPower(POWER, PLAYER)
\par adds the POWER amount to the PLAYER's current level
\par POWER is the value to add to the player's power
\par PLAYER is the id of the player 
\par 
\par setLandingZone(x1, y1, x2, y2)
\par sets the landing zone for the map. The coords are in tile units and must all be less than 255
\par 
\par setLimboLanding(x1, y1, x2, y2)
\par sets the landing zone for the Limbo Units.The coords are in tile units and must all be less than 255
\par The units from the Limbo list are then placed at this location - so call in CALL_GAME_INIT of the mission you want them to appear in
\par 
\par initAllNoGoAreas()
\par initialises all the no go areas to 0. Should be called when a new map is loaded
\par 
\par setNoGoArea(x1, y1, x2, y2, areaNum)
\par defines an area that cannot be built on - used for enemy landing zones. 
\par areaNum is a number between 0 and 7. If 0, then this function is the same as calling setlandingZone
\par 
\par setTransporterExit( PLAYER, exitTileX, exitTileY )
\par setup transporter exit point on map for PLAYER
\par 
\par flyTransporterIn( PLAYER, entryTileX, entryTileY, BOOL bTrackTransporter )
\par flys PLAYER's transporter in from entry point on map; set bTrackTransporter true to
\par track it onto the map.
\par 
\par tutorialEnd()
\par A bit of a hack to notify the game when the last of the tutorial events has been run 
\par so that the console messages can be turned back on to how they will appear for 
\par the rest of the game
\par 
\par gameOver(BOOL)
\par function to call for ending the game
\par BOOL - true or false depending on whether the player has won or not
\par 
\par anyDroidsLeft(PLAYER)
\par checks the specified player for any units - returns TRUE if some exist, FALSE if 
\par they have all been destroyed
\par 
\par anyStructButWallsLeft(PLAYER)
\par checks the specified player for any structures except walls - returns TRUE if some 
\par exist, FALSE if they have all been destroyed
\par 
\par anyFactoriesLeft(PLAYER)
\par returns true if player has a factory/cyborg factory/ vtol factory
\par 
\par setRetreatPoint(PLAYER, x,y)
\par sets the position for a players units to retreat to
\par 
\par setRetreatForce(INT player, INT level)
\par Sets the percentage of the current force below which units for a side will retreat
\par 
\par setRetreatLeadership(INT player, INT level)
\par Sets the leadership level (chance to run away) for a player (1-100)
\par 
\par startMission(MISSION_TYPE, LEVEL)
\par Starts a mission for the currently selected player - NB Transporters must be filled if
\par you want units to appear on the Mission map
\par MISSION_TYPE is a predefined type - see ScriptConstants.txt
\par LEVEL is the name of the level to load as defined in GameDesc.lev
\par 
\par endMission(BOOL)
\par Ends the current mission the selected player is on - returns all Units that have been 
\par loaded onto the Transporter. False if player lost, true if player won????
\par 
\par 
\par !!!! DISABLED, no group wins at this time !!!!!!
\par !!BOOL allianceState()
\par !!returns true if group wins are allowed in the particular multiplayer game.
\par !!returns false otherwise.
\par 
\par BOOL allianceExists()
\par returns true if two or more players are in alliance. returns false otherwise.
\par 
\par BOOL dominatingAlliance()
\par returns true if there is a single dominating alliance, using all multi-players.
\par 
\par BOOL playerInAlliance()
\par returns true if player is in an alliance
\par 
\par BOOL myResponsibility(PLAYER);
\par returns true if this machine is responsible for 'player' in multiplayer games.
\par 
\par STRUCTURE structureBuiltInRange(STRUCTURESTAT, X, Y, RANGE, PLAYER)
\par Checks to see if a Structure has been built within a specified range of x, y. The first structure
\par to be found within this range will be returned. Check the result of the function for being
\par NULLOBJECT before using!
\par STRUCTURE is a return value (structure defined by ID)
\par STRUCTURESTAT is defined by the name from Access
\par X, Y, RANGE are all in world coords
\par PLAYER is the id of the player whose structure list is searched
\par 
\par 
\par groupAddDroid(GROUP, DROID)
\par Add a unit to a group
\par 
\par groupAddArea(GROUP, PLAYER, X1,Y1, X2,Y2)
\par Add all the units inside the rectangle X1,Y1, X2,Y2.
\par Only units belonging to player PLAYER are added.
\par 
\par groupAddAreaNoGroup(GROUP, PLAYER, X1,Y1, X2,Y2)
\par as above but doesnt add units that are already grouped.
\par 
\par groupAddGroup(group1, group2)
\par Add all the units in group2 to group1.
\par All the units are removed from group2.
\par 
\par 
\par orderDroid(DROID, order)
\par Give a unit an order currently one of:
\par \tab DORDER_STOP\tab \tab \tab - stop current order
\par \tab DORDER_RETREAT\tab \tab - retreat
\par \tab DORDER_DESTRUCT\tab \tab - self destruct
\par \tab DORDER_RTR\tab \tab \tab - return to repair
\par \tab DORDER_RTB\tab \tab \tab - return to base
\par \tab DORDER_RUN\tab \tab \tab - run away for a bit (moral failure)
\par 
\par orderDroidLoc(DROID, order, x,y)
\par Give a unit an order with a location :
\par \tab DORDER_MOVE\tab \tab \tab - move to location
\par 
\par orderDroidObj(DROID, order, BASEOBJ)
\par Give a unit an order with an object :
\par \tab DORDER_ATTACK\tab \tab - attack the object
\par \tab DORDER_HELPBUILD\tab - help construct the object
\par \tab DORDER_DEMOLISH\tab \tab - demolish structure
\par \tab DORDER_REPAIR\tab \tab - repair structure
\par \tab DORDER_OBSERVE\tab \tab - (sensor units) keep a target in sensor range
\par \tab DORDER_EMBARK\tab \tab - get onto a transporter
\par \tab DORDER_FIRESUPPORT\tab - follow this sensor unit and attack anything it DORDER_OBSERVE's
\par 
\par orderDroidStatsLoc(DROID, INT order, STRUCTURESTAT stats, INT x, INT y)
\par Give a unit an order with stats and a location :
\par \tab DORDER_BUILD\tab \tab - build a structure at the location
\par 
\par orderGroup(GROUP, order)
\par Give all the units in the group an order
\par 
\par orderGroupLoc(GROUP, order, x,y)
\par Give all the units in the group an order with a location
\par 
\par orderGroupObj(GROUP, order, BASEOBJ)
\par Give all the units in the group an order with an object
\par 
\par 
\par 
\par DROID objToDroid(BASEOBJ)
\par Convert a BASEOBJ to DROID when BASEOBJ.type == OBJ_DROID. Returns NULLOBJECT otherwise
\par 
\par STRUCTURE objToStructure(BASEOBJ)
\par Convert a BASEOBJ to STRUCTURE when BASEOBJ.type == OBJ_STRUCTURE. Returns NULLOBJECT otherwise
\par 
\par FEATURE objToFeature(BASEOBJ)
\par Convert a BASEOBJ to FEATURE when BASEOBJ.type == OBJ_FEATURE. Returns NULLOBJECT otherwise
\par 
\par 
\par INT random(range)
\par Return a random number between 0 and range - 1.
\par 
\par 
\par flashOn(INT buttonID)
\par turn on flashing for a button (id's in scriptConstants.txt)
\par  ... now works for all buttons not just reticule buttons
\par 
\par flashOff(INT buttonID)
\par turn off flashing for a button
\par 
\par createAlliance(INT player1, INT player2)
\par Create an alliance between two players
\par 
\par breakAlliance(INT player1, INT player2)
\par Breake an alliance between two players
\par 
\par setRadarZoom(INT level)
\par level is the zoom level between 0 .. 2 on the PC and 0 .. 1 on PSX.
\par 0 is the most zoomed out, 2 the most zoomed in.
\par 2 is mapped to 1 if the script is run on the PSX
\par 
\par centreViewPos(INT x, INT y)
\par center the view on the world coordinates x,y.
\par 
\par setGroupRetreatForce(GROUP group, INT level)
\par Sets the percentage of the current force below which units for a side will retreat
\par 
\par setGroupRetreatLeadership(GROUP group, INT level)
\par Sets the leadership level (chance to run away) for a player (1-100)
\par 
\par setGroupRetreatPoint(GROUP group, INT x, INT y)
\par Set the retreat position for a group
\par 
\par setDroidSecondary(DROID droid, INT secondaryOrder, INT secondaryState)
\par Set the state of a secondary order for a droid (values in scriptConstants.txt)
\par 
\par setGroupSecondary(GROUP group, INT secondaryOrder, INT secondaryState)
\par Set the state of a secondary order for a group (values in scriptConstants.txt)
\par 
\par setMissionTime(INT time)
\par used to specify how long an OffWorld mission will last for - used in conjunction with the
\par callback CALL_MISSION_TIME so that end conditions can be displayed if the player has not
\par managed to finish the mission
\par If time < 0, there is no limit. time is in 10th of a second
\par 
\par INT missionTimeRemaining()
\par Returns how long left for the current mission. If the mission time has not been set it will return 0.
\par The value returned is in 10ths of a second
\par 
\par 
\par setReinforcementTime(INT time)
\par this defines how long it will take for reinforcements to arrive for an OffWorld mission
\par If time < 0, there can be no reinforcements. Time is in 10th of a second.
\par Set time to LZ_COMPROMISED_TIME to display '--:--' to indicate the Transporter is unable to land
\par 
\par INT idleGroup(GROUP group)
\par returns number of units in group not doing anything.
\par 
\par BOOL groupMember(GROUP group, DROID droid)
\par return whether a unit is a member of a group.
\par 
\par initIterateGroup(GROUP group)
\par Prepare a group to iterate through the units in it.
\par 
\par DROID iterateGroup(GROUP group)
\par Get the next unit from the group.  Must be called after an initial initGroupIterate.
\par To reset a group back to the start call initGroupIterate.
\par 
\par droidLeaveGroup(DROID droid)
\par Make a unit leave the group it is a member of (if any).
\par 
\par initGetFeature(STRUCTURESTAT, PLAYER,BUCKET)
\par getFeature(BUCKET)
\par enumerate features of a single feature type.
\par PLAYER is the player to use, Only features visible to that player are returned.
\par BUCKET is an int of range 0-MAX_PLAYERS(8), so up to 8 feature enumerations can be going on at any time! (wow)
\par getFeature returns NULLOBJECT when no more features are visible.
\par 
\par BOOL structButNoWallsInArea(PLAYER, X1,Y1, X2,Y2)
\par See if there are any player structures excluding walls in an area.
\par 
\par INT numObjectsInArea(PLAYER, X1,Y1, X2,Y2)
\par Return the number of player objects in an area.
\par 
\par INT numDroidsInArea(PLAYER, X1,Y1, X2,Y2)
\par Return the number of player units in an area.
\par 
\par INT numStructsInArea(PLAYER, X1,Y1, X2,Y2)
\par Return the number of player structures in an area.
\par 
\par INT numStructsButNotWallsInArea(PLAYER, X1,Y1, X2,Y2)
\par Return the number of player structures excluding walls in an area.
\par 
\par randomiseSeed()
\par Generate a new random seed for the random number generator.
\par 
\par INT numStructsByTypeInArea(PLAYER, TYPE, X1,Y1, X2,Y2)
\par Return the number of structures of a certain type in an area.
\par 
\par flushConsoleMessages()
\par Clear all the console messages
\par 
\par BOOL pickStructLocation(STRUCTURESTAT,ref x, ref y, player);
\par returns true if structure of type strucutrestat can be built at x,y.
\par  If a structure can be built nearby then returns true and modifies x and y
\par to the coords of acceptable location. Player trying to build - uses this for the visibility
\par 
\par INT playerPower(INT player)
\par returns aspower[player].currentPower (players current power)
\par 
\par BOOL seenStructInArea(INT player,INT enemy,BOOL walls,INT x1,INT y1,INT x2,INT y2)
\par returns true if player has seen a structure belonging to enemy in area specified. Call with
\par walls = true/false to include/exclude walls in the search.
\par (note similar to StructInArea)
\par 
\par INT\tab distBetweenTwoPoints(INT x1, INT y1, INT x2, INT y2)
\par Returns the distance between the two points given.
\par 
\par BOOL losTwoObjects(BASEOBJ source, BASEOBJ target, BOOL wallsMatter)
\par Decides whether object source can see object target and you can specify whether
\par walls matter or not. Note that whilst target can be anything, source needs to be
\par something that can actually see - ie - have a sensor like a unit or structure.
\par Returns TRUE or FALSE
\par 
\par void killStructsInArea(INT player, INT buildingRef (like REF_WALL etc), INT x1, INT y1, 
\par \tab INT x2, INT y2, BOOL bSeeEffect, BOOL bTakeFeatures)
\par Blows up all the buildings of the specified reference within the specified area. 
\par If bSeeEffect is set, then you'll see it blow up (provided you can see the building
\par in question of course).
\par If bTakeFeatures is et, then it will also kill features of type BUILDING.
\par Returns 'nowt.
\par 
\par INT getThreatInArea(INT playerLooking, INT playerTarget, INT x1, INT y1, INT x2, INT y2, INT ldThreat, INT mdThreat, INT hdThreat)
\par Returns the threat value of all units of a specified player within a certain area for a specified player. 
\par The user can 'calibrate' this threat value by specifying the relative weights attached to the threats of
\par small,medium and heavy units respectively as the last three parameters to this function. The final boolean
\par parameter allows the user to say whether they care about whether or not the units in question are
\par presently visible.. TRUE means they only add to the threat if PlayerLooking can see this unit (owned by
\par playerTarget), FALSE means they add to the threat if even they can't see that unit.
\par 
\par BOOL getNearestGateway(INT x, INT y, ref rX, ref rY)
\par Puts the coordinates of the nearest gateway into reference variables rX and rY. It might not though
\par if there are no gateways on the present map. So make sure you look at the return value. If it's FALSE, 
\par then the values in rX and rY will be meaningless - unchanged actually, assuming the scripting works 
\par this way. Otherwise, they'll be the coordinates of the midpoint of the nearest gateway.
\par 
\par VOID setWaterTile(INT tileNum)
\par Sets the tile to use for underwater. Count from the top of the tileset pcx - presently 17 for arizona.
\par 
\par initIterateCluster(INT clusterID)
\par get ready to iterate a cluster
\par 
\par BASEOBJ iterateCluster()
\par return the next object in the cluster or NULLOBJ if none left
\par 
\par cmdDroidAddDroid(DROID commander, DROID droid)
\par adds the unit droid to the command group of the command unit commander
\par 
\par BOOL testStructureModule(INT playeNumber, ST_STRUCTURE structureToTest, INT ref)
\par Returns true if the structure in question has a module attached - presently the ref id is unused but 
\par could be later on. At the moment it returns true if the structure has _any_ number of modules attached.
\par If the structure pointer that's sent in is NULL (ie - no structure is specified), then it'll return 
\par TRUE is _any_ of the player's structures possess _any_ module. In all other cases, it'll return FALSE.
\par 
\par BOOL addTemplate(TEMPLATE, INT player)
\par given a template, gives the player the template so that build droid can be used. At least one
\par player must have the template.
\par 
\par VOID vanishUnit(DROID droid)
\par Will remove 'droid' from the world without any graphical hoo ha.
\par 
\par VOID forceDamageObject(BASEOBJ obj, INT damage)
\par Sets 'obj' to be 'damage' percent damaged. Obj must be a feature,droid or structure and damage 
\par must be <= 100.
\par 
\par 
\par BOOL getGameStatus(INT StatusRequired)
\par Gets the status of some of the game TRUE/FALSE variables. Can be used to find if the reticule is up or the
\par battle map is open,  that sort of thing.
\par 
\par e.g.    getGameStatus(STATUS_ReticuleIsOpen);\tab will return TRUE if the reticule is open (on screen) or FALSE if the reticule is not (disabled)
\par or
\par \tab     getGameStatus(STATUS_BattleMapViewEnabled);\tab will return TRUE if we are in the battle map mode
\par or
\par \tab     getGameStatus(STATUS_DeliveryResposInProgress);\tab will return TRUE if we are repositioning the delivery point
\par 
\par these are currently the only two options implemented ... for other game modes (like design screen or intelligence map modes)
\par  use the externed variable intMode
\par 
\par INT getPlayerColour(INT player)
\par returns the colour of the player
\par 
\par VOID setPlayerColour(INT colour, INT player)
\par sets the colour to use for the player specified - colour must be 0 to (MAX_PLAYERS-1)
\par 
\par DROID takeOverSingleDroid(DROID droidToTakeOver, INT playerToGain)
\par this replaces the existing droid (droidToTakeOver) by a new one for the playerToGain. 
\par The new droid is passed back to the script 
\par ****Test for NULLOBJECT BEFORE calling this function****
\par 
\par INT takeOverDroidsInArea(INT fromPlayer, INT toPlayer, INT x1, INT y1, INT x2, INT y2)
\par x1,y1,x2,y2 are in world units
\par checks for units belonging to fromPlayer and if they are in the area they are 'given' to the toPlayer
\par 
\par INT takeOverDroidsInAreaExp(INT fromPlayer, INT toPlayer, INT x1, INT y1, INT x2, INT y2, INT level, INT max)
\par x1,y1,x2,y2 are in world units
\par checks for units belonging to fromPlayer and if they are in the area they are 'given' to the toPlayer
\par if their experience level is less than or equal to level
\par max specifies the maximum number of units to take over
\par 
\par STRUCTURE takeOverSingleStructure(STRUCTURE structToTakeOver, INT playerToGain)
\par this replaces the existing structure (structToTakeOver) by a new one for the playerToGain. 
\par The new structure is passed back to the script 
\par ****Test for NULLOBJECT BEFORE calling this function****
\par 
\par INT takeOverStructsInArea(INT fromPlayer, INT toPlayer, INT x1, INT y1, INT x2, INT y2)
\par x1,y1,x2,y2 are in world units
\par checks for structures belonging to fromPlayer and if they are in the area they are 'given' to the toPlayer
\par This will NOT WORK for the selectedPlayer on any Factory. The structure limits will be increased if necessary
\par 
\par VOID resetStructTargets()
\par reset the structure preferences
\par 
\par VOID resetDroidTargets()
\par reset the unit preferences
\par 
\par VOID setStructTarPref(INT type)
\par set a prefered structure target type, repeated calls combine the effect
\par 
\par VOID setStructTarIgnore(INT type)
\par set structure target ignore types
\par 
\par VOID setDroidTarPref(INT type)
\par set prefered unit target types
\par 
\par VOID setDroidTarIgnore(INT type)
\par set unit target ignore types
\par 
\par STRUCTURE structTargetInArea(INT targetPlayer, INT visibleToPlayer, INT x1, INT y1, INT x2, INT y2)
\par get a structure target in an area using the preferences
\par targetPlayer is the player to choose targets from, visibleToPlayer specifies the
\par player that has to be able to see the target or -1 for no visibility check
\par 
\par STRUCTURE structTargetOnMap(INT targetPlayer, INT visibleToPlayer)
\par get a structure target on the map using the preferences
\par 
\par DROID droidTargetInArea(INT targetPlayer, INT visibleToPlayer, INT x1, INT y1, INT x2, INT y2)
\par get a unit target in an area using the preferences
\par 
\par DROID droidTargetOnMap(INT targetPlayer, INT visibleToPlayer)
\par get a unit target on the map using the preferences
\par 
\par BASEOBJ targetInCluster(INT clusterID, INT visibleToPlayer)
\par get a target from a cluster using the preferences
\par 
\par VOID fireWeaponAtObj(WEAPON weap, BASEOBJ target)
\par fire a single shot of the weapon weap at the object target
\par 
\par VOID fireWeaponAtLoc(WEAPON weap, INT x, INT y)
\par fire a single shot of the weapon weap at the location x,y
\par 
\par 
\par BOOL isStructureAvailable(STRUCTURESTAT stat, INT player)
\par PC ONLY FOR NOW. returns true if structure is available to player, false otherwise.
\par 
\par BOOL structureComplete(STRUCTURE struct)
\par PC ONLY FOR NOW. returns true if the structure is completely built.
\par 
\par INT getDroidCount(INT player)
\par returns the number of units on the current map for the specified player
\par 
\par setDroidKills(DROID droid, INT kills)
\par sets the number of kills for a unit.  currently the level boudaries are:
\par 4, 8, 16, 32, 64, 128, 256, 128
\par 
\par resetPlayerVisibility(INT player)
\par reset the visibility for a player
\par 
\par VOID resetLimboMission(VOID)
\par This can only be called mid Limbo Expand mission - the units that were stored in the
\par mission list at the start of the mission are added back into the map, and the mission
\par type is changed to an Expand Mission.
\par 
\par INT killDroidsInArea(INT x1, INT y1, INT x2, INT y2, INT player)
\par Kills all the player's units within the area defined. Returns how many it wiped out.
\par 
\par  traceOn()  -- view the script debug info to stdout.
\par  traceOff()
\par 
\par BOOL applyLimitSet (void)
\par Apply the limits set in the structure limits screen.
\par 
\par BOOL isHumanPlayer (INT pl)
\par Returns true is pl is human.
\par 
\par VOID offerAlliance (INT p1, INT p2)
\par Make p1 offer p2 an alliance
\par 
\par BOOL allianceExistsBetween (INT p1 , INT p2)
\par True if alliance exists between p1 and p2.
\par 
\par VOID skDoResearch\{ STRUCTURE str , INT pl , INT bias)
\par Make player pl do some research with structure str.
\par 
\par BASEOBJECT\tab skLocateEnemy( INT pl)
\par Return a baseobject of interest belonging to player pl.
\par 
\par BOOL\tab  skCanBuildTemplate\{ INT pl, STRUCTURE str, TEMPLATE tem)
\par True when player pl can build design tem with structure str.
\par 
\par BOOL\tab skVtolEnableCheck\{ INT pl)
\par True when player pl is actively using vtols.
\par 
\par INT\tab skGetFactoryCapacity( STRUCTURE str)
\par Return the capacity of factory str.
\par 
\par VOID\tab skDifficultyModifier( INT pl)
\par Apply the frontend slider settings to player pl.
\par 
\par BOOL\tab skDefenseLocation (ref INT x , ref INT y , STRUCTURESTAT defenceStat, STRUCTURESTAT wallstat, DROID unit, INT player\} \},
\par Given a starting x and y, make unit \lquote unit\rquote  belonging to \lquote player\rquote  build either a \lquote defenceStat\rquote  or a row of \lquote wallStat\rquote s. returns 
\par Modified x and y\rquote s.
\par 
\par VOID\tab skFireLassat \{INT pl, BASEOBJECT obj)
\par Fire lassat of player pl\rquote s at object obj.
\par 
\par }{\b SCRIPT FUNCTION CONSTANTS
\par }{
\par These values are used to represent numbers that are constant throughout the game.
\par 
\par BUTTONID - these values are used when a particular reticule button needs to be identified
\par OPTIONS\tab \tab - NOTE - this currently references the command button
\par CANCEL
\par BUILD
\par MANUFACTURE
\par RESEARCH
\par INTELMAP
\par DESIGN
\par COMMAND
\par  - When flashing an icon - with scrFlashOn()  scrFlashOff()
\par you can additional use
\par 
\par \tab IDRET_OPTIONS,
\par \tab IDRET_CANCEL,\tab \tab 
\par \tab IDRET_BUILD,\tab \tab 
\par \tab IDRET_MANUFACTURE,\tab 
\par \tab IDRET_RESEARCH,\tab \tab 
\par \tab IDRET_INTEL_MAP,\tab 
\par \tab IDRET_DESIGN,\tab \tab 
\par \tab IDRET_COMMAND,\tab \tab 
\par \tab IDDES_TEMPLSTART,\tab 
\par \tab IDDES_SYSTEMBUTTON,\tab 
\par \tab IDDES_BODYBUTTON,\tab 
\par \tab IDDES_PROPBUTTON,\tab 
\par 
\par 
\par 
\par MESSAGETYPE - these values are used when a type of message needs to be identified
\par RES_MSG
\par CAMP_MSG
\par MISS_MSG
\par PROX_MSG
\par 
\par NULLOBJECT - used to check that a BASEOBJECT has been assigned by a function
\par NULLTEMPLATE - used to check that a TEMPLATE has been assigned by a function
\par NULLSTAT - used to check that a BASESTAT has been assigned by a function
\par 
\par BARBARIAN1 - this can used to represent enemy1 (PC:player 6, PSX:player2)
\par BARBARIAN2 - this can used to represent enemy2 (PC:player 7, PSX:player3)
\par 
\par MISSIONTYPE - these values are used when a type of mission needs to be identified
\par CAMP_START - used for the starting point of a campaign
\par CAMP_EXPAND - used to expand a current campaign map
\par OFF_KEEP - used to load up an off world map, but keeping access to factories and 
\par \tab    research facilities back at home base
\par OFF_CLEAR - used to load up an off world map, but having no access to home base
\par 
\par LZ_COMPROMISED_TIME - value to set the reinforcement time with to display '--:--' when
\par \tab \tab the Transporter is unable to land
\par 
\par Droid Orders
\par \tab DORDER_NONE\tab \tab \tab - no order assigned
\par \tab DORDER_STOP\tab \tab \tab - stop current order
\par \tab DORDER_RETREAT\tab \tab - retreat
\par \tab DORDER_DESTRUCT\tab \tab - self destruct
\par \tab DORDER_RTR\tab \tab \tab - return to repair
\par \tab DORDER_RTB\tab \tab \tab - return to base
\par \tab DORDER_RUN\tab \tab \tab - run away for a bit (moral failure)
\par \tab DORDER_MOVE\tab \tab \tab - move to location
\par \tab DORDER_ATTACK\tab \tab - attack the object
\par \tab DORDER_HELPBUILD\tab - help construct the object
\par \tab DORDER_DEMOLISH\tab \tab - demolish structure
\par \tab DORDER_REPAIR\tab \tab - repair structure
\par \tab DORDER_OBSERVE\tab \tab - (sensor units) keep a target in sensor range
\par \tab DORDER_EMBARK\tab \tab - get onto a transporter
\par \tab DORDER_FIRESUPPORT\tab - follow this sensor unit and attack anything it DORDER_OBSERVE's
\par \tab DORDER_SCOUT\tab \tab - same as move, but stop if enemy units are encountered.
\par 
\par Unit secondary orders
\par \tab DSO_ATTACK_RANGE
\par \tab DSO_REPAIR_LEVEL
\par \tab DSO_ATTACK_LEVEL
\par \tab DSO_RECYCLE,
\par \tab DSO_PATROL,\tab \tab \tab \tab \tab // patrol between current pos and next move target
\par \tab DSO_HALTTYPE,\tab \tab \tab \tab // what to do when stopped
\par \tab DSO_RETURN_TO_LOC,\tab \tab \tab // return to various locations
\par 
\par Unit secondary states
\par \tab DSS_ARANGE_SHORT
\par \tab DSS_ARANGE_LONG
\par \tab DSS_ARANGE_DEFAULT
\par 
\par \tab DSS_REPLEV_LOW\tab \tab \tab //Medium Damage Taken
\par \tab DSS_REPLEV_HIGH\tab \tab \tab //Heavy Damage Taken
\par \tab DSS_REPLEV_NEVER\tab \tab //Never Repair
\par 
\par \tab DSS_ALEV_ALWAYS
\par \tab DSS_ALEV_ATTACKED
\par \tab DSS_ALEV_NEVER
\par 
\par \tab DSS_PATROL_SET\tab \tab \tab (0 to clear)
\par 
\par \tab DSS_HALT_HOLD
\par \tab DSS_HALT_GUARD
\par \tab DSS_HALT_PERSUE
\par 
\par \tab DSS_RECYCLE_SET\tab \tab \tab (0 to clear)
\par 
\par \tab DSS_RTL_REPAIR\tab \tab \tab (0 to clear)
\par \tab DSS_RTL_BASE\tab \tab \tab (0 to clear)
\par \tab DSS_RTL_TRANSPORT\tab \tab (0 to clear)
\par 
\par Button ID's
\par \tab IDRET_OPTIONS\tab \tab // option button
\par \tab IDRET_BUILD\tab \tab \tab // build button
\par \tab IDRET_MANUFACTURE\tab // manufacture button
\par \tab IDRET_RESEARCH\tab \tab // research button
\par \tab IDRET_INTEL_MAP\tab \tab // intelligence map button
\par \tab IDRET_DESIGN\tab \tab // design units button
\par \tab IDRET_CANCEL\tab \tab // central cancel button
\par 
\par Unit types
\par \tab DROID_WEAPON,\tab \tab // Weapon unit
\par \tab DROID_SENSOR,\tab \tab // Sensor unit
\par \tab DROID_ECM,\tab \tab \tab // ECM unit
\par \tab DROID_CONSTRUCT,\tab // Constructor unit
\par \tab DROID_PERSON,\tab \tab // person
\par \tab DROID_CYBORG,\tab \tab // cyborg-type thang
\par \tab DROID_TRANSPORTER,\tab // guess what this is!
\par \tab DROID_COMMAND,\tab \tab // Command unit
\par \tab DROID_REPAIR,\tab \tab // Repair Unit
\par 
\par Structure types
\par \tab REF_HQ,
\par \tab REF_FACTORY,\tab 
\par \tab REF_FACTORY_MODULE,//draw as factory 2\tab 
\par \tab REF_POWER_GEN,
\par \tab REF_POWER_MODULE,
\par \tab REF_RESOURCE_EXTRACTOR,
\par \tab REF_DEFENSE,
\par \tab REF_WALL,
\par \tab REF_WALLCORNER,\tab \tab \tab \tab //corner wall - no gun
\par \tab REF_RESEARCH,\tab 
\par \tab REF_RESEARCH_MODULE,\tab 
\par \tab REF_REPAIR_FACILITY,
\par \tab REF_COMMAND_CONTROL,\tab \tab //control centre for command units
\par \tab REF_CYBORG_FACTORY,
\par \tab REF_VTOL_FACTORY,
\par \tab REF_REARM_PAD,
\par \tab REF_MISSILE_SILO,
\par 
\par 
\par Multiplayer Game Types
\par \tab SKIRMISH
\par \tab DMATCH
\par \tab CAMPAIGN
\par \tab TEAMPLAY
\par 
\par MultiPlayer Base Configurtations
\par \tab CAMP_CLEAN\tab \tab // build units only
\par \tab CAMP_BASE\tab \tab // small base
\par \tab CAMP_WALLS\tab \tab // defensive base.
\par 
\par 
\par Cursor Mode (possible values of cursorType)
\par \tab IMAGE_CURSOR_SELECT,
\par \tab IMAGE_CURSOR_ATTACK,
\par \tab IMAGE_CURSOR_MOVE,
\par \tab IMAGE_CURSOR_JAM,
\par \tab IMAGE_CURSOR_PICKUP,
\par \tab IMAGE_CURSOR_DEFAULT,
\par \tab IMAGE_CURSOR_SEEKREPAIR,
\par \tab IMAGE_CURSOR_BUILD,
\par \tab IMAGE_CURSOR_GUARD,
\par \tab IMAGE_CURSOR_BRIDGE,
\par \tab IMAGE_CURSOR_ATTACH,
\par \tab IMAGE_CURSOR_LOCKON,
\par \tab IMAGE_CURSOR_FIX,
\par \tab IMAGE_CURSOR_EMBARK,
\par 
\par 
\par Game mode - possible values for intMode external variable
\par \tab INT_NORMAL,\tab \tab // Standard mode (just the reticule)
\par \tab INT_OPTION,\tab \tab // Option screen
\par \tab INT_EDITSTAT,\tab // Stat screen up for placing objects
\par \tab INT_EDIT,\tab \tab // Edit mode
\par \tab INT_OBJECT,\tab \tab // Object screen
\par \tab INT_STAT,\tab \tab // Object screen with stat screen
\par \tab INT_CMDORDER,\tab // Object screen with command units and orders screen
\par \tab INT_DESIGN,\tab \tab // Design screen
\par \tab INT_INTELMAP,\tab // Intelligence Map
\par \tab INT_ORDER,
\par \tab INT_INGAMEOP,\tab // in game options.
\par \tab INT_TRANSPORTER, //Loading/unloading a Transporter
\par \tab INT_MISSIONRES,\tab // Results of a mission display.
\par \tab INT_MULTIMENU,\tab // multiplayer only, player stats etc...
\par 
\par Possible options for getGameStatus()
\par \tab STATUS_ReticuleIsOpen\tab \tab \tab // returns true is the reticule is open
\par \tab STATUS_BattleMapViewEnabled\tab \tab // returns true if we are in battlemap mode
\par 
\par Possible values for targetedObjectType
\par MT_TERRAIN,
\par MT_RESOURCE,
\par MT_BLOCKING,
\par MT_RIVER,
\par MT_TRENCH,
\par MT_OWNSTRDAM,
\par MT_OWNSTROK,
\par MT_OWNSTRINCOMP,
\par MT_REPAIR,
\par MT_REPAIRDAM,
\par MT_ENEMYSTR,
\par MT_TRANDROID,
\par MT_OWNDROID,
\par MT_OWNDROIDDAM,
\par MT_ENEMYDROID,
\par MT_COMMAND,
\par MT_ARTIFACT,
\par MT_DAMFEATURE,
\par MT_SENSOR,
\par MT_WRECKFEATURE,
\par 
\par 
\par Structure Target preference types
\par ST_HQ\tab \tab \tab \tab \tab = 1,
\par ST_FACTORY\tab \tab \tab \tab = 2,
\par ST_POWER_GEN\tab \tab \tab = 4,
\par ST_RESOURCE_EXTRACTOR\tab = 8,
\par ST_WALL\tab \tab \tab \tab \tab = 16,
\par ST_RESEARCH\tab \tab \tab \tab = 32,
\par ST_REPAIR_FACILITY\tab \tab = 64,
\par ST_COMMAND_CONTROL\tab \tab = 128,
\par ST_CYBORG_FACTORY\tab \tab = 256,
\par ST_VTOL_FACTORY\tab \tab \tab = 512,
\par ST_REARM_PAD\tab \tab \tab = 1024,
\par ST_SENSOR\tab \tab \tab \tab = 2048,
\par ST_DEF_GROUND\tab \tab \tab = 4096,
\par ST_DEF_AIR\tab \tab \tab \tab = 8192,
\par ST_DEF_IDF\tab \tab \tab \tab = 16384,
\par ST_DEF_ALL\tab \tab \tab \tab = 28672,\tab - ground/air/idf structures
\par 
\par 
\par Unit target preference types
\par // turret types
\par DT_COMMAND\tab \tab \tab \tab = 1,
\par DT_SENSOR\tab \tab \tab \tab = 2,
\par DT_CONSTRUCT\tab \tab \tab = 4,
\par DT_REPAIR\tab \tab \tab \tab = 8,
\par DT_WEAP_GROUND\tab \tab \tab = 16,
\par DT_WEAP_AIR\tab \tab \tab \tab = 32,
\par DT_WEAP_IDF\tab \tab \tab \tab = 64,
\par DT_WEAP_ALL\tab \tab \tab \tab = 112,\tab \tab - ground/air/idf units
\par 
\par // body types
\par DT_LIGHT\tab \tab \tab \tab = 128,
\par DT_MEDIUM\tab \tab \tab \tab = 256,
\par DT_HEAVY\tab \tab \tab \tab = 512,
\par DT_SUPER_HEAVY\tab \tab \tab = 1024,\tab \tab - transporter only
\par 
\par // propulsion
\par DT_TRACK\tab \tab \tab \tab = 2048,
\par DT_HTRACK\tab \tab \tab \tab = 4096,
\par DT_WHEEL\tab \tab \tab \tab = 8192,
\par DT_LEGS\tab \tab \tab \tab \tab = 16384,
\par DT_GROUND\tab \tab \tab \tab = 30720,
\par DT_VTOL\tab \tab \tab \tab \tab = 32768,
\par DT_HOVER\tab \tab \tab \tab = 65536,\tab - any ground propulsion
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\lang2057\cgrid {\f2 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid {\b SCRIPT FUNCTION EXTERNALS
\par }{
\par These represent variables that are defined in the game which can be accessed in the scripts. It will only be possible to set the value that is held for some of the variables. 
\par 
\par mapWidth - (get) - field to hold the width of the map
\par 
\par mapHeight - (get) - field to hold the height of the map
\par 
\par gameInitialised - (get) flag to specify when all initialisation has been performed for the game - use it in place of a bool ie can be considered to equal true or false
\par 
\par selectedPlayer - (get) field to hold the currently selected player
\par 
\par gameTime - (get) the current time in the game (in 1/10 sec)
\par 
\par multiPlayerGameType \tab - (get) the type of multiplayer game underway.
\par multiPlayerMaxPlayers \tab - max number of human players in this game.(see constants for return values)
\par multiPlayerBaseType \tab - campaign game base type. (see constants for return values)
\par 
\par scrollX\tab - (get/set) field to hold the starting x coordinate where the player can scroll
\par scrollY  - (get/set) field to hold the starting y coordinate where the player can scroll
\par scrollWidth - (get/set) field to hold the width the player can scroll
\par scrollHeight - (get/set) field to hold the height the player can scroll
\par 
\par cursorType   - (get)  - Gets the current mode that the cursor is in (e.g. IMAGE_CURSOR_BUILD ... see scriptConstant.txt)
\par intMode\tab - (get)\tab \tab - Get the current game mode (e.g. INT_DESIGN when the design screen is active) ... see scriptConstant.txt)
\par 
\par targetedObjectType - (get) - The type of the object currently under the cursor (one of MT_... see scriptconstants.txt)
\par 
\par BOOL extraVictoryFlag\tab - use to mark additional victory conditions have been met - reset to FALSE at start of each level
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\lang2057\cgrid {\f2 BOOL extraFailFlag\tab \tab - use to mark additional failure conditions have been met - reset to FALSE at start of each level
\par 
\par GameLevel (get/set) \endash  set single player difficulty.
\par 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid {\b SCRIPT FUNCTION CALLBACKS
\par }{
\par These are used in the place of a trigger and are for events that are to be called at specific times in the game. They will cause the event they are associated with to be called every time unless the trigger for the event is set to inactive.
\par 
\par CALL_GAMEINIT - this is triggered when the game has initialised
\par CALL_DROIDDESIGNED - this is triggered when the player saves a template design
\par CALL_RESEARCHCOMPLETED - this is triggered when a research topic is complete - major or minor
\par CALL_DROIDBUILT - this is triggered when a unit has been built via a factory
\par CALL_POWERGEN_BUILT - this is triggered when a Power generatot has been built
\par CALL_RESEX_BUILT - this is triggered when a Resource Extractor has been built
\par CALL_RESEARCH_BUILT - this is triggered when a Research Facility has been built
\par CALL_FACTORY_BUILT - this is triggered when a Factory has been built
\par CALL_MISSION_START - this is triggered when CTRL + 'M' is pressed so that the script can start a mission
\par CALL_MISSION_END - this is triggered when CTRL + 'B' is pressed so that the script can end a mission
\par CALL_VIDEO_QUIT - this is triggered when the CURRENT video sequence is over - either end of anim or when 'ESC' has been pressed
\par CALL_LAUNCH_TRANSPORTER - this is triggered when the 'Launch' button is pressed on the Transporter interface
\par CALL_START_NEXT_LEVEL - this is triggered when a new level is desired
\par CALL_TRANSPORTER_REINFORCE - this is triggered when a transporter carrying reinforcements for player 0 enters the map
\par CALL_MISSION_TIME - this is triggered when the time specified by setMissionTime() has elapsed
\par CALL_ELECTRONIC_TAKEOVER - triggered when a unit or a structure for the selectedPlayer are taken over using Electronic weapons
\par 
\par Callbacks with parameters:
\par 
\par CALL_NEWDROID player, ref DROID,ref STRUCTURE
\par triggered when a unit for player is built by a factory.  DROID is the unit that was built
\par structure is the factory that built it, dont assume that the factory is still there!!
\par 
\par CALL_STRUCT_ATTACKED player, ref STRUCTURE, ref BASEOBJ
\par triggered when a structure for player is attacked.  STRUCTURE is the attacked structure,
\par BASEOBJ is the unit that attacked the structure (could be NULLOBJECT)
\par 
\par CALL_DROID_ATTACKED player, ref DROID, ref BASEOBJ
\par triggered when a unit for player is attacked.  DROID is the attacked unit,
\par BASEOBJ is the unit that attacked (could be NULLOBJECT)
\par 
\par CALL_ATTACKED player, ref BASEOBJ, ref BASEOBJ
\par triggered when a structure or unit for player is attacked.  BASEOBJ is the attacked unit,
\par BASEOBJ is the unit that attacked (could be NULLOBJECT)
\par 
\par CALL_TRANSPORTER_OFFMAP player
\par triggered when a transporter for player exits the map.
\par 
\par CALL_TRANSPORTER_LANDED GROUP, player
\par triggered when transporter for player lands; units on transporter are unloaded
\par into the given GROUP.
\par 
\par Tutorial Callbacks
\par 
\par CALL_BUILDLIST\tab \tab \tab - Build structures interface up
\par CALL_BUILDGRID\tab \tab \tab - Place structure cursor up
\par CALL_RESEARCHLIST\tab \tab - Choose research interface up
\par CALL_MANURUN\tab \tab \tab - Number of units to manufacture has changed
\par CALL_MANULIST\tab \tab \tab - Choose manufacturing interface up
\par 
\par 
\par CALL_BUTTON_PRESSED buttonID
\par triggered when an interface button with id buttonID is pressed
\par 
\par CALL_DESIGN_QUIT
\par triggered when the design screen is closed
\par 
\par 
\par CALL_OBJ_DESTROYED, INT player, ref BASEOBJ object
\par triggered when either a unit or a structure for player is destroyed
\par 
\par CALL_DROID_DESTROYED, INT player, ref DROID droid
\par triggered when a unit for player is destroyed
\par 
\par CALL_STRUCT_DESTROYED, INT player, ref STRUCTURE structure
\par triggered when a structure for player is destroyed
\par 
\par CALL_FEATURE_DESTROYED, ref FEATURE feature
\par triggered when either a unit or a structure for player is destroyed
\par 
\par CALL_OBJ_SEEN, INT player, ref BASEOBJ object, ref BASEOBJ viewer
\par triggered when either a unit or a structure is seen by a unit belonging to player.
\par object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).
\par 
\par CALL_DROID_SEEN, INT player, ref BASEOBJ object, ref BASEOBJ viewer
\par triggered when a unit is seen by a unit belonging to player.
\par object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).
\par 
\par CALL_STRUCT_SEEN, INT player, ref BASEOBJ object, ref BASEOBJ viewer
\par triggered when a structure is seen by a unit belonging to player.
\par object is the thing that was seen, viewer is the thing that saw it (may be NULLOBJECT).
\par 
\par CALL_NO_REINFORCEMENTS_LEFT - called when the player has transferred all reinforcements from one level to the next
\par 
\par More tutorial callbacks - ALL tutorial only
\par 
\par CALL_DESIGN_WEAPON\tab \tab - a weapon button pressed
\par CALL_DESIGN_SYSTEM\tab \tab - a system (constructor/ecm/sensor/etc) button pressed
\par CALL_DESIGN_COMMAND\tab \tab - a command droid turret pressed
\par CALL_DESIGN_BODY\tab \tab - a body selected
\par CALL_DESIGN_PROPULSION\tab - a propulsion selected
\par 
\par CALL_ALL_ONSCREEN_DROIDS_SELECTED - does exactly when it says on the box
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\lang2057\cgrid {\f2 
\par CALL_UNITTAKEOVER, ref unit;
\par \tab Unit has been taken over by nexus link\'85
\par 
\par CALL_PLAYERLEFT,\tab ref int player;
\par \tab Player has left the multiplayer game.
\par 
\par CALL_ALLIANCEOFFER, ref int one, ref int two
\par \tab One offers two an alliance.
\par }}