/////////////////////////////////////////////////////////////////////
// ai for skirmish game
/////////////////////////////////////////////////////////////////////
// Warzone2100, Pumpkin Studios, 
// alex lee.98/99.
//
// This script does the following.
// -------------------------------
// structural rules
//  * ensure we have derricks.
//  * if oil in range with no derrick on . build
//  * if idle and derrick in range and no defense then build defense, else rtb.
//  * build a power gen for every 4 derricks.
//  * ensure we have everything in the vital structs list.
//  * build stage two.. build other stuff, grow the base slowly...
//  * Structure (fac/res/pow) upgrades
//	* Finish Building Part Built Structures 
//  * keep details about the size and postion of the ai players base
//  * fortify base by building defensive structs on the edge of the base.
// vehicle rules
//  * deal with a droid being built 
//  * deal with attacks. 
//  * build more con droids.
//  * build better droids as time goes on.
//  * put vrhicle factories to work
//  * put cyborg factories to work
//  * scout an area
//  * dont unneccesarily wonder around the base. (better comms and faster play)
//  * visit new places
//  * order scouts
//  * process new visibility reports
//  * send attack team out to cause trouble near things scout found.
//  * defend attacked objects.
//  * defenders  return after they are finished.
// management rules
//  * do research
//  * form alliances
//  * break the alliance too.
//  * bring forces back together to consolidate attacks
//  * stop building stuff on low power, but only when appropriate. maybe: no power == build lighter units.
// vtol rules
//  * if any player attacks with a vtol. build a vtol defense within range of the attacked strucutre..
//  * build a vtol factory if required.
//  * make sure that vtol factories have pads.
//  * vtol factories build vtols.
//  * groups of vtols attack the attack and defend group targets..

// * dont ever build more than 80 units. 

// still to do / should do
// -----------------------
//  * build walls in bright places.
//  * store locations when see other hq's/good targets.
//  * multiple scout groups.
//  * jump base!
//  * attack teams should concentrate on (roughly) one opposing player at a time.

/////////////////////////////////////////////////////////////////////

public	INT				player;				// player for this instance.

public	INT				tileExpand;

public	INT				numScouts;			// aim for...
public	INT				numDefenders;
public	INT				numAttackers;

// structures
private INT				baseX,baseY,minx,miny,maxx,maxy;				// base details
public	INT				numStructs,numDefStructs,numExtraStructs;							
public	STRUCTURESTAT	structs[5],defStructs[10],extraStructs[5];
public	STRUCTURESTAT	resLab,powGen,playerHQ,factory,derrick,cybFactory,vtolDefStruct,vtolPad,vtolFactory;
public	STRUCTURESTAT	powModule,facModule,resModule;
public	INT				extraStruct;

// common droid types.
public	TEMPLATE		constructor,cybTempl[4];						
public	TEMPLATE		tmpl[36];
public	INT				numTemplates,tmplTwo,tmplThree;
public	INT				numCyborgs;
private INT				currentCyborgs,currentCyborgTemplate;
private INT				curTemplate;
private INT				facState;

//defend
private GROUP			defendGroup;
private BOOL			defendbusy;
private BASEOBJ			defendObj;

//build
private GROUP			buildGroup;
private INT				buildX,buildY;
public	FEATURESTAT		oilRes;

// scout
private GROUP			scoutGroup;
private INT				scoutX,scoutY;
private INT				scoutTLX,scoutTLY,scoutW,scoutH;

// attack
private GROUP			attackGroup;
private BASEOBJ			attackObj;

// vtols
private GROUP			vtolGroup;
public	TEMPLATE		vtolTemplate;

// research
public	RESEARCHSTAT	res[100];
public	INT				numResearch,resClean,resBase,resDefensive;
private INT				curResearch;

// generic
private STRUCTURE		structure;
private DROID			droid;
private FEATURE			feature;
private BASEOBJ			baseobj,baseobj2;
private INT				count,count2,result,tempx,tempy;
private BOOL			boolResult,boolResult2;

private BOOL			powerSave;

/////////////////////////////////////////////////////////////////////
// triggers.

trigger buildExpandTr				(every, 1400);
trigger fortifyTr					(every,	2110);
trigger upgradeStructuresTr			(every, 590 );
trigger conDroidsTr					(every, 3600);
trigger	managePowerTr				(every, 2000);
trigger basedetailsTr				(every, 700	);
trigger buildDerrickTr				(every, 110	);
trigger buildOilDefenseOrRetreatTr	(every, 170	);
trigger buildPowerGeneratorsTr		(every, 90	);
trigger buildBaseTr					(every, 210	);
trigger finishStructsTr				(every, 610 );
//event droidBuilt					(CALL_NEWDROID,player, ref droid,ref structure)
//event droidDestroyed				(CALL_DROID_DESTROYED,  player, ref droid)
trigger consolidateEventTr			(every,	1700);
trigger droidUpgradeTr				(every, 1800);
trigger factoryEventTr				(every, 200	);
trigger cyborgFactoryEventTr		(every, 200	);
trigger chooseScoutAreaTr			(every,	200	);
trigger expandScoutAreaTr			(every,	600	);
trigger scoutMainTr					(every,	150	);
//event newObjectReport				(CALL_OBJ_SEEN, player, ref baseobj, ref baseobj2)
trigger attackStuffTr				(every, 300	);
//event defendWatch					(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
trigger defendReturnTr				(every,	600	);
trigger doResearchTr				(every, 900);
//event vtolDefend(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
trigger vtolStructsTr				(every, 360);		
trigger buildVtolsTr				(every, 360);		
trigger vtolAttackTr				(every, 460);			


/////////////////////////////////////////////////////////////////////
// HouseKeeping

event initialisedEvent(CALL_GAMEINIT)
{

	// setup build group
	//all initial droids are in buildgroup! (assume only constructs for now)

	facState	= 0;
	extraStruct = 0;

	groupAddArea(buildGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));  
	initGetFeature(oilRes,player,player);		// use bucket = player

	// note where our base is.
	initIterateGroup(buildGroup);		// find idle droids in build group.
	droid = iterateGroup(buildGroup);
	if(droid != NULLOBJECT)
	{
		baseX = droid.x;
		baseY = droid.y;
	}
	else
	{
		baseX = (128*mapWidth)/2;
		baseY = (128*mapHeight)/2;
	}

	// defence.
	defendbusy = FALSE;
	
	// setup scouts
	structure = getStructure(factory, player);
	if(structure != NULLOBJECT)
	{	
		scoutTLX		= structure.x;
		scoutTLY		= structure.y;
	}
	else
	{
		scoutTLX		= baseX;
		scoutTLY		= baseY;
	}
	scoutW			= 256;
	scoutH			= 256;
	scoutX			= scoutTLX;
	scoutY			= scoutTLY;

	// setup indexes into research etc...
	if(multiPlayerBaseType == CAMP_CLEAN)
	{
		curTemplate = 2;
		curResearch = resClean;
	}
	else if(multiPlayerBaseType == CAMP_BASE)
	{
		curTemplate = tmplTwo + 2;
		curResearch = resBase;
	}
	else
	{
		curTemplate = tmplThree + 2;
		curResearch = resDefensive;
	}

	currentCyborgTemplate = 0;
	powerSave = FALSE;
}

/////////////////////////////////////////////////////////////////////

event givehelp(every, 100)
{
 	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{
		setEventTrigger(givehelp,	inactive);			
	}
	else
	{
		if(multiPlayerBaseType == CAMP_WALLS)
		{
			// free power
			addPower(1500, player);

			// free droids.
			count = 0;
			while(count<10)
			{
				tempx = baseX;
				tempy = baseY;
				 
				boolResult = pickStructLocation(defStructs[0], ref tempx, ref tempy,player);
				if(boolResult == TRUE)
				{
					addDroid(tmpl[ random(6) ]  , tempx, tempy, player);
				}

				count = count + 1;
			}

		}
		setEventTrigger(givehelp,	inactive);			

	}
}

/////////////////////////////////////////////////////////////////////
// keep details about the size and postion of the ai players base
event basedetails(basedetailsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{
		setEventTrigger(basedetails,	inactive);			
	}
	else
	{
		// clear old extremities.
		maxy = 0;
		maxx = 0;
		miny = (mapHeight*128);
		minx = (mapWidth*128);

		// now find the extremities of our vital structures.	
		count = 0;
		while(count < numStructs)
		{
			initEnumStruct(FALSE,structs[count],player,player);					
			structure= enumStruct();
			while(structure != NULLOBJECT)	
			{
				if(structure.x < minx)
				{
					minx = structure.x;
				}
				if(structure.x > maxx)
				{
					maxx = structure.x;	
				}
				if(structure.y < miny)
				{
					miny = structure.y;
				}
				if(structure.y > maxy)
				{
					maxy = structure.y;
				}
				structure= enumStruct();
			}
			count = count + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// structure building rules

// ensure we have derricks.
// if oil in range with no derrick on . build

event buildDerrick(buildDerrickTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildDerrick,	inactive);			
	}
	else
	{
		feature = getFeature(player);					// find unoccupied oil resource.
		if(feature != NULLOBJECT)
		{
			buildX = feature.x;
			buildY = feature.y;

			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			boolResult = FALSE;							// only send 1 droid to each derrick
			while( (boolResult == FALSE) and (droid != NULLOBJECT))
			{
				if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);	//build a derick
					boolResult = TRUE;
				}
				droid = iterateGroup(buildGroup);
			}
		}
		else											// feature is null
		{
			initGetFeature(oilRes,player,player);		// start again next time.
		}
	}
}

/////////////////////////////////////////////////////////////////////
// if idle and derrick in range and no defense then build defense, else rtb.
event buildOilDefenseOrRetreat(buildOilDefenseOrRetreatTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildOilDefenseOrRetreat,	inactive);			
	}
	else
	{
		// check idle.
		initIterateGroup(buildGroup);					// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				// if in range of a derrick				 
				structure = structureBuiltInRange(derrick, droid.x, droid.y, (3*128), player);

				if(structure != NULLOBJECT)
				{
					buildX = droid.x;
					buildY = droid.y;
					
					count = 0;							// if derrick has no defense near it.
					result = 0;
					while(count < numDefStructs)
					{	
						structure = structureBuiltInRange(defStructs[count], droid.x, droid.y,(3*128), player);
						if(structure != NULLOBJECT)
						{				
							result = 1;								// found a defense. 
						}
						count = count + 1;
					}

					// no defense nearby
					if(result == 0)
					{
						result = random(numDefStructs);				// pick a structure

						// pick a location 
						boolResult = pickStructLocation(defStructs[result], ref buildX, ref buildY,player);
						if(boolResult == TRUE)
						{						
							// build it.
							orderDroidStatsLoc(droid, DORDER_BUILD,defStructs[result], buildX,buildY);
						}	
					}
					else
					{	
						structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), player);	
						if(structure == NULLOBJECT)
						{
							orderDroid(droid,DORDER_RTB);				// return to base;
						}
					}					
				}
				else
				{
					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), player);	
					if(structure == NULLOBJECT)
					{
						orderDroid(droid,DORDER_RTB);					// return to base;
					}
				}
			}	
			droid = iterateGroup(buildGroup);
		}
	}
}


/////////////////////////////////////////////////////////////////////
// build a power gen for every 4 derricks. VITAL!
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildPowerGenerators,	inactive);			
	}
	else
	{
		initEnumStruct(FALSE,derrick,player,player);					// count = numderricks
		structure= enumStruct();
		count	 = 0;
		while(structure != NULLOBJECT)	
		{
			count = count + 1;
			structure= enumStruct();
		}
			
		initEnumStruct(FALSE,powGen,player,player);					// count2 = numpowgens
		structure= enumStruct();
		count2	 = 0;
		while(structure != NULLOBJECT)	
		{
			count2 = count2 + 1;
			structure= enumStruct();
		}
								
		if( (count2 * 4) < count )								// if we need powergen
		{
			buildX = baseX;										// try build powergen.
			buildY = baseY;
			boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{	
				initIterateGroup(buildGroup);				
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE or droid.order == DORDER_RTB)
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
					}
					droid = iterateGroup(buildGroup);
				}	
					
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
// ensure we have everything in the vital structs list.
event buildBase(buildBaseTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildBase,	inactive);			
	}
	else
	{
		if( idleGroup(buildGroup) >= (buildGroup.members/2) )
		{
			count = 0;
			while(count < numStructs)
			{
				// check that struct.
				structure = getStructure(structs[count],player);
				if(structure == NULLOBJECT)				// if missing build it.
				{
					buildX = baseX;						// pick a location 
					buildY = baseY;
					boolResult = pickStructLocation(structs[count], ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{	
						initIterateGroup(buildGroup);				// find idle droids in build group.
						droid = iterateGroup(buildGroup);
						while(droid != NULLOBJECT)
						{				
							if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
							{
								orderDroidStatsLoc(droid, DORDER_BUILD,structs[count], buildX,buildY);	// build it
							}
							droid = iterateGroup(buildGroup);
						}
					}
				}
				count = count + 1;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
//  build other stuff, grow the base slowly...
event buildExpand( buildExpandTr )
{

	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildExpand,inactive);			
	}
	else
	{

		if(extraStruct == numExtraStructs)	// loop round
		{
			extraStruct = 0;
		}

		buildX = baseX;						// pick a location 
		buildY = baseY;
		boolResult = pickStructLocation(extraStructs[extraStruct], ref buildX, ref buildY,player);
	
		if(boolResult == TRUE)
		{	
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order != DORDER_BUILD)
				{	
					orderDroidStatsLoc(droid, DORDER_BUILD,extraStructs[extraStruct], buildX,buildY);// build it.
				}
				droid = iterateGroup(buildGroup);
			}
		}
		extraStruct = extraStruct + 1;
	}
}


/////////////////////////////////////////////////////////////////////
//	Structure (fac/res/pow) upgrades
event upgradeStructures(upgradeStructuresTr )
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(upgradeStructures,inactive);			
	}
	else
	{
		initIterateGroup(buildGroup);				// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order != DORDER_BUILD)
			{	
				// got an idle constructor vehicle.
				//powergen
				initEnumStruct(FALSE,powGen,player,player);									
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)))			
					{
						orderDroidStatsLoc(droid,DORDER_BUILD,powModule, structure.x,structure.y);// upgrade it.				
					}
					structure= enumStruct();
				}
			
				//factory
				initEnumStruct(FALSE,factory,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)	
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(facModule,player) and (not testStructureModule(player, structure, 0)))			
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.			
					}
					structure= enumStruct();
				}

				//research
				initEnumStruct(FALSE,resLab,player,player);
				structure= enumStruct();
				while(structure != NULLOBJECT)	
				{
					// if upgrade is available && struct is not upgraded
					if( isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)))			
					{			
						orderDroidStatsLoc(droid, DORDER_BUILD,resModule, structure.x,structure.y);	// upgrade it.			
					}
					structure= enumStruct();
				}			
			}
			droid = iterateGroup(buildGroup);	
		}
	}
}


/////////////////////////////////////////////////////////////////////
//	Finish Building Part Built Structures 
event finishStructs(finishStructsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(finishStructs,	inactive);			
	}
	else
	{
		initEnumStruct(TRUE,factory,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)	
		{	
			if(not structureComplete(structure))
			{
				initIterateGroup(buildGroup);				// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order != DORDER_BUILD) 
					{	
						orderDroidObj(droid,DORDER_HELPBUILD,structure);
					}
					droid = iterateGroup(buildGroup);
				}
			}
			structure= enumStruct();
		}
	}
}


/////////////////////////////////////////////////////////////////////
//  fortify base by builiding defensive structs on the edge of the base.
event fortify(fortifyTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(fortify,	inactive);			
	}
	else
	{
		boolResult = FALSE;
		initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
		droid = iterateGroup(buildGroup);
		while((boolResult == FALSE) and (droid != NULLOBJECT))
		{
			if(droid.order != DORDER_BUILD)
			{	
				boolResult = TRUE;					// dont do this again!
				
				// pick a side of the base.
				tempx = 0;
				tempy = 0;
				result = random(4);
				if(result == 0)
				{
					tempx = minx - (3*128);
				}
				else if(result == 1)
				{
					tempx = maxx + (3*128);
				}
				else if(result == 2)
				{
					tempy = miny - (3*128);
				}
				else
				{
					tempy = maxy + (3*128);
				}

				// pick the other point at the edge of the base.....
				if(tempx == 0)
				{
					tempx = random( maxx - minx ) + minx;
				}
				if(tempy ==0)
				{
					tempy = random( maxy - miny ) + miny;
				}
					
				// now build a defense at that point
				result = random(numDefStructs);				// pick a structure

				// pick a location & build it.
				boolResult = pickStructLocation(defStructs[result], ref tempx, ref tempy,player);
				if(boolResult == TRUE)
				{						
					orderDroidStatsLoc(droid, DORDER_BUILD,defStructs[result], tempx,tempy);
				}	
			}
			droid = iterateGroup(buildGroup);
		}	
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// droid building rules


/////////////////////////////////////////////////////////////////////
// deal with a droid being built 
event droidBuilt(CALL_NEWDROID,player, ref droid,ref structure)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(droidBuilt,	inactive);			
	}
	else
	{
		if(isVtol(droid))
		{
			groupAddDroid(vtolGroup, droid);
		}
		else
		{
			if(droid.droidType == DROID_CONSTRUCT)				// if not constructor droid 
			{	
				groupAddDroid(buildGroup, droid);
			}
			else
			{	
				if(scoutGroup.members < numScouts)
				{	
					groupAddDroid(scoutGroup, droid);
				}
				else if( attackGroup.members < numAttackers)
				{
					groupAddDroid(attackGroup, droid);
				}
				else if( defendGroup.members < numDefenders)
				{
					groupAddDroid(defendGroup, droid);
				}
			
				else		// just make them scouts.
				{	
					if(attackGroup.members > scoutGroup.members)
					{
						groupAddDroid(scoutGroup, droid);
					}
					else
					{
						groupAddDroid(attackGroup, droid);
					}
				}
			}
		}
	}	
}

/////////////////////////////////////////////////////////////////////
// deal with attacks. 
event droidDestroyed(CALL_DROID_DESTROYED,  player, ref droid)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(droidDestroyed,inactive);			
	}
	else
	{
		if(droid.droidType == DROID_CONSTRUCT)						// if constructor droid 
		{
			initEnumStruct(FALSE,factory,player,player);
			structure= enumStruct();							// find factory.

			if( (structure != NULLOBJECT) and (getDroidCount(player) < 80) )
			{
				buildDroid(constructor, structure, player, 1);// build constructor
			}

		}
	}
}


/////////////////////////////////////////////////////////////////////
// build more con droids.
event conDroids(conDroidsTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(conDroids,inactive);			
	}
	else
	{	
		initEnumStruct(FALSE,factory,player,player);
		structure= enumStruct();							// find factory.

		if((structure != NULLOBJECT)  and (getDroidCount(player) < 80) )
		{
			buildDroid(constructor, structure, player, 1);// build constructor
		}
	}
}
/////////////////////////////////////////////////////////////////////
// build better droids.
event droidUpgrade(droidUpgradeTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(droidUpgrade,	inactive);			
	}
	else
	{
		if(curTemplate < (numTemplates - 1))
		{
			curTemplate = curTemplate + 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////
// put factories to work
event factoryEvent(factoryEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(factoryEvent,	inactive);			
	}
	else
	{
		initEnumStruct(FALSE,factory,player,player);
		structure= enumStruct();								// find factory.

		if(getDroidCount(player) < 80)
		{
			while(structure != NULLOBJECT)
			{
				if( structureIdle(structure) == TRUE)
				{	
					if(facState == 0)
					{
						buildDroid(tmpl[curTemplate], structure, player, 1);
						facState = 1;
					}
					else
					{
						if(facState == 1)
						{
							buildDroid(tmpl[curTemplate - 1],structure,player,1);
							facState = 2;
						}
						else
						{
							buildDroid(tmpl[curTemplate - 2],structure,player,1);
							facState = 0;
						}
					}
				}
				structure= enumStruct();								// find factory.
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// put cyborg factories to work
event cyborgFactoryEvent(cyborgFactoryEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(cyborgFactoryEvent,	inactive);			
	}
	else
	{
		initEnumStruct(FALSE,cybFactory,player,player);
		structure= enumStruct();								// find factory.

		while(structure != NULLOBJECT)
		{
			if( structureIdle(structure)  == TRUE)
			{	
				if( (scoutGroup.members < numCyborgs) and (getDroidCount(player) < 80) )
				{
					buildDroid(cybTempl[currentCyborgTemplate], structure, player, 1);
				}
			}
			structure= enumStruct();							// find factory.
		}
		
		// increment cyborg template counter, wrapping if required.
		currentCyborgTemplate = currentCyborgTemplate + 1;
		if( currentCyborgTemplate > 3)
		{
			currentCyborgTemplate = 0;
		}

	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// scouting rules

// scout an area
event chooseScoutArea(chooseScoutAreaTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(chooseScoutArea,	inactive);			
	}
	else
	{		
		// else wander randomly within this area.
		scoutX = scoutTLX + random(scoutW);
		scoutY = scoutTLY + random(scoutH);
	}
}

/////////////////////////////////////////////////////////////////////
// visit new places

event expandScoutArea(expandScoutAreaTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(expandScoutArea,	inactive);			
	}
	else
	{
		//expand the scouting area slightly
		scoutTLX	= scoutTLX - ((mapWidth*128)/ tileExpand);
		scoutTLY	= scoutTLY - ((mapHeight*128)/ tileExpand);
		scoutW		= scoutW + (2*((mapWidth*128)/ tileExpand));
		scoutH		= scoutH + (2*((mapHeight*128)/ tileExpand));

		// check & restrain.
		if(scoutTLX <1)
		{
			scoutTLX = 1;
		}
		if(scoutTLY <1)
		{
			scoutTLY = 1;
		}

		if(scoutTLX >(mapWidth*128))
		{
			scoutTLX = (mapWidth*128) - 128;
		}
		if(scoutTLY >(mapHeight*128))
		{
			scoutTLY = (128*mapHeight) - 128;
		}

		if( (scoutTLX + scoutW) > (128 * mapWidth) )
		{
			scoutW = ( (128 * mapWidth) - scoutTLX) - 128;
		}
		if( (scoutTLY + scoutH) > (128 *mapHeight) )
		{
			scoutH = ( (128*mapHeight) - scoutTLY) - 128;
		}
	}
}

/////////////////////////////////////////////////////////////////////
// order scouts

event scoutMain(scoutMainTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(scoutMain,	inactive);			
	}
	else
	{
		// find any new scouts
		// if scouts aren't busy, send them to a new spot.
		if( idleGroup(scoutGroup) >= (scoutGroup.members /2) )
		{	
			orderGroupLoc(scoutGroup, DORDER_MOVE,scoutX,scoutY);
		}
	}
}

/////////////////////////////////////////////////////////////////////
// process new visibility reports

event newObjectReport(CALL_OBJ_SEEN, player, ref baseobj, ref baseobj2)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(newObjectReport,	inactive);			
	}
	else
	{
		if( baseobj2 != NULLOBJECT )
		{
			if(baseobj2.type == OBJ_DROID)				
			{
				attackObj = baseobj;// got a new unseen target from a scout.
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// attack rules

// send attack team out to cause trouble near things scout found.
event attackStuff(attackStuffTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(attackStuff,	inactive);			
	}
	else
	{
		if( idleGroup(attackGroup) >= (attackGroup.members /2)) 
		{	
			if(attackObj != NULLOBJECT)
			{
				if(attackGroup.members > 7+random(10) ) 
				{		
					orderGroupLoc(attackGroup, DORDER_SCOUT,attackObj.x,attackObj.y);
				}
			}

		}
	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// defending rules

// defend attacked objects.
event defendWatch(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(defendWatch,	inactive);			
	}
	else
	{
		if(baseobj != NULLOBJECT)
		{
			defendObj = baseobj;
			defendbusy = TRUE;
			// if not too busy, attack.
			if( idleGroup(defendGroup) >= (defendGroup.members /2) )
			{			
				orderGroupObj(defendGroup, DORDER_ATTACK, defendObj);
			}
		}		
	}
}

/////////////////////////////////////////////////////////////////////
// defenders  return after they are finished.
event defendReturn(defendReturnTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(defendReturn,	inactive);			
	}
	else
	{
		if( defendbusy and (idleGroup(defendGroup) == defendGroup.members))
		{
			orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
			defendbusy = FALSE;
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Research Rules
// do research
event doResearch(doResearchTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(doResearch,	inactive);			
	}
	else
	{
		//if we have a lab
		structure = getStructure(resLab, player);
		if(structure != NULLOBJECT)
		{
			completeResearch(res[curResearch], player);				// do the research.
			if(curResearch < (numResearch- 1))
			{
				curResearch = curResearch + 1;						// move to next topic.
			}
			else
			{		
				setEventTrigger(doResearch,	inactive);				// done researching.
			}
		}	
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Alliance Rules

// form alliances
//event formAllianceEvent(every,3000)
//{
//	if( (player == selectedPlayer) or (not myResponsibility(player)) )
//	{	
//		setEventTrigger(formAllianceEvent,	inactive);			
//	}
//	else
///	{
//		count = 0;
//		while(count<8)
//		{
//			// if not the only other player and rand2
//			if( (random(4) == 1) and (count != player) )
//			{
//				if(isHumanPlayer(count))	// offer if human.	
//				{		
//					offerAlliance(player,count); 			
//				}				
//				else
//				{							// accept if computer
//					createAlliance(player,count);
//				}
//			}
//			count = count + 1;	
//		}
//	}
//}

/////////////////////////////////////////////////////////////////////
// break the alliance too.
//event breakAllianceEvent(every,3000)
//{
//	if( (player == selectedPlayer) or (not myResponsibility(player)) )
//	{	
//		setEventTrigger(breakAllianceEvent,	inactive);			
//	}
//	else
//	{
//		count = 0;
//		while(count<8)
//		{
//			// check if we're in alliance with any other players.
//		
//			if(dominatingAlliance())			// near the end of the game.
//			{
//				breakAlliance(player,count); 
//			}
//			else
//			{	
//				if(random(4) == 1)		// rand 2, possibly break;
//				{
//					breakAlliance(player,count); 
//				}
//			}
//			count = count + 1;
//		}
//	}
//}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Consolidate Rules

// bring forces back together to consolidate attacks
event consolidateEvent(consolidateEventTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(consolidateEvent,	inactive);			
	}
	else
	{
		if(random(3 ) == 1)				// order all droids home to rejoin forces.!
		{
			orderGroupLoc(scoutGroup, DORDER_MOVE,baseX,baseY);
			orderGroupLoc(defendGroup, DORDER_MOVE,baseX,baseY);
		}

		if(attackObj != NULLOBJECT)	// consolidate any ongoing attack.
		{
			orderGroupObj(attackGroup, DORDER_ATTACK,attackObj);
		}
		else
		{
			orderGroupLoc(attackGroup, DORDER_MOVE,baseX,baseY);
		}

	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// power management.

// if running low on power put some power eating stuff on hold for a while.
event managePower(managePowerTr)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(managePower,	inactive);			
	}
	else
	{
		if( playerPower(player) < 250 )	// turn off some events.
		{
			powerSave = TRUE;	

			setEventTrigger(fortify,			inactive);	// stop building defenses.
			setEventTrigger(upgradeStructures,	inactive);	// stop building oil defenses.
			setEventTrigger(buildExpand,		inactive);	// stop building extra buildings.
			setEventTrigger(conDroids,			inactive);	// stop building more construct droids.
		}
		else
		{
			if(powerSave == TRUE)		// turn events back on.
			{
			powerSave = FALSE;
				
			setEventTrigger(fortify,			fortifyTr);			 //  building defenses.
			setEventTrigger(upgradeStructures,	upgradeStructuresTr);//  building oil defenses.
			setEventTrigger(buildExpand,		buildExpandTr);		 //  building extra buildings.
			setEventTrigger(conDroids,			conDroidsTr);	  	 //  building more construct droids.
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// vtols.



/////////////////////////////////////////////////////////////////////
// build vtol strucutures.
event vtolStructs(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolStructs,inactive);			
	}
	else
	{
		structure = getStructure(vtolFactory,player);	// if we dont have vtol factory
		if(structure == NULLOBJECT)						// if missing build it.
		{		
			// build factory
			buildX = baseX;								// pick a location 
			buildY = baseY;
			boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,player);
			if(boolResult == TRUE)
			{
				initIterateGroup(buildGroup);			// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				boolResult = FALSE;						// only send 1 droid to do the job
				while( (boolResult == FALSE) and (droid != NULLOBJECT))
				{
					if( (droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD,vtolFactory, buildX,buildY);
						boolResult = TRUE;
					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
		else	// we have a factory..
		{
			// count rearm pads
			initEnumStruct(FALSE,vtolPad,player,player);
			structure= enumStruct();
			count	 = 0;
			while(structure != NULLOBJECT)	
			{
				count = count + 1;
				structure= enumStruct();
			}

			// do we have 2 or more rearm pads?
			if(count < 3)
			{
				// build vtol rearm pads.
				buildX = baseX;								// pick a location 
				buildY = baseY;
				boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);			// find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while( droid != NULLOBJECT)
					{
						if(droid.order != DORDER_BUILD) 
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,vtolPad, buildX,buildY);
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}


		}
	}
}


/////////////////////////////////////////////////////////////////////
// build vtols.

event buildVtols(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(buildVtols,inactive);			
	}
	else
	{
		structure = getStructure(vtolPad,player);			// got vtol pads?
		if(structure != NULLOBJECT)					
		{
			structure = getStructure(vtolFactory,player);	// got a vtolfac?	
			if(structure != NULLOBJECT)					
			{
				if(vtolGroup.members < 5)					// got enough vtols?
				{
					if( (structureIdle(structure) == TRUE) and (getDroidCount(player) < 80))	// if factory idle
					{
						buildDroid (vtolTemplate, structure, player, 1);// build vtols.
					}
				}
			}
		}
	}
}



/////////////////////////////////////////////////////////////////////
// attack with vtols.

event vtolAttack(inactive)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolAttack,inactive);			
	}
	else
	{
		// if vtol group is not busy..
		if(  (idleGroup(vtolGroup) >= (vtolGroup.members /2)) and (vtolGroup.members > 2) )
		{	
			if(attackObj != NULLOBJECT)
			{
				orderGroupObj(vtolGroup, DORDER_ATTACK,attackObj);	// get the attack target.
			}
			else
			{
				if(defendObj != NULLOBJECT)
				{
					orderGroupObj(vtolGroup, DORDER_ATTACK,defendObj);		// get the defend target
				}
			}
		}
	}
}



/////////////////////////////////////////////////////////////////////
// watch for incoming vtols
event vtolDefend(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj)
{
	if( (player == selectedPlayer) or (not myResponsibility(player)) )
	{	
		setEventTrigger(vtolDefend,inactive);			
	}
	else
	{
		boolResult2 = FALSE;					// if attacked by a vtol.
		if(baseobj != NULLOBJECT)
		{
			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					// activate other vtol functions..
					setEventTrigger(vtolStructs,vtolStructsTr);			
					setEventTrigger(buildVtols,	buildVtolsTr);			
					setEventTrigger(vtolAttack,	vtolAttackTr);			

					// build defenses.
					initIterateGroup(buildGroup);		// find idle droids in build group.
					droid = iterateGroup(buildGroup);
					while( (boolResult2 != TRUE) and (droid != NULLOBJECT))
					{
						if( (structure != NULLOBJECT) and (droid.order != DORDER_BUILD) )
						{	
							buildX = structure.x;				
							buildY = structure.y;
							//	if ! vtol defense already built...
							if(structureBuiltInRange(vtolDefStruct, buildX, buildY, 384, player) == NULLOBJECT)
							{
								boolResult = pickStructLocation(vtolDefStruct, ref buildX, ref buildY,player);
								if(boolResult == TRUE)	// build a vtol defense near the attacked struct...
								{
									orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct,buildX,buildY);
									boolResult2 = TRUE;
								}
							}
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}	
		}
	}
}





