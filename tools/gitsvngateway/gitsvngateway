#!/bin/bash
#       A tool to move commits from svn to git and from git to svn
#       Copyright (C) 2009  Gerard Krol
#       Copyright (C) 2009  Dennis Schridde
#       Copyright (C) 2009  Warzone Resurrection Project
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

usage() {
	echo "USAGE: ${cmd} [options] LOCAL_BRANCH REMOTE_SVN_BRANCH"
}

help() {
	usage
	cat << EOF
Put new commits from LOCAL_BRANCH and REMOTE_SVN_BRANCH on top of each other and commit to SVN and push to Git

Example: "$cmd" master svn/trunk

Options:
  -h, --help           Display this message
  -n, --dry-run        Do not push or commit to SVN and leave branches in their original state
  -p, --prefix=PREFIX  Git branch prefix to use [default: "_gitsvngateway/"]
  -r, --remote=REMOTE  Git rmote to push to [default: "origin"]
  -a, --automatic      Clean up and abort on conflicts
  -f, --no-fetch       Do not initially fetch from SVN to see if there are new commits
EOF
	exit 1
}

die() {
	usage
	echo "ERROR: $1"
	revert_and_exit -1
}

echo_c() {
	echo -n -e "$color"
	echo $*
	echo -n -e "$reset"
}

is_merge() {
	# check if this commit has two parents
	git show --pretty=format:%P "$1" | head -n1 | grep -q " "
}

is_same_commit() {
	log_lines=`git log --pretty=oneline "$1".."$2" | wc -l`
	[ "$log_lines" -eq 0 ]
}

branch_exists() {
	git rev-parse --verify "$1" > /dev/null 2>&1
}

cherry_pick_from() {
	is_merge "$1" && options=--mainline 1
	git cherry-pick $options "$1"
}

revert_and_exit() {
	echo_c '== Reverting changes and exitting'
	git rebase --abort > /dev/null
	git reset -q --hard > /dev/null
	git checkout -q "${prefix}/new/${git_branch}"
	git branch -f "$git_branch" "${prefix}/new/${git_branch}"
	git checkout -q "$git_branch"
	git branch -f "${prefix}/${git_branch}" "${prefix}/backup/${git_branch}"

	git branch -D "${prefix}/backup/${git_branch}" > /dev/null
	git branch -D "${prefix}/tocommit/${svn_branch}" > /dev/null
	git branch -D "${prefix}/new/${git_branch}" > /dev/null

	rm -f "$mergefile"
	exit $1
}


cmd="$0"

color="\033[35m"
reset="\033[0m"

prefix="_gitsvngateway"
remote="origin"
dry_run=false
automatic=false
no_fetch=false
squash=false


[ -x ./git-ssh.sh ] && export GIT_SSH="./git-ssh.sh"


# Check option validity
TEMP=`getopt -o hnp:r:afs --long help,dry-run,prefix:,remote:,automatic,no-fetch,squash \
     -n 'gitsvngateway' -- "$@"`
if [ $? != 0 ] ; then
	usage
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"


# Parse options
while true ; do
	case "$1" in
		-h|--help) usage; ;;
		-n|--dry-run) dry_run=true; shift;;
		-p|--prefix) prefix="$2"; shift 2;;
		-r|--remote) remote="$2"; shift 2;;
		-a|--automatic) automatic=true; shift;;
		-f|--no-fetch) no_fetch=true; shift;;
		-s|--squash) squash=true; shift;;
		--) shift ; break ;;
		*) echo "Internal error!" ; exit 1 ;;
	esac
done


git_branch="$1"
svn_branch="$2"

mergefile="${prefix}.${git_branch}.${svn_branch}.merge"
mergefile="${mergefile//\//_}"


## first run ##

if ! branch_exists "${prefix}/${git_branch}" || ! branch_exists "${prefix}/${svn_branch}" ; then
	echo_c '== Storing pre-commit states'

	git branch "${prefix}/${git_branch}" "$git_branch" || die 'initial-branch:git'
	git branch "${prefix}/${svn_branch}" "$svn_branch" || die 'initial-branch:svn'

	echo_c '== You need to run this command on all branches you want to keep in sync.'
	echo_c '== Otherwise it will not be able to determine which commits from git svn fetch are new.'
	echo_c '== Please do this now and restart this script (with the same arguments) to continue.'
	exit 0
fi


## svn -> git ##

if ! branch_exists "${prefix}/tocommit/${svn_branch}" ; then
	if ! $no_fetch ; then
		echo_c '== Fetching commits from SVN'
		$dry_run || ( git svn fetch || die 'svn-fetch' )
	fi

	if is_same_commit "${prefix}/${svn_branch}" "$svn_branch" && is_same_commit "${prefix}/${git_branch}" "$git_branch" ; then
		echo_c '== No new commits from SVN and no new local commits'
		exit 0
	fi

	# so we can reset it later when the user decides to abort
	git branch "${prefix}/backup/${git_branch}" "${prefix}/${git_branch}" || die 'branch-backup:git'

	# mark current state so we know what the local changes were we need to commit to SVN
	git branch -f "${prefix}/new/${git_branch}" "$git_branch" || die 'branch-new:git'

	if is_same_commit "${prefix}/${svn_branch}" "$svn_branch" ; then
		echo_c '== No new changes from SVN'
	else
		echo_c "== Rebasing commits from ${svn_branch} onto ${git_branch}"
		git branch -f "${prefix}/new/${svn_branch}" "$svn_branch" || die 'branch-new:svn'
		if ! git rebase --onto "$git_branch" "${prefix}/${svn_branch}" "${prefix}/new/${svn_branch}" ; then
			if $automatic ; then
				revert_and_exit 2
			else
				echo_c '== Finish the rebase and restart this script (with the same arguments)'
				exit 2
			fi
		fi
		git branch -f "$git_branch" "${prefix}/new/${svn_branch}" || die 'branch-new:svn:reverse'
		git checkout -q "$git_branch" || die 'checkout:git'
		git branch -D "${prefix}/new/${svn_branch}" > /dev/null || die 'delete-branch:svn-new'
	fi
	git branch "${prefix}/tocommit/${svn_branch}" "$svn_branch" || die 'branch-tocommit:svn'
	rm -f "$mergefile" || die 'rm-mf-1' # make sure we start a new merge
fi


## git -> svn ##

if branch_exists "${prefix}/tocommit/${svn_branch}" ; then

	echo_c "== Rebasing commits from ${git_branch} onto ${svn_branch}"
	git checkout -q "${prefix}/tocommit/${svn_branch}" || die 'checkout:svn:tocommit'
	hashes=`git log --pretty=oneline --first-parent "${prefix}/${git_branch}..${prefix}/new/${git_branch}" | cut -f 1 --delimiter=" " | tac`

	for hash in $hashes ; do
		if is_merge "$hash" ; then
			if ! $squash ; then
				echo_c "== Merge detected for ${hash}"

				echo_c '== Commits contained in this merge:'
				git log --pretty=oneline "${prefix}/${git_branch}..${hash}" | tail -n+2
				amount=`git log --pretty=oneline "${prefix}/${git_branch}..${hash}" | tail -n+2 | wc -l`
				echo_c "== ${amount} commit(s) found, will unravel if 15 or less"
				if [ "$amount" -le 15 ] ; then
					echo_c '== Going ahead with unraveling the merge'
					if ! [ -s "$mergefile" ] ; then
						git log --pretty=oneline "${prefix}/${git_branch}..${hash}" | cut -f 1 --delimiter=" " | tail -n+2 | tac > "$mergefile"
					fi
					hashes2=`cat "$mergefile"`
					echo_c '== Commits still to merge:'
					echo "$hashes2"

					for hash2 in $hashes2 ; do
						echo_c "== Merging ${hash2}"
						# remove the first line from the merge file
						sed -i '1d' "$mergefile"

						if ! cherry_pick_from "$hash2" ; then
							if $automatic ; then
								revert_and_exit 2
							else
								echo_c '== Could not merge! Please fix, commit and restart the script.'
								echo_c '== To use the already existing log message use:'
								echo_c "git commit -a -C ${hash2}"
								exit 2
							fi
						fi
					done
					# cleanup
					rm "$mergefile"
					# to keep track of where we are
					git branch -f "${prefix}/${git_branch}" "$hash" || die 'branch-hash'
					echo_c '== Done processing the merge'
					continue
				else
					echo_c '== Squashing this merge'
				fi
			fi
		fi
		# to keep track of where we are in case of a failed merge
		git branch -f "${prefix}/${git_branch}" "$hash" || die 'branch-hash2'
		if ! cherry_pick_from "$hash" ; then
			if $automatic ; then
				revert_and_exit 2
			else
				echo_c '== Could not merge! Please fix, commit and restart the script.'
				echo_c '== To use the already existing log message use:'
				echo_c "git commit -a -C ${hash}"
				exit 2
			fi
		fi
	done

	# everything is done, try to get it back into SVN and origin

	if ! is_same_commit "${svn_branch}" "${prefix}/tocommit/${svn_branch}" ; then
		echo
		echo_c '== These changes are staged for commit to SVN:'
		git log "${svn_branch}..${prefix}/tocommit/${svn_branch}" | cat
		if ! $automatic ; then
			echo_c -n -e '\nDo you want to commit these changes to SVN? [Y/n]: '
			read -n1 answer
			echo_c
		fi
		if $automatic || [ "x$answer" == "x" ] ; then
			echo_c '== Committing to SVN'
			$dry_run || git svn dcommit
			echo_c '== Getting back the changes from SVN'
			$dry_run || git svn fetch
		else
			revert_and_exit 1
		fi
	else
		echo_c '== Nothing to commit to SVN'
	fi

	git checkout -q "$git_branch" || die 'checkout:git2'

	if ! is_same_commit "${remote}/${git_branch}" "$git_branch" ; then
		echo_c "== Pushing the changes to ${remote}"
		$dry_run || git push "$remote" "$git_branch"
	else
		echo_c "== No local changes, so not pushing to ${remote}"
	fi

	if ! $dry_run ; then
		echo_c "== Marking current state of ${git_branch} and ${svn_branch}"
		git branch -f "${prefix}/${git_branch}" "$git_branch" || die 'branch:git12'
		git branch -f "${prefix}/${svn_branch}" "$svn_branch" || die 'branch:svn12'
	else
		revert_and_exit 0
	fi

	git branch -D "${prefix}/backup/${git_branch}" > /dev/null || die 'delete-branch-backup'
	git branch -D "${prefix}/tocommit/${svn_branch}" > /dev/null || die 'delete-branch-tocommit'
	git branch -D "${prefix}/new/${git_branch}" > /dev/null || die 'delete-branch-new'
	exit 0
fi

echo_c '== Not supposed to reach this line!'
exit 1
