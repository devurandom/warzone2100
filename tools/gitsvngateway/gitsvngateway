#!/bin/bash
#       A tool to move commits from svn to git and from git to svn
#       Copyright (C) 2009  Warzone Resurrection Project
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

color="\033[35m"
reset="\033[0m"

function echo_c {
	echo -n -e "$color"
	echo $*
	echo -n -e "$reset"
}

function is_merge {
	git show --raw $1 | grep -q "Merge:"
	return $?
}

if [ $# -ne 2 ]
then
	echo_c "Usage: gitsvngateway [local branch] [svn remote branch]"
	echo_c "If you want to reset the state of this script remove the gitsvngateway.*.*.state file."
	echo_c "This script assumes that your public git repository is \"origin\""
	exit
fi

git=$1
svn=$2
statefile="gitsvngateway.$git.$svn.state"
statefile=${statefile//\//_}

if [ -e $statefile ]
then
	state=`cat "$statefile"`
else
	state=init
fi

echo_c "== Current state: ${state}"

# svn -> git

if [ "$state" = "init" ]
then

	echo_c "== Storing pre-commit states"
	git branch ${git}_old ${git}
	git branch ${svn}_old ${svn}
	state=svn2git
	echo $state > "$statefile"

	echo_c "== You need to run this command on all branches you want to keep in sync."
	echo_c "== Otherwise it will not be able to determine which commits from git svn fetch are new."
	echo_c "== Please do this now and restart this script (with the same arguments) to continue."
	exit 1
fi

if [ "$state" = "svn2git" ]
then
	echo_c "== Marking current state of ${git}"
	git branch -f ${git}_new ${git}

	echo_c "== Fetching commits from SVN"
	git svn fetch

	echo_c "== Rebasing commits from ${svn} onto ${git}"
	git branch -f ${svn}_new ${svn}
	if ! git rebase -p --onto ${git} ${svn}_old ${svn}_new
	then
		echo_c svn2git_rebase_complete > "$statefile"
		echo_c "== Finish the rebase and restart this script (with the same arguments)"
		exit 2
	fi
	state=svn2git_rebase_complete
	echo $state > "$statefile"
fi

if [ "$state" = "svn2git_rebase_complete" ]
then
	echo_c "== ${svn}_new is the new ${git}"
	git branch -f ${git} ${svn}_new

	# git -> svn
	# so we can reset it later when the user decides to abort
	git branch ${git}_old_backup ${git}_old

	echo_c "== Rebasing commits from ${git} onto ${svn}"
	git branch ${svn}_tocommit ${svn}
	git checkout ${svn}_tocommit
	hashes=`git log --pretty=oneline --first-parent ${git}_old..${git}_new | cut -f 1 --delimiter=" " | tac`

	for hash in $hashes; do

		if is_merge $hash
		then
			echo_c "== Merge detected for $hash"
			echo_c "== Commits contained in this merge:"
			git log --pretty=oneline ${git}_old..$hash | tail -n+2
			amount=`git log --pretty=oneline ${git}_old..$hash | tail -n+2 | wc -l`
			echo_c "== $amount commit(s) found, will unravel if 10 or less"
			if [ $amount -le 10 ]
			then
				echo_c "== Going ahead with unraveling the merge"
				filename=gitsvngateway.$hash.merge
				if ! [ -s $filename ]
				then
					git log --pretty=oneline ${git}_old..$hash | cut -f 1 --delimiter=" " | tail -n+2 | tac > $filename
				fi
				hashes2=`cat $filename`
				echo_c "== List of hashes still to merge:"
				cat $filename

				for hash2 in $hashes2; do
					echo_c "== Merging $hash2"
					# remove the first line from the merge file
					tail -n+2 $filename > ${filename}2
					mv ${filename}2 $filename

					mainline=
					test is_merge $hash2 && mainline=-m1
					if ! git cherry-pick $mainline $hash2
					then
						echo_c "== Could not merge! Please fix this and commit."
						echo_c "== To use the already existing log message use:"
						echo_c "git commit -a -C $hash2"
						exit
					fi
				done
				# cleanum
				rm $filename
				# to keep track of where we are
				git branch -f ${git}_old $hash
				echo_c "== Done processing the merge"
				continue
			else
				echo_c "== Squashing this merge"
			fi
		fi
		mainline=
		test is_merge $hash2 && mainline=-m1
		if ! git cherry-pick $mainline $hash
		then
			echo_c "== Could not merge! Please fix this and commit."
			echo_c "== To use the already existing log message use:"
			echo_c "git commit -a -C $hash"
			# to keep track of where we are
			git branch -f ${git}_old $hash
			exit
		fi
		git branch -f ${git}_old $hash
	done

	state=git2svn_rebase_complete
	echo $state > "$statefile"
fi

if [ "$state" = "git2svn_rebase_complete" ]
then
	echo
	echo_c "== These changes are staged for commit to SVN:"
	git log ${svn}..${svn}_tocommit
	echo_c -n -e "\nDo you want to commit these changes to SVN? [Y/n]: "
	read -n1 answer
	echo_c
	if [ "x$answer" == "x" ]
	then
		echo_c "== Committing to SVN"
		git svn dcommit
	else
		echo_c "== Cleaning up"
		git branch -f ${git} ${git}_new
		git checkout ${git}
		git branch -f ${git}_old ${git}_old_backup
		git branch -D ${git}_old_backup
		git branch -D ${svn}_tocommit
		git branch -D ${git}_new
		git branch -D ${svn}_new
		echo svn2git > "$statefile"
		exit
	fi

	echo_c "== Getting back the changes from SVN"
	git svn fetch

	echo_c "== Checking out master"
	git checkout ${git}
	git branch -D ${git}_old_backup
	git branch -D ${svn}_tocommit
	git branch -D ${git}_new
	git branch -D ${svn}_new

	echo_c "== Pushing the changes to origin"
	git push origin ${git}

	echo_c "== Marking current state of ${git} and ${svn}"
	git branch -f ${git}_old ${git}
	git branch -f ${svn}_old ${svn}

	echo svn2git > "$statefile"
fi
